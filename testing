    repeat
        task.wait()
    until game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and game.Players.LocalPlayer.Character.Humanoid.Health > 0
    
    VirtualUser = game:GetService('VirtualUser')
    
    	game:GetService('Players').LocalPlayer.Idled:Connect(function()
    	    VirtualUser:CaptureController()
    	    VirtualUser:ClickButton2(Vector2.new())
    	end)
    
    if game:GetService("CoreGui"):FindFirstChild("HaxterHub V6") then
        return
    end
    
    if game.PlaceId == 6884319169 or game.PlaceId == 15546218972 or game.PlaceId == 17473325951 then
    success, vermLib = pcall(loadstring(game:HttpGet("https://raw.githubusercontent.com/FelixHaxter/HaxterHub-/refs/heads/main/HaxterHub%20UI%20Library")))
    if not success then
        return
    end
    window = vermLib:CreateWindow()
    main = window:CreateTab("main", "Main", "") 
    Player = window:CreateTab("Player", "LocalPlayer", "")
    Reanimate = window:CreateTab("Reanimate", "Reanimate", "")
    Visuals = window:CreateTab("Visuals", "Visuals", "")
    Environment = window:CreateTab("Environment", "Environment", "")
    Animations = window:CreateTab("Animations", "Animations", "") 
    Target = window:CreateTab("Target", "Target", "")
    Universal = window:CreateTab("Universal", "Universal", "")
    Server = window:CreateTab("Server", "Server", "")
    Credits = window:CreateTab("Credits", "Credits", "")
    UserInputService = game:GetService("UserInputService")
    UserInputService = cloneref(game:GetService("UserInputService"))
    Players = game:GetService("Players")
    IsOnMobile = table.find({Enum.Platform.IOS, Enum.Platform.Android}, UserInputService:GetPlatform())
    RunService = game:GetService("RunService")
    plr = Players.LocalPlayer
    workspace = game.Workspace
    mouse = plr:GetMouse()
    flying = false
    ctrl = {f = 0, b = 0, l = 0, r = 0}
    currentAnim = nil
    plr.CameraMaxZoomDistance = 800000
    ScreenGui = Instance.new("ScreenGui", game.CoreGui)
    uis, mode = game:GetService("UserInputService"), ""
    R15reanimated = false 
    R6reanimated = false 
    EmotePlayingR15 = false
    euler, sin, sine, abs, clamp = CFrame.fromEulerAnglesXYZ, math.sin, 0, math.abs, math.clamp
    CachedKeyframes = {}
    LoadingKeyFrames = {}
    mouse = plr:GetMouse()
    FlySpeed = 30  
    velocityHandlerName = "VelocityHandler"
    gyroHandlerName = "GyroHandler"
    cf = CFrame.new

     function cfMul(a, b)
        return a * b
    end
    
    function StopAnimTrackss()
        plr.Character.Animate.Disabled = false
        local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
        for _, track in pairs(animtrack) do
            track:Stop()
        end
    end
    
    function angles(x, y, z)
        return CFrame.Angles(x, y, z)
    end


    game.Workspace.FallenPartsDestroyHeight = 0/0
    local HaxterFelix = {
        "Back Handstand", "Chest Lay", "Corruption",  "Sit Jerk", 
        "Jerking Off", "Unknown", "Invisible"
    }

    local Shavine = {
        "Emoter", "spaghetti",
        "No", "Yes", "Wave", "Point", "Scared", "AMOGUS",
        "Chase", "Laugh", "CHAOS", "mayhem", "Tornado", "equinox", "ragdoll", "reverse ragdoll",
        "Pogo Stick", "fishy business", "siezrure funnier", "siezrure 2", "Sonic", "Creature", "ERRAH", 
        "Bacon God", "Dragged away"
    }
    local CustomBundle = {
        "Ghoul", "Mario", "Sonic", "Steve", "Sk8tr", "Garry's Mod", "Jolly", "None"
    }
    local Random = {
        "laying", 
        "sit", "rickroll", "wave", "dab", "blaze", "T", "float", "floss", "emote", 
        "pushups", "kazotsky", "L", "goofy trolus", "fe creepy crawler"
    }
    local SolvexAnimation = {
        "Cry baby"
    }
    local TargetAnimation = {
        "Hawk Tuah", "Lap Dance", 
        "Thrust On Face", "Back Fuck"
    }
    local selectedAnimationMode = ""
    function PlayAnim(id, time, speed)
    local hum = plr.Character:WaitForChild("Humanoid")
    local animtrack = hum:GetPlayingAnimationTracks()
    for _, track in pairs(animtrack) do
        track:Stop()
    end
    local Anim = Instance.new("Animation")
    Anim.AnimationId = "rbxassetid://"..id
    local loadanim = hum:LoadAnimation(Anim)
    loadanim:Play()
    loadanim.TimePosition = time
    loadanim:AdjustSpeed(speed)
    currentAnim = loadanim
    end
    function StopAllAnims()
    if currentAnim then
        currentAnim:Stop()
        currentAnim = nil
    end
    end
    local AllBool = false
    local Targetnms = ""
    local OriginalCFrame 
    
    local GetPlayer = function(Name)
        Name = Name:lower()
        if Name == "all" or Name == "others" then
            AllBool = true
            return
        elseif Name == "random" then
            local GetPlayers = Players:GetPlayers()
            if table.find(GetPlayers, Player) then 
                table.remove(GetPlayers, table.find(GetPlayers, Player)) 
            end
            return GetPlayers[math.random(#GetPlayers)]
        else
            for _, x in next, Players:GetPlayers() do
                if x ~= Player then
                    if x.Name:lower():match("^" .. Name) or x.DisplayName:lower():match("^" .. Name) then
                        return x
                    end
                end
            end
        end
    end

    
    function deepSearchAndProcess(parent)
        for _, child in ipairs(parent:GetChildren()) do
            
            if child:IsA("Script") and child.Name == "Kill" then
                
                local parentOfKill = child.Parent
                if parentOfKill then
                    parentOfKill:Destroy()
                end
                return  
            end
            
            
            if child:IsA("Texture") and child.Name == "Texture" then
                local parentOfTexture = child.Parent
                local grandparentOfTexture = parentOfTexture.Parent
                
                
                if grandparentOfTexture and grandparentOfTexture.Name == "Room" then
                    parentOfTexture.CanCollide = true
                end
                
                return  
            end
            
            deepSearchAndProcess(child)  
        end
    end
    
    
    deepSearchAndProcess(game:GetService("Workspace"))
    

    function Message(title, text, duration)
        local TweenService = game:GetService("TweenService")
        local notificationFrame = Instance.new("Frame")
        notificationFrame.Size = UDim2.new(0.150000006, 0, 0.0599999987, 0) 
        notificationFrame.Position = UDim2.new(0.370000005, 0, 0, -500) 
        notificationFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0) 
        notificationFrame.BackgroundTransparency = 0
        notificationFrame.BorderSizePixel = 0
        notificationFrame.ClipsDescendants = true
        notificationFrame.Parent = ScreenGui
    
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10) 
        corner.Parent = notificationFrame
    
        
        local titleLabel = Instance.new("TextLabel")
        titleLabel.Size = UDim2.new(1, 0, 0.5, 0) 
        titleLabel.Text = title
        titleLabel.TextColor3 = Color3.fromRGB(179, 0, 255) 
        titleLabel.BackgroundTransparency = 1 
        titleLabel.Parent = notificationFrame
        titleLabel.TextSize = 14
    
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 0.5, 0) 
        textLabel.Position = UDim2.new(0, 0, 0.5, 0) 
        textLabel.Text = text
        textLabel.TextColor3 = Color3.fromRGB(179, 0, 255) 
        textLabel.BackgroundTransparency = 1 
        textLabel.Parent = notificationFrame
        textLabel.TextSize = 14
        
        local tweenPosition = TweenService:Create(notificationFrame, TweenInfo.new(0.5), {
            Position = UDim2.new(0.430000007, 0, 0, 0) 
        })
    
        
        local fadeDuration = 0.6
        local tweenTransparencyFrame = TweenService:Create(notificationFrame, TweenInfo.new(fadeDuration), {
            BackgroundTransparency = 1
        })
        
        local tweenTransparencyTitle = TweenService:Create(titleLabel, TweenInfo.new(fadeDuration), {
            TextTransparency = 1
        })
    
        local tweenTransparencyText = TweenService:Create(textLabel, TweenInfo.new(fadeDuration), {
            TextTransparency = 1
        })
    
        
        tweenPosition:Play()
        tweenPosition.Completed:Wait() 
        wait(duration) 
    
        
        tweenTransparencyFrame:Play()
        tweenTransparencyTitle:Play()
        tweenTransparencyText:Play()
    
        
        tweenTransparencyFrame.Completed:Wait() 
    end

    
    function removeBloxiliciousTool(player)
    
    local backpack = player:FindFirstChild("Backpack")
    if backpack then
        local tool = backpack:FindFirstChild("Bloxilicious")
        if tool then
            tool:Destroy() 
        end
    end

    
    local character = player.Character or player.CharacterAdded:Wait()
    if character then
        local tool = character:FindFirstChild("Bloxilicious")
        if tool then
            tool:Destroy() 
        end
    end
    end
    function ToolEsp() 
        for _, v in pairs(game:GetService("Players"):GetPlayers()) do
            if v ~= game:GetService("Players").LocalPlayer then
                local character = v.Character
                if character and character:FindFirstChild("Head") and character.Head:FindFirstChild("Name") == nil then
                    local head = character.Head
                    local a = Instance.new("BillboardGui", head)
                    a.Name = "Name"
                    a.AlwaysOnTop = true
                    a.Size = UDim2.new(8, 0, 1.5, 0)
                    a.StudsOffsetWorldSpace = Vector3.new(0, 2.635981321334839, 0)
                    local b = Instance.new("Frame", a)
                    b.Size = UDim2.new(1, 0, 1, 0)
                    b.BackgroundTransparency = 1
                    b.BorderSizePixel = 0
                    local c = Instance.new("TextLabel", b)
                    c.Text = v.Name
                    c.TextColor3 = Color3.fromRGB(125, 125, 125)
                    c.Size = UDim2.new(1, 0, 0.5, 0)
                    c.BackgroundTransparency = 1
                    c.BorderSizePixel = 0
                    c.TextSize = 12
                    c.TextStrokeTransparency = 0.7
                    c.TextScaled = true
                    c.RichText = true
                    c.TextWrapped = false
                end
            end
        end
    end
    function ApplyESP() 
    for _, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v ~= game:GetService("Players").LocalPlayer then
    local character = v.Character
    if character and character:FindFirstChild("HumanoidRootPart") and character.HumanoidRootPart:FindFirstChild("Name") == nil then
        local HumanoidRootPart = character.HumanoidRootPart
        local a = Instance.new("BillboardGui", HumanoidRootPart)
        a.Name = "Name"
        a.AlwaysOnTop = true
        a.Size = UDim2.new(8, 0, 1.5, 0)
        a.StudsOffsetWorldSpace = Vector3.new(0, 2.635981321334839, 0)
        local b = Instance.new("Frame", a)
        b.Size = UDim2.new(1, 0, 1, 0)
        b.BackgroundTransparency = 1
        b.BorderSizePixel = 0
        local c = Instance.new("TextLabel", b)
        c.Text = v.Name
        c.TextColor3 = Color3.fromRGB(125, 125, 125)
        c.Size = UDim2.new(1, 0, 0.5, 0)
        c.BackgroundTransparency = 1
        c.BorderSizePixel = 0
        c.TextSize = 12
        c.TextStrokeTransparency = 0.7
        c.TextScaled = true
        c.RichText = true
        c.TextWrapped = false
    end
    end
    end
    end



    function ApplyChams(player)
        
        if player == game.Players.LocalPlayer then
            return
        end
        
        if player.Character then
            if player.Character:FindFirstChild("Highlight") == nil then
                local char = player.Character
                local highlight = Instance.new("Highlight", char)
                highlight.FillTransparency = 0.9
                highlight.FillColor = Color3.fromRGB(20, 37, 135)
                highlight.OutlineTransparency = 0.6
            end
        end
    end
    
    local gameModel = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Game")
    if gameModel then
    for _, model in ipairs(gameModel:GetChildren()) do
    	if model:IsA("Model") and model:FindFirstChild("Slot") then
    		local success, pos = pcall(function()
    			return model:GetPivot().Position
    		end)

    		if success and pos then
    			local isTicTacToe2 = pos:FuzzyEq(Vector3.new(719.7562255859375, 17.872467041015625, -190.75), 0.1)
    			if isTicTacToe2 and model.Name ~= "TicTacToe2" then
    				model.Name = "TicTacToe2"
    			elseif not isTicTacToe2 and model.Name ~= "TicTacToe1" then
    				model.Name = "TicTacToe1"
    			end
    		end
    	end
    end
    local TicTacToeBoardOption = "TicTacToe1"
    function getBoardModel()
    	local gameModel = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Game")
    	if not gameModel then return nil end
    	return gameModel:FindFirstChild(TicTacToeBoardOption)
    end

    function getBoardRoot()
    	local model = getBoardModel()
    	return model and model:FindFirstChild("Slot")
    end
    local boardRoot = getBoardRoot()

    if not boardRoot then warn("Board not found or not labeled.") return end

    local ChosenColor = "Green"
    local runService = game:GetService("RunService")
    local MoveOptions = {"Green", "Blue"} 
    local MoveOption = "Green" 
    local TTTDelay = 0.6
    getgenv().TTTAutoPlay = false

    local GREEN = Color3.fromRGB(76, 184, 93)
    local BLUE = Color3.fromRGB(43, 133, 141)
    local myColor, opponentColor


    local cellOrder = {}
    for r = 1, 3 do
    	for c = 1, 3 do
    		table.insert(cellOrder, {row = r, col = c})
    	end
    end

    function getCircle(r, c)
    	local boardRoot = getBoardRoot()
    	if not boardRoot then return nil end
    	local slot = boardRoot:FindFirstChild("Slot0" .. r)
    	return slot and slot:FindFirstChild("Circle0" .. c)
    end

    function getClickDetector(r, c)
    	local boardRoot = getBoardRoot()
    	if not boardRoot then return nil end
    	local slot = boardRoot:FindFirstChild("Slot0" .. r)
    	local part = slot and slot:FindFirstChild("Slot0" .. c)
    	return part and part:FindFirstChild("ClickDetector")
    end

    function isRoundOver()
    	for _, pos in ipairs(cellOrder) do
    		local circle = getCircle(pos.row, pos.col)
    		if circle and circle.Material == Enum.Material.Neon then
    			return true
    		end
    	end
    	return false
    end

    function allCirclesFilled()
    	for _, pos in ipairs(cellOrder) do
    		local circle = getCircle(pos.row, pos.col)
    		if circle and circle.Transparency == 1 then
    			return false
    		end
    	end
    	return true
    end

    function waitUntilNoNeon()
    	while isRoundOver() do task.wait(0.2) end
    end

    function getBoardState()
    	local state = {}
    	for i, pos in ipairs(cellOrder) do
    		local circle = getCircle(pos.row, pos.col)
    		if circle and circle.Transparency == 0 then
    			state[i] = {
    				color = circle.Color,
    				material = circle.Material,
    				row = pos.row,
    				col = pos.col,
    			}
    		end
    	end
    	return state
    end

    function isMyTurn()
    	local myMoves, theirMoves = 0, 0
    	for _, cell in pairs(getBoardState()) do
    		if cell.color == myColor then myMoves += 1
    		elseif cell.color == opponentColor then theirMoves += 1 end
    	end
    	if myColor == GREEN then
    		return myMoves == theirMoves
    	else
    		return myMoves < theirMoves
    	end
    end

    function indexToPosition(index)
    	if not index then return nil, nil end
    	local row = math.floor((index - 1) / 3) + 1
    	local col = ((index - 1) % 3) + 1
    	return row, col
    end

    function makeMove(row, col)
    	local detector = getClickDetector(row, col)
    	local circle = getCircle(row, col)
    	if detector and circle and circle.Transparency == 1 then
    		fireclickdetector(detector)
    		print("Clicked:", row, col)

        
    		local timeout = 3
    		local start = tick()
    		repeat task.wait(0.1)
    		until circle.Transparency == 0 or tick() - start > timeout
    	end
    end


    function getSimpleBoard()
    	local board = {}
    	for i = 1, 9 do board[i] = nil end
    	for i, pos in ipairs(cellOrder) do
    		local circle = getCircle(pos.row, pos.col)
    		if circle and circle.Transparency == 0 then
    			if circle.Color == myColor then
    				board[i] = "AI"
    			elseif circle.Color == opponentColor then
    				board[i] = "Opponent"
    			end
    		end
    	end
    	return board
    end

    function checkWin(board, who)
    	local winCombos = {
    		{1,2,3},{4,5,6},{7,8,9},
    		{1,4,7},{2,5,8},{3,6,9},
    		{1,5,9},{3,5,7},
    	}
    	for _, combo in ipairs(winCombos) do
    		if board[combo[1]] == who and board[combo[2]] == who and board[combo[3]] == who then
    			return true
    		end
    	end
    	return false
    end

    function isDraw(board)
    	for i = 1, 9 do if not board[i] then return false end end
    	return true
    end

    function minimax(board, depth, isMaximizing)
    	if checkWin(board, "AI") then return 10 - depth end
    	if checkWin(board, "Opponent") then return depth - 10 end
    	if isDraw(board) then return 0 end

    	if isMaximizing then
    		local bestScore = -math.huge
    		for i = 1, 9 do
    			if not board[i] then
    				board[i] = "AI"
    				local score = minimax(board, depth + 1, false)
    				board[i] = nil
    				bestScore = math.max(bestScore, score)
    			end
    		end
    		return bestScore
    	else
    		local bestScore = math.huge
    		for i = 1, 9 do
    			if not board[i] then
    				board[i] = "Opponent"
    				local score = minimax(board, depth + 1, true)
    				board[i] = nil
    				bestScore = math.min(bestScore, score)
    			end
    		end
    		return bestScore
    	end
    end

    function getBestMove()
    	local board = getSimpleBoard()
    	local bestScore = -math.huge
    	local move = nil

    	for i = 1, 9 do
    		if not board[i] then
    			board[i] = "AI"
    			local score = minimax(board, 0, false)
    			board[i] = nil
    			if score > bestScore then
    				bestScore = score
    				move = i
    			end
    		end
    	end

    	if move then
    		return indexToPosition(move)
    	else
    		return nil, nil
    	end
    end



    task.spawn(function()
    	while true do
    		task.wait(0.2)
    		if not getgenv().TTTAutoPlay or ChosenColor ~= "Green" then continue end

            if not myColor then
            	myColor = (MoveOption == "Green") and GREEN or BLUE
            	opponentColor = (MoveOption == "Green") and BLUE or GREEN
            end


    		if isRoundOver() then
    			waitUntilNoNeon()
    			repeat task.wait(0.2) until #getBoardState() == 0
    			myColor, opponentColor = GREEN, BLUE
    		elseif allCirclesFilled() then
    			repeat task.wait(0.2) until isRoundOver() or #getBoardState() == 0
    		end

    		if isMyTurn() then
    			task.wait(TTTDelay)

    			local boardState = getBoardState()
    			if #boardState == 0 then
    				local empty = {}
    				for _, pos in ipairs(cellOrder) do
    					local circle = getCircle(pos.row, pos.col)
    					if circle and circle.Transparency == 1 then
    						table.insert(empty, {row = pos.row, col = pos.col})
    					end
    				end
    				if #empty > 0 then
    					local pick = empty[math.random(1, #empty)]
    					makeMove(pick.row, pick.col)
    				end
    			else
    				local row, col = getBestMove()
    				if row and col then
    					makeMove(row, col)
    				end
    			end
    		end
    	end
    end)


    task.spawn(function()
    	while true do
    		task.wait(0.2)
    		if not getgenv().TTTAutoPlay or ChosenColor ~= "Blue" then continue end

            if not myColor then
            	myColor = (MoveOption == "Green") and GREEN or BLUE
            	opponentColor = (MoveOption == "Green") and BLUE or GREEN
            end


    		if isRoundOver() then
    			waitUntilNoNeon()
    			repeat task.wait(0.2) until #getBoardState() == 0
    			myColor, opponentColor = BLUE, GREEN
    		elseif allCirclesFilled() then
    			repeat task.wait(0.2) until isRoundOver() or #getBoardState() == 0
    		end

            local boardState = getBoardState()
            local greenMoved = false
            for _, cell in pairs(boardState) do
            	if cell.color == GREEN then
            		greenMoved = true
            		break
            	end
            end
            if not greenMoved then
            	continue 
            end

    		if isMyTurn() then
    			task.wait(TTTDelay)
    			local row, col = getBestMove()
    			if row and col then
    				makeMove(row, col)
    			end
    		end
    	end
    end)

    function autoLabelBoards()
    	local gameModel = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Game")
    	if not gameModel then return end

    	for _, model in ipairs(gameModel:GetChildren()) do
    		if model:IsA("Model") and model:FindFirstChild("Slot") then
    			local success, cframe = pcall(function() return model.WorldPivot end)
    			if success then
    				local pos = cframe.Position
    				if (pos - Vector3.new(719.756226, 17.872467, -190.75)).Magnitude < 0.1 then
    					if model.Name ~= "TicTacToe2" then
    						model.Name = "TicTacToe2"
    					end
    				elseif (pos - Vector3.new(502.756226, 19.75, -216.877747)).Magnitude < 0.1 then
    					if model.Name ~= "TicTacToe1" then
    						model.Name = "TicTacToe1"
    					end
    				end
    			end
    		end
    	end
    end

    autoLabelBoards()

    main:CreateToggle("Tic Tac Toe Auto Play", function(val)
    	getgenv().TTTAutoPlay = val
    end)

    main:CreateSlider("Next Move Delay", 0, 10, 0.6, function(val)
    	local num = tonumber(val)
    	if num and num >= 0 then TTTDelay = num end
    end)


    local BoardOptions = {"1", "2"}
    main:CreateDropdown("TicTacToe Board", BoardOptions, function(option)
    	if option == "1" then
    		TicTacToeBoardOption = "TicTacToe1"
    	elseif option == "2" then
    		TicTacToeBoardOption = "TicTacToe2"
    	end
    end)

    main:CreateDropdown("Move Option", MoveOptions, function(option)
    	MoveOption = option
    	myColor = nil
    	opponentColor = nil
    	ChosenColor = option
    end)
    end
        main:CreateToggle("Avoid Tool Abusers (Lag)", function(AvoidLagTools)
            getgenv().AvoidLagToolss = AvoidLagTools
            while true do 
                wait(0)
                if not getgenv().AvoidLagToolss then
                    return 
                end


                for _, player in ipairs(Players:GetPlayers()) do
                    removeBloxiliciousTool(player)
                end
            end
        end)

            main:CreateButton("Teleport To AvatarUI", function()
                local character = plr.Character or plr.CharacterAdded:Wait()


                local Avatar_UI = game.Workspace.Map.GameAvatar.Model.Avatar

                if Avatar_UI then
                        local AvatarUIPosition = Avatar_UI.Position


                        local teleportPosition = AvatarUIPosition + Vector3.new(-10, 0, 0)  


                        local rayOrigin = teleportPosition + Vector3.new(0, 0, 0)  
                        local rayDirection = Vector3.new(0, 0, 0)  
                        local raycastResult = workspace:Raycast(rayOrigin, rayDirection)
                
                        if raycastResult then

                            teleportPosition = raycastResult.Position
                        else

                        end
                        local rotation = CFrame.Angles(0, math.rad(-90), 0)  
                        character:SetPrimaryPartCFrame(CFrame.new(teleportPosition) * rotation)
                end
                                    end)
                                
                    main:CreateToggle("Auto Dislike", function(Auto_Dislike)
                        getgenv().Auto_Dislikes = Auto_Dislike
                        while true do
                            if not getgenv().Auto_Dislikes then
                                return 
                            end
                            local Avatar_UI = game.Workspace.Map.GameAvatar.Model.DislikeButton

                            if Avatar_UI then
                                local Dislike_Button = Avatar_UI
                                local Click_Detector_Input = Dislike_Button:FindFirstChild("ClickDetector")

                                if Click_Detector_Input then
                                    fireclickdetector(game.Workspace.Map.GameAvatar.Model.DislikeButton.ClickDetector)
                                else

                                end
                            else

                            end

                            wait(1)
                        end
                    end)

                    main:CreateToggle("Auto Like", function(Auto_Like)
                        getgenv().Auto_Likes = Auto_Like
                        while true do
                            if not getgenv().Auto_Likes then
                                return 
                            end

                            local Avatar_UI = game.Workspace.Map.GameAvatar.Model.LikeButton

                            if Avatar_UI then
                                local Like_Button = Avatar_UI
                                local Click_Detector_Input = Like_Button:FindFirstChild("ClickDetector")

                                if Click_Detector_Input then
                                    fireclickdetector(game.Workspace.Map.GameAvatar.Model.LikeButton.ClickDetector)
                                else

                                end
                            else

                            end

                            wait(1)
                        end
                    end)

                

            Visuals:CreateToggle("Player ESP", function(PlayerESO)
                getgenv().PlayerESP = PlayerESO
                while true do
                    if getgenv().PlayerESP then
                        ApplyESP()
                    else
                        for _, v in pairs(game:GetService("Players"):GetPlayers()) do
                            if v ~= game:GetService("Players").LocalPlayer then
                                local character = v.Character
                                if character and character:FindFirstChild("HumanoidRootPart") then
                                    local HumanoidRootPart = character.HumanoidRootPart
                                    local nameGui = HumanoidRootPart:FindFirstChild("Name")
                                    if nameGui then
                                        nameGui:Destroy()
                                    end
                                end
                            end
                        end
                    end
                    wait(1) 
                end
            end)
        

            local playerAddedConnection
            local characterAddedConnections = {}


            Visuals:CreateToggle("Player Chams", function(PlayerChams)
                getgenv().PlayerChamss = PlayerChams
            
                if PlayerChamss then

                    playerAddedConnection = Players.PlayerAdded:Connect(function(player)
                        characterAddedConnections[player.UserId] = player.CharacterAdded:Connect(function(character)
                            ApplyChams(player)
                        end)
                    end)
                

                    for _, player in pairs(Players:GetPlayers()) do
                        characterAddedConnections[player.UserId] = player.CharacterAdded:Connect(function(character)
                            ApplyChams(player)
                        end)
                        ApplyChams(player)
                    end
                else

                    if playerAddedConnection then
                        playerAddedConnection:Disconnect()
                        playerAddedConnection = nil
                    end

                    for _, player in pairs(Players:GetPlayers()) do
                        if characterAddedConnections[player.UserId] then
                            characterAddedConnections[player.UserId]:Disconnect()
                            characterAddedConnections[player.UserId] = nil
                        end

                        if player.Character then
                            local highlight = player.Character:FindFirstChild("Highlight")
                            if highlight then
                                highlight:Destroy()
                            end
                        end
                    end
                end
            end)

    
    local RunService = game:GetService("RunService")
    
    getgenv().AimAtHeadEnabled = false 
    Universal:CreateButton("Universal Emotes", function(state)
        loadstring(game:HttpGet("https://raw.githubusercontent.com/LmaoItsCrazyBro/qweytguqwebuqt/refs/heads/main/marked_esp_system_ai"))()
    end)
    Universal:CreateButton("Infinite Yield", function(state)
        loadstring(game:HttpGet(('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'),true))()
    end)
    local R67 = 0.65
    local R157 = 0.65 
    local tpwalking = false 
    local teleportWalkValue = 1 
    local CurrentTeleportWalk = 0 
    
    function startTeleportWalking()
        tpwalking = true
        local chr = plr.Character
        local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
        local hb = game:GetService("RunService").Heartbeat
    
        while tpwalking and chr and hum and hum.Parent do
            local delta = hb:Wait()
            if hum.MoveDirection.Magnitude > 0 then
                chr:TranslateBy(hum.MoveDirection * (teleportWalkValue + CurrentTeleportWalk) * delta)
            end
        end
    end
    
    
    local isQPressed = false
    local isRPressed = false
    
    function incrementTeleportWalk()
        while isQPressed do
            CurrentTeleportWalk = CurrentTeleportWalk + 1 
            wait(0.05) 
        end
    end
    function adjustWalkSpeed()
        if plr.Character and plr.Character:FindFirstChild("Humanoid") then
            plr.Character.Humanoid.WalkSpeed = math.max(1, walkSpeeder)
        end
    end
    
    function holdKeyAdjustment(amount)
        while isQPressed or isRPressed do
            walkSpeeder = math.max(1, walkSpeeder + amount)
            adjustWalkSpeed()
            wait(0.05) 
        end
    end
    UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
        if not gameProcessedEvent then
            if input.KeyCode == Enum.KeyCode.Q then
                if not isQPressed then
                    isQPressed = true
                    coroutine.wrap(incrementTeleportWalk)() 
                    startTeleportWalking() 
                end
            elseif input.KeyCode == Enum.KeyCode.R then
                if not isRPressed then
                    isRPressed = true
                    tpwalking = false 
                    CurrentTeleportWalk = 0 
                    teleportWalkValue = 1 
                end
            end
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
        if not gameProcessedEvent then
            if input.KeyCode == Enum.KeyCode.Q then
                isQPressed = false
            elseif input.KeyCode == Enum.KeyCode.R then
                isRPressed = false
            end
        end
    end)

    local map = workspace:FindFirstChild("Map")
    if map then
        local important = map:FindFirstChild("Important")
        if important then
            local baseplate = important:FindFirstChild("Baseplate"):FindFirstChild("Baseplate")

            if baseplate then
                Environment:CreateSlider("Platform Size", 400, 50000, 402, function(PlatFormSize)


                    for _, part in pairs(workspace:GetChildren()) do
                        if part:IsA("Part") and part.Name == "PlatformPart" then
                            part:Destroy()
                        end
                    end

                    local maxSize = 2048
                    local numPartsX = math.ceil(PlatFormSize / maxSize)
                    local partSizeX = PlatFormSize / numPartsX
                    local numPartsZ = math.ceil(PlatFormSize / maxSize)
                    local partSizeZ = PlatFormSize / numPartsZ


                    baseplate.Size = Vector3.new(partSizeX, baseplate.Size.Y, partSizeZ)

                    for i = 0, numPartsX - 1 do
                        for j = 0, numPartsZ - 1 do
                            local part = Instance.new("Part")
                            part.Size = Vector3.new(partSizeX, baseplate.Size.Y, partSizeZ)
                            part.Position = baseplate.Position + Vector3.new((i - (numPartsX - 1) / 2) * partSizeX, 0, (j - (numPartsZ - 1) / 2) * partSizeZ)
                            part.Name = "PlatformPart"
                            part.Anchored = true


                            for _, texture in pairs(baseplate:GetChildren()) do
                                if texture:IsA("Texture") then
                                    local textureClone = texture:Clone()
                                    textureClone.Transparency = 0 
                                    textureClone.Parent = part
                                end
                            end

                            part.Parent = workspace
                        end
                    end


                    for _, conveyor in pairs(workspace:GetChildren()) do
                        if conveyor:IsA("Part") and conveyor.Name == "Conveyer" then
                            local size = conveyor.Size

                            if size ~= Vector3.new(4.875644683837891, 1, 12.945449829101562) and size ~= Vector3.new(3.8756446838378906, 1, 42.94544982910156) then
                                conveyor.Texture.Color3 = Color3.fromRGB(109, 47, 198)
                                conveyor.Texture.Transparency = 0.74
                                conveyor.Size = Vector3.new(conveyor.Size.X, 5.1, conveyor.Size.Z)
                            end
                        end
                    end

                end)
            else
                warn("Baseplate not found.")
            end
        else
            warn("Important folder not found.")
        end
    else
        warn("Map not found.")
    end
        local EnvironmentThemes = {
            "Original", "Nothing",
        }

        Environment:CreateDropdown("Themes", EnvironmentThemes, function(EnvironmentOption)
            if EnvironmentOption == "Original" then
                local mainBaseplate = workspace:FindFirstChild("Baseplate")


                local textureID = "rbxassetid://10442413242"
                local textureExists = false
            

                for _, child in pairs(mainBaseplate:GetChildren()) do
                    if child:IsA("Texture") and child.Texture == textureID then
                        textureExists = true
                        break
                    end
                end
            

                if not textureExists then
                    local newTexture = Instance.new("Texture")
                    newTexture.Texture = textureID
                    newTexture.Color3 = Color3.new(114/255, 229/255, 114/255) 
                    newTexture.StudsPerTileU = 10
                    newTexture.StudsPerTileV = 10
                    newTexture.Face = Enum.NormalId.Top
                    newTexture.Parent = mainBaseplate
                    newTexture.Transparency = 1

                

                    for _, part in pairs(workspace:GetChildren()) do
                        if part:IsA("Part") and part.Name == "PlatformPart" then
                            local partTexture = newTexture:Clone()
                            partTexture.Parent = part
                            partTexture.Transparency = 0
                        end
                    end
                end
            
            elseif EnvironmentOption == "Nothing" then
                local basePlateCount = 0

                function removeTexturesFromBaseplates(parent)
                    for _, item in pairs(parent:GetChildren()) do
                        if item:IsA("Model") or item:IsA("Folder") then
                            removeTexturesFromBaseplates(item) 
                        end
                        if item.Name == "Baseplate" then
                            basePlateCount = basePlateCount + 1
                            for _, texture in pairs(item:GetChildren()) do
                                if texture:IsA("Texture") then
                                    texture.Parent.Transparency = 1
                                    texture:Destroy()
                                end
                            end
                        end
                    end
                end

                removeTexturesFromBaseplates(workspace) 

                local gameBaseplate = workspace:FindFirstChild("Baseplate")
                if gameBaseplate then
                    for _, texture in pairs(gameBaseplate:GetChildren()) do
                        if texture:IsA("Texture") then
                            texture:Destroy()
                            basePlateCount = basePlateCount + 1
                        end
                    end
                end

                for _, part in pairs(workspace:GetChildren()) do
                    if part:IsA("Part") and part.Name == "PlatformPart" then
                        for _, texture in pairs(part:GetChildren()) do
                            if texture:IsA("Texture") then
                                texture:Destroy()
                            end
                        end
                    end
                end
            end
        end)


        Player:CreateSlider("Walk Speed", 1, 100, 16, function(WalkspeedAdjuster)
            walkSpeeder = WalkspeedAdjuster
            adjustWalkSpeed()
        end)

            function Fly()
            local UpperTorso = plr.Character:WaitForChild("UpperTorso")
            local bg = Instance.new("BodyGyro", UpperTorso)
            bg.P = 9e4
            bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
            bg.CFrame = UpperTorso.CFrame
            local bv = Instance.new("BodyVelocity", UpperTorso)
            bv.Velocity = Vector3.new(0, 0.1, 0)
            bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
            PlayAnim(10714347256, 4, 0)
            
            repeat
                wait()
                plr.Character:SetAttribute("Tripped", true)
                plr.Character.Humanoid.PlatformStand = true
                local speed = (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and FlySpeed or 0
            
                if speed > 0 then
                    bv.Velocity = ((workspace.CurrentCamera.CFrame.LookVector * (ctrl.f + ctrl.b)) +
                    ((workspace.CurrentCamera.CFrame * CFrame.new(ctrl.l + ctrl.r, (ctrl.f + ctrl.b) * 0.2, 0).p) - 
                    workspace.CurrentCamera.CFrame.p)) * speed
                else
                    bv.Velocity = Vector3.new(0, 0, 0)
                end
            
                bg.CFrame = workspace.CurrentCamera.CFrame * CFrame.Angles(-math.rad((ctrl.f + ctrl.b) * 70 * speed / FlySpeed), 0, 0)
            until not flying
            plr.Character:SetAttribute("Tripped", false)
            ctrl = {f = 0, b = 0, l = 0, r = 0}
            bg:Destroy()
            bv:Destroy()
            plr.Character.Humanoid.PlatformStand = false
            StopAllAnims() 
        end

        function getRoot(char)
            return char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso') or char:FindFirstChild('UpperTorso')
        end

        function unmobilefly(speaker)
            pcall(function()
                flying = false
                speaker.Character:SetAttribute("Tripped", false)
                local root = getRoot(speaker.Character)
                root:FindFirstChild(velocityHandlerName):Destroy()
                root:FindFirstChild(gyroHandlerName):Destroy()
                speaker.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
            end)
        end

        function mobilefly(speaker)
            unmobilefly(speaker)
            flying = true
        
            local root = getRoot(speaker.Character)
            local camera = workspace.CurrentCamera
            local v3none = Vector3.new()
            local v3inf = Vector3.new(9e9, 9e9, 9e9)
    
        local bv = Instance.new("BodyVelocity", root)
        bv.Name = velocityHandlerName
        bv.MaxForce = v3inf
        bv.Velocity = v3none
    
        local bg = Instance.new("BodyGyro", root)
        bg.Name = gyroHandlerName
        bg.MaxTorque = v3inf
        bg.P = 1000
        bg.D = 50
        StopAllAnims() 
        PlayAnim(10714347256, 4, 0)
    
        RunService.RenderStepped:Connect(function()
            root = getRoot(speaker.Character)
            speaker.Character:SetAttribute("Tripped", true)
            camera = workspace.CurrentCamera
            if speaker.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild(velocityHandlerName) and root:FindFirstChild(gyroHandlerName) then
                local humanoid = speaker.Character:FindFirstChildWhichIsA("Humanoid")
                local VelocityHandler = root:FindFirstChild(velocityHandlerName)
                local GyroHandler = root:FindFirstChild(gyroHandlerName)
    
                VelocityHandler.MaxForce = v3inf
                GyroHandler.MaxTorque = v3inf
                humanoid.PlatformStand = true
                GyroHandler.CFrame = camera.CFrame
                VelocityHandler.Velocity = v3none
    
                local direction = Vector3.new(ctrl.r - ctrl.l, 0, ctrl.b - ctrl.f).Unit
                VelocityHandler.Velocity = direction * FlySpeed
            end
        end)
    end

    Player:CreateToggle("Fly", function(EnableFly)
        if EnableFly then
            if not IsOnMobile then
                flying = true
                local KeyDownFunction, KeyUpFunction
    
                KeyDownFunction = mouse.KeyDown:Connect(function(key)
                    if flying then
                        if key:lower() == "w" then
                            ctrl.f = 1
                            PlayAnim(10714177846, 4.65, 0) 
                        elseif key:lower() == "s" then
                            ctrl.b = -1
                            PlayAnim(10147823318, 4.11, 0) 
                        elseif key:lower() == "a" then
                            ctrl.l = -1
                            PlayAnim(10147823318, 3.55, 0) 
                        elseif key:lower() == "d" then
                            ctrl.r = 1
                            PlayAnim(10147823318, 4.81, 0) 
                        end
                    end
                end)
    
                KeyUpFunction = mouse.KeyUp:Connect(function(key)
                    if flying then
                        if key:lower() == "w" then
                            ctrl.f = 0
                        elseif key:lower() == "s" then
                            ctrl.b = 0
                        elseif key:lower() == "a" then
                            ctrl.l = 0
                        elseif key:lower() == "d" then
                            ctrl.r = 0
                        end
                        StopAllAnims() 
                        if ctrl.f + ctrl.b + ctrl.l + ctrl.r == 0 then
                            PlayAnim(10714347256, 4, 0) 
                        end
                    end
                end)
    
                Fly()
            else
                mobilefly(plr)
            end
        else
            flying = false
            unmobilefly(plr)
            if KeyDownFunction then KeyDownFunction:Disconnect() end
            if KeyUpFunction then KeyUpFunction:Disconnect() end
            StopAllAnims() 
            ctrl = {f = 0, b = 0, l = 0, r = 0} 
        end
    end)
    
    Player:CreateSlider("Fly Speed", 0, 500, 30, function(FlyingValueSpeed)
        FlySpeed = FlyingValueSpeed
    end)


    Reanimate:CreateButton("R15 Reanimate", function(R15reanimatedTrue)

        if R6reanimated or plr.Character.Humanoid.Health == 0 then
            Message("Error R6 Reanimate Status:", "Active", 5)
            return 
        end

        if R15reanimated or plr.Character.Humanoid.Health == 0 then
            Message("R15 Reanimate Status:", "Active", 5)
            return 
        end
        
        R15reanimated = true
        local v3_net, v3_808 = Vector3.new(0, 0, 0), Vector3.new(0, 0, 0)    
        function getNetlessVelocity(realPartVelocity)
            local mag = realPartVelocity.Magnitude
            if mag > 0 then
                local unit = realPartVelocity.Unit
                if unit.Y ~= 0 then
                    return unit * (0.0 / unit.Y)  
                end
            end
            return v3_net + realPartVelocity * v3_808
        end
        
        
        local simradius = "shp" 
        local simrad = 0 
        local healthHide = false 
        local reclaim = true 
        
        local novoid = true 
        local physp = nil 
        
        local noclipAllParts = false 
        local antiragdoll = false 
        local newanimate = true 
        local discharscripts = false 
        local hatcollide = false 
        local humState16 = true 
        local addtools = false 
        local hedafterneck = true 
        local loadtime = game:GetService("Players").RespawnTime + 0.5 
        local method = 3 
        
        local alignmode = 4 
        local flingpart = "HumanoidRootPart" 
        
        local lp = game:GetService("Players").LocalPlayer
        local rs, ws, sg = game:GetService("RunService"), game:GetService("Workspace"), game:GetService("StarterGui")    
        local stepped, heartbeat, renderstepped = rs.Stepped, rs.Heartbeat, rs.RenderStepped
        local twait, tdelay, rad, inf, abs, clamp = task.wait, task.delay, math.rad, math.huge, math.abs, math.clamp
        local cf, v3 = CFrame.new, Vector3.new
        local v3_0, v3_101, v3_010, v3_d, v3_u = v3(0, 0, 0), v3(1, 0, 1), v3(0, 1, 0), v3(0, -10000, 0), v3(0, 10000, 0)

        local angles = CFrame.Angles
        local v3_0, cf_0 = v3(0, 0, 0), cf(0, 0, 0)
        
        local c = lp.Character
        if not (c and c.Parent) then
            return
        end
    local args = {
	    "Ball"
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Ragdoll"):FireServer(unpack(args))

        c:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (c and c.Parent) then
                c = nil
            end
        end)
        
        local clone, destroy, getchildren, getdescendants, isa = c.Clone, c.Destroy, c.GetChildren, c.GetDescendants, c.IsA
        
        function gp(parent, name, className)
            if typeof(parent) == "Instance" then
                for i, v in pairs(getchildren(parent)) do
                    if (v.Name == name) and isa(v, className) then
                        return v
                    end
                end
            end
            return nil
        end
        
        local fenv = getfenv()
        local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
        local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.setsimrad or fenv.set_sim_rad
        
        healthHide = healthHide and ((method == 0) or (method == 3)) and gp(c, "Head", "BasePart")
        
        local reclaim, lostpart = reclaim and c.PrimaryPart, nil
        
        function align(Part0, Part1)
            local att0 = Instance.new("Attachment")
            att0.Position, att0.Orientation, att0.Name = v3_0, v3_0, "att0_" .. Part0.Name
            local att1 = Instance.new("Attachment")
            att1.Position, att1.Orientation, att1.Name = v3_0, v3_0, "att1_" .. Part1.Name
        
            if alignmode == 4 then
                local hide = false
                if Part0 == healthHide then
                    healthHide = false
                    tdelay(0, function()
                        while twait(2.9) and Part0 and c do
                            hide = #Part0:GetConnectedParts() == 1
                            twait(0.1)
                            hide = false
                        end
                    end)
                end
        
                local rot = rad(0.05)
                local con0, con1 = nil, nil
                con0 = stepped:Connect(function()
                    if not (Part0 and Part1) or not plr.Character or not plr.Character:FindFirstChild("UpperTorso") then 
                        print("Disconnected 1")
                        con0:Disconnect() 
                        con1:Disconnect() 
                        return 
                    end
                    plr.Character.UpperTorso.CanCollide = false
                    plr.Character.LowerTorso.CanCollide = false
                    Part0.RotVelocity = Part1.RotVelocity
                end)

                local lastpos = Part0.Position
                con1 = heartbeat:Connect(function(delta)
                    if not (Part0 and Part1 and att1) then return con0:Disconnect() and con1:Disconnect()  end
                    if (not Part0.Anchored) and (Part0.ReceiveAge == 0) then
                        if lostpart == Part0 then
                            lostpart = nil
                        end
                        rot = -rot
                        local newcf = Part1.CFrame * att1.CFrame * angles(0, 0, rot)
                        if Part1.Velocity.Magnitude > 0.01 then
                            Part0.Velocity = getNetlessVelocity(Part1.Velocity)
                        else
                            Part0.Velocity = getNetlessVelocity((newcf.Position - lastpos) / delta)
                        end
                        lastpos = newcf.Position
                        if lostpart and (Part0 == reclaim) then
                            newcf = lostpart.CFrame
                        elseif hide then
                            newcf += v3(0, 3000, 0)
                        end
                        if novoid and (newcf.Y < ws.FallenPartsDestroyHeight + 0.1) then
                            newcf += v3(0, ws.FallenPartsDestroyHeight + 0.1 - newcf.Y, 0)
                        end
                        Part0.CFrame = newcf
                    elseif (not Part0.Anchored) and (abs(Part0.Velocity.X) < 45) and (abs(Part0.Velocity.Y) < 25) and (abs(Part0.Velocity.Z) < 45) then
                        lostpart = Part0
                    end
                end)
            else
                Part0.CustomPhysicalProperties = physp
            end
        
            att0:GetPropertyChangedSignal("Parent"):Connect(function()
                Part0 = att0.Parent
                if not isa(Part0, "BasePart") then
                    att0 = nil
                    if lostpart == Part0 then
                        lostpart = nil
                    end
                    Part0 = nil
                end
            end)
            att0.Parent = Part0
        
            att1:GetPropertyChangedSignal("Parent"):Connect(function()
                Part1 = att1.Parent
                if not isa(Part1, "BasePart") then
                    att1 = nil
                    Part1 = nil
                end
            end)
            att1.Parent = Part1
        end
        
        function respawnrequest()
            local ccfr, c = ws.CurrentCamera.CFrame, lp.Character
            lp.Character = nil
            lp.Character = c
            local con = nil
            con = ws.CurrentCamera.Changed:Connect(function(prop)
                if (prop ~= "Parent") and (prop ~= "CFrame") then
                    return
                end
                ws.CurrentCamera.CFrame = ccfr
                con:Disconnect()
            end)
        end
        
        local destroyhum = (method == 4) or (method == 5)
        local breakjoints = (method == 0) or (method == 4)
        local antirespawn = (method == 0) or (method == 2) or (method == 3)
        
        hatcollide = hatcollide and (method == 0)
        
        addtools = addtools and lp:FindFirstChildOfClass("Backpack")
        
        if type(simrad) ~= "number" then simrad = 1000 end
        if shp and (simradius == "shp") then
            tdelay(0, function()
                while c do
                    shp(lp, "SimulationRadius", simrad)
                    heartbeat:Wait()
                end
            end)
        elseif ssr and (simradius == "ssr") then
            tdelay(0, function()
                while c do
                    ssr(simrad)
                    heartbeat:Wait()
                end
            end)
        end
        
        if antiragdoll then
            antiragdoll = function(v)
                if isa(v, "HingeConstraint") or isa(v, "BallSocketConstraint") then
                    v.Parent = nil
                end
            end
            for i, v in pairs(getdescendants(c)) do
                antiragdoll(v)
            end
            c.DescendantAdded:Connect(antiragdoll)
        end
        
        if antirespawn then
            
        end
        
        if method == 0 then
            twait(loadtime)
            if not c then
                return
            end
        end
        
        if discharscripts then
            for i, v in pairs(getdescendants(c)) do
                if isa(v, "LocalScript") then
                    v.Disabled = true
                end
            end
        elseif newanimate then
            local animate = gp(c, "Animate", "LocalScript")
            if animate and (not animate.Disabled) then
                animate.Disabled = true
            else
                newanimate = false
            end
        end
        
        if addtools then
            for i, v in pairs(getchildren(addtools)) do
                if isa(v, "Tool") then
                    v.Parent = c
                end
            end
        end
        
        pcall(function()
            settings().Physics.AllowSleep = false
            settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
        end)
        
        local OLDscripts = {}
        
        for i, v in pairs(getdescendants(c)) do
            if v.ClassName == "Script" then
                OLDscripts[v.Name] = true
            end
        end
        
        local scriptNames = {}
        
        for i, v in pairs(getdescendants(c)) do
            if isa(v, "BasePart") then
                local newName, exists = tostring(i), true
                while exists do
                    exists = OLDscripts[newName]
                    if exists then
                        newName = newName .. "_"    
                    end
                end
                table.insert(scriptNames, newName)
                Instance.new("Script", v).Name = newName
            end
        end
        
        local hum = c:FindFirstChildOfClass("Humanoid")
        if hum then
            for i, v in pairs(hum:GetPlayingAnimationTracks()) do
                v:Stop()
            end
        end
        c.Archivable = true
        local cl = clone(c)
        if hum and humState16 then
            hum:ChangeState(Enum.HumanoidStateType.Physics)
            if destroyhum then
                twait(1.6)
            end
        end
        if destroyhum then
            pcall(destroy, hum)
        end
        
        if not c then
            return
        end
        
        local head, torso, root = gp(c, "Head", "BasePart"), gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart"), gp(c, "HumanoidRootPart", "BasePart")
        if hatcollide then
            pcall(destroy, torso)
            pcall(destroy, root)
            pcall(destroy, c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script"))
        end
        
        local model = Instance.new("Model", c)
        model:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (model and model.Parent) then
                model = nil
            end
        end)
        
        for i, v in pairs(getchildren(c)) do
            if v ~= model then
                if addtools and isa(v, "Tool") then
                    for i1, v1 in pairs(getdescendants(v)) do
                        if v1 and v1.Parent and isa(v1, "BasePart") then
                            local bv = Instance.new("BodyVelocity")
                            
                            bv.Velocity, bv.MaxForce, bv.P, bv.Name = v3_0, v3(1000, 1000, 1000), 1250, "bv_" .. v.Name
                            bv.Parent = v1
                        end
                    end
                end
                v.Parent = model
            end
        end
        
        if breakjoints then
            model:BreakJoints()
        else
            if head and torso then
                for i, v in pairs(getdescendants(model)) do
                    if isa(v, "JointInstance") then
                        local save = false
                        if (v.Part0 == torso) and (v.Part1 == head) then
                            save = true
                        end
                        if (v.Part0 == head) and (v.Part1 == torso) then
                            save = true
                        end
                        if save then
                            if hedafterneck then
                                hedafterneck = v
                            end
                        else
                            pcall(destroy, v)
                        end
                    end
                end
            end
            if method == 3 then
                task.delay(loadtime, pcall, model.BreakJoints, model)
            end
        end
        
        cl.Parent = ws
        for i, v in pairs(getchildren(cl)) do
            v.Parent = c
        end
        pcall(destroy, cl)
        
        local uncollide, noclipcon = nil, nil
        if noclipAllParts then
            uncollide = function()
                if c then
                    for i, v in pairs(getdescendants(c)) do
                        if isa(v, "BasePart") then
                            v.CanCollide = false
                        end
                    end
                else
                    noclipcon:Disconnect()
                end
            end
        else
            uncollide = function()
                if model then
                    for i, v in pairs(getdescendants(model)) do
                        if isa(v, "BasePart") then
                            v.CanCollide = false
                        end
                    end
                else
                    noclipcon:Disconnect()
                end
            end
        end
        noclipcon = stepped:Connect(uncollide)
        uncollide()
        
        for i, scr in pairs(getdescendants(model)) do
            if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
                local Part0 = scr.Parent
                if isa(Part0, "BasePart") then
                    for i1, scr1 in pairs(getdescendants(c)) do
                        if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
                            local Part1 = scr1.Parent
                            if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
                                align(Part0, Part1)
                                pcall(destroy, scr)
                                pcall(destroy, scr1)
                                break
                            end
                        end
                    end
                end
            end
        end
        
        for i, v in pairs(getdescendants(c)) do
            if v and v.Parent and (not v:IsDescendantOf(model)) then
                if isa(v, "Decal") then
                elseif isa(v, "BasePart") then
                    v.Anchored = false
                elseif isa(v, "ForceField") then
                    v.Visible = false
                elseif isa(v, "Sound") then
                    v.Playing = false
                elseif isa(v, "BillboardGui") or isa(v, "SurfaceGui") or isa(v, "ParticleEmitter") or isa(v, "Fire") or isa(v, "Smoke") or isa(v, "Sparkles") then
                    v.Enabled = false
                end
            end
        end
        
        if newanimate then
            local animate = gp(c, "Animate", "LocalScript")
            if animate then
                animate.Disabled = false
            end
        end
        
        if addtools then
            for i, v in pairs(getchildren(c)) do
                if isa(v, "Tool") then
                    v.Parent = addtools
                end
            end
        end
        
        local hum0, hum1 = model:FindFirstChildOfClass("Humanoid"), c:FindFirstChildOfClass("Humanoid")
        if hum0 then
            hum0:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (hum0 and hum0.Parent) then
                    hum0 = nil
                end
            end)
        end
        if hum1 then
            hum1:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (hum1 and hum1.Parent) then
                    hum1 = nil
                end
            end)
        
            ws.CurrentCamera.CameraSubject = hum1

        end
       
        function setTransparency(model, transparencyValue)
            for _, descendant in ipairs(model:GetDescendants()) do
                if descendant:IsA("BasePart") then
                    descendant.Transparency = transparencyValue
                end
            end
        end
        
        
        setTransparency(plr.Character.Model, 1)
        plr.Character.Model.Head.Transparency = 0
        plr.Character.Head.Transparency = 1
        local rb = Instance.new("BindableEvent", c)
        rb.Event:Connect(function()
            pcall(destroy, rb)
            sg:SetCore("ResetButtonCallback", true)
            if destroyhum then
                if c then c:BreakJoints() end
                return
            end
            if model and hum0 and (hum0.Health > 0) then
                model:BreakJoints()
                hum0.Health = 0
            end
            if antirespawn then
                
            end
        end)
        
        sg:SetCore("ResetButtonCallback", rb)
        
        tdelay(0, function()
            while c do
                if hum0 and hum1 then
                    hum1.Jump = hum0.Jump
                end
                wait()
            end
            sg:SetCore("ResetButtonCallback", true)
        end)
        
        
        local R15toR6 = false 
        if R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15) then
        end
        
        
        local torso1 = torso
        torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
        if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
            local conNeck, conTorso, conTorso1 = nil, nil, nil
            local aligns = {}
            function enableAligns()
                if conNeck then conNeck:Disconnect() end
                if conTorso then conTorso:Disconnect() end
                if conTorso1 then conTorso1:Disconnect() end
                for i, v in pairs(aligns) do
                    v.Enabled = true
                end
            end
            conNeck = hedafterneck.Changed:Connect(function(prop)
                if table.find({"Part0", "Part1", "Parent"}, prop) then
                    enableAligns()
                end
            end)
            conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
            conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
            for i, v in pairs(getdescendants(head)) do
                if isa(v, "AlignPosition") or isa(v, "AlignOrientation") then
                    i = tostring(i)
                    aligns[i] = v
                    v:GetPropertyChangedSignal("Parent"):Connect(function()
                        aligns[i] = nil
                    end)
                    v.Enabled = false
                end
            end
        end
        
    end)
    
        local previousWidth = 0 

    Reanimate:CreateSlider("Width", 0, 500, 0, function(CharacterWidth)
        if not R15reanimated then
            return
        end
    
        local offset = CharacterWidth 
        local widthChange = offset - previousWidth 
    
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
    
        local rootPart = character:WaitForChild("HumanoidRootPart")
        local head = character:WaitForChild("Head")
        local leftFoot = character:WaitForChild("LeftFoot")
        local leftHand = character:WaitForChild("LeftHand")
        local leftLowerArm = character:WaitForChild("LeftLowerArm")
        local leftLowerLeg = character:WaitForChild("LeftLowerLeg")
        local leftUpperArm = character:WaitForChild("LeftUpperArm")
        local leftUpperLeg = character:WaitForChild("LeftUpperLeg")
        local lowerTorso = character:WaitForChild("LowerTorso")
        local rightFoot = character:WaitForChild("RightFoot")
        local rightHand = character:WaitForChild("RightHand")
        local rightLowerArm = character:WaitForChild("RightLowerArm")
        local rightLowerLeg = character:WaitForChild("RightLowerLeg")
        local rightUpperArm = character:WaitForChild("RightUpperArm")
        local rightUpperLeg = character:WaitForChild("RightUpperLeg")
        local upperTorso = character:WaitForChild("UpperTorso")
    
        local Joints = {
            ["Torso"] = rootPart:FindFirstChild("RootJoint"),
            ["Head"] = head:FindFirstChild("Neck"),
            ["LeftUpperArm"] = leftUpperArm:FindFirstChild("LeftShoulder"),
            ["RightUpperArm"] = rightUpperArm:FindFirstChild("RightShoulder"),
            ["LeftUpperLeg"] = leftUpperLeg:FindFirstChild("LeftHip"),
            ["RightUpperLeg"] = rightUpperLeg:FindFirstChild("RightHip"),
            ["LeftFoot"] = leftFoot:FindFirstChild("LeftAnkle"),
            ["RightFoot"] = rightFoot:FindFirstChild("RightAnkle"),
            ["LeftHand"] = leftHand:FindFirstChild("LeftWrist"),
            ["RightHand"] = rightHand:FindFirstChild("RightWrist"),
            ["LeftLowerArm"] = leftLowerArm:FindFirstChild("LeftElbow"),
            ["RightLowerArm"] = rightLowerArm:FindFirstChild("RightElbow"),
            ["LeftLowerLeg"] = leftLowerLeg:FindFirstChild("LeftKnee"),
            ["RightLowerLeg"] = rightLowerLeg:FindFirstChild("RightKnee"),
            ["LowerTorso"] = lowerTorso:FindFirstChild("Root"),
            ["UpperTorso"] = upperTorso:FindFirstChild("Waist"),
        }
    
        
        for jointName, joint in pairs(Joints) do
            if joint then
                if jointName == "LeftUpperArm" then
                    joint.C0 = joint.C0 + Vector3.new(-widthChange * 0.5, 0, 0) 
                elseif jointName == "RightUpperArm" then
                    joint.C0 = joint.C0 + Vector3.new(widthChange * 0.5, 0, 0) 
                elseif jointName == "LeftUpperLeg" then
                    joint.C0 = joint.C0 + Vector3.new(-widthChange * 0.5, 0, 0) 
                elseif jointName == "RightUpperLeg" then
                    joint.C0 = joint.C0 + Vector3.new(widthChange * 0.5, 0, 0) 
                elseif jointName == "Torso" then
                    joint.C0 = joint.C0 + Vector3.new(0, 0, widthChange * 0.5) 
                end
            else
                
            end
        end
    
        previousWidth = offset 
    end)
    


    local character = plr.Character or plr.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")


    local ActualHipHeight = humanoid.HipHeight

    local previousHeight = 0
    local previousHipHeightR15 = 0

    Reanimate:CreateSlider("Height", 0, 250, 0, function(CharacterHeight)
    if not R15reanimated then
        return
    end

    local character = plr.Character or plr.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local head = character:WaitForChild("Head")
    local leftFoot = character:WaitForChild("LeftFoot")
    local leftHand = character:WaitForChild("LeftHand")
    local leftLowerArm = character:WaitForChild("LeftLowerArm")
    local leftLowerLeg = character:WaitForChild("LeftLowerLeg")
    local leftUpperArm = character:WaitForChild("LeftUpperArm")
    local leftUpperLeg = character:WaitForChild("LeftUpperLeg")
    local lowerTorso = character:WaitForChild("LowerTorso")
    local rightFoot = character:WaitForChild("RightFoot")
    local rightHand = character:WaitForChild("RightHand")
    local rightLowerArm = character:WaitForChild("RightLowerArm")
    local rightLowerLeg = character:WaitForChild("RightLowerLeg")
    local rightUpperArm = character:WaitForChild("RightUpperArm")
    local rightUpperLeg = character:WaitForChild("RightUpperLeg")
    local upperTorso = character:WaitForChild("UpperTorso")
    local humanoid = character:WaitForChild("Humanoid")
    local offset = CharacterHeight / 100 
    local changeInHeight = CharacterHeight - previousHeight
    local Joints = {
        ["Torso"] = rootPart:FindFirstChild("RootJoint"),
        ["Head"] = head:FindFirstChild("Neck"),
        ["LeftUpperArm"] = leftUpperArm:FindFirstChild("LeftShoulder"),
        ["RightUpperArm"] = rightUpperArm:FindFirstChild("RightShoulder"),
        ["LeftUpperLeg"] = leftUpperLeg:FindFirstChild("LeftHip"),
        ["RightUpperLeg"] = rightUpperLeg:FindFirstChild("RightHip"),
        ["LeftFoot"] = leftFoot:FindFirstChild("LeftAnkle"),
        ["RightFoot"] = rightFoot:FindFirstChild("RightAnkle"),
        ["LeftHand"] = leftHand:FindFirstChild("LeftWrist"),
        ["RightHand"] = rightHand:FindFirstChild("RightWrist"),
        ["LeftLowerArm"] = leftLowerArm:FindFirstChild("LeftElbow"),
        ["RightLowerArm"] = rightLowerArm:FindFirstChild("RightElbow"),
        ["LeftLowerLeg"] = leftLowerLeg:FindFirstChild("LeftKnee"),
        ["RightLowerLeg"] = rightLowerLeg:FindFirstChild("RightKnee"),
        ["LowerTorso"] = lowerTorso:FindFirstChild("Root"),
        ["UpperTorso"] = upperTorso:FindFirstChild("Waist"),
    }
    for jointName, joint in pairs(Joints) do
        if joint then
            if jointName == "Torso" or jointName == "LowerTorso" or jointName == "UpperTorso" then
                joint.C0 = joint.C0 + Vector3.new(0, changeInHeight * 0.1, 0) 
            elseif jointName == "LeftUpperLeg" or jointName == "RightUpperLeg" then
                joint.C0 = joint.C0 + Vector3.new(0, -changeInHeight * 0.1, 0) 
            elseif jointName == "LeftHand" or jointName == "RightHand" then
                joint.C0 = joint.C0 + Vector3.new(0, -changeInHeight * 0.1, 0) 
            elseif jointName == "LeftLowerArm" or jointName == "RightLowerArm" then
                joint.C0 = joint.C0 + Vector3.new(0, -changeInHeight * 0.1, 0) 
            elseif jointName == "LeftLowerLeg" or jointName == "RightLowerLeg" then
                joint.C0 = joint.C0 + Vector3.new(0, -changeInHeight * 0.1, 0) 
            elseif jointName == "LeftFoot" or jointName == "RightFoot" then
                joint.C0 = joint.C0 + Vector3.new(0, -changeInHeight * 0.1, 0) 
            end
        else

        end
    end
    if CharacterHeight >= 1 then
        local hipHeightChange = changeInHeight * 0.2
        local newHipHeight = previousHipHeightR15 + hipHeightChange

        if newHipHeight < ActualHipHeight then
            newHipHeight = ActualHipHeight
        end

        humanoid.HipHeight = newHipHeight
    else
        humanoid.HipHeight = ActualHipHeight
    end
    previousHeight = CharacterHeight 
    previousHipHeightR15 = humanoid.HipHeight 
    end)

    local root_part = plr.Character.HumanoidRootPart
    local initial_cframe = root_part.CFrame
    local old_cframe = initial_cframe * CFrame.new(-111, 60, -11210) * CFrame.Angles(math.rad(180), 0, 0)

    Environment:CreateSlider("Platform Adjuster", -19.2, 250, 60, function(MapPooperHeight)
        old_cframe = CFrame.new(initial_cframe.Position.X - 111, MapPooperHeight, initial_cframe.Position.Z - 11210) * CFrame.Angles(math.rad(-90), 0, 0)
    end)

    Environment:CreateToggle("Platform (Layered clothing needed)", function(MapPooper)
        if R15reanimated then
            Message("Error!", "Deactivate R15", 5)
    return end
    plr.Character.Humanoid:ChangeState(3)
        getgenv().MapPooperss = MapPooper
        local originalpositon = plr.Character.HumanoidRootPart.CFrame        
        
        local renderConnection
        plr.Character.Humanoid:ChangeState(3)
        if not getgenv().MapPooperss then
            if renderConnection then
                renderConnection:Disconnect()
                wait(1)
                plr.Character.HumanoidRootPart.CFrame = originalpositon
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
            end
            if R15reanimated then
                Message("Error!", "Deactivate R15", 5)
            else
                game:GetService("ReplicatedStorage"):WaitForChild("Unragdoll"):FireServer()
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
            end
                return
        end
        local players = game:GetService("Players")
        local run_service = game:GetService("RunService")
        local replicated_storage = game:GetService("ReplicatedStorage")

        local local_player = players.LocalPlayer
        local ragdoll_event = replicated_storage.RagdollEvent

        local character = local_player.Character

        local offset = 100000
        task.wait()
        local head = character.Head
        local upper_torso = character.UpperTorso
        local lower_torso = character.LowerTorso

        local right_upper_arm = character.RightUpperArm
        local right_lower_arm = character.RightLowerArm
        local right_hand = character.RightHand

        local left_upper_arm = character.LeftUpperArm
        local left_lower_arm = character.LeftLowerArm
        local left_hand = character.LeftHand

        local right_upper_leg = character.RightUpperLeg
        local right_lower_leg = character.RightLowerLeg
        local right_foot = character.RightFoot

        local left_upper_leg = character.LeftUpperLeg
        local left_lower_leg = character.LeftLowerLeg
        local left_foot = character.LeftFoot


        function set_velocity_to_zero(part)
            part.AssemblyLinearVelocity = Vector3.zero
            part.AssemblyAngularVelocity = Vector3.zero
        end
        plr.Character.HumanoidRootPart.CFrame = originalpositon
        function SimulateJump()
            local Humanoid = game:GetService("Players").LocalPlayer.Character:WaitForChild("Humanoid")
            game:GetService("VirtualUser"):SetKeyDown("0x20");
            task.wait(0.1);
            game:GetService("VirtualUser"):SetKeyUp("0x20");
            repeat task.wait() until Humanoid:GetState().Value == 7; 
        end

        SimulateJump()
        task.wait()
            local args = {
        	"Ball"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Ragdoll"):FireServer(unpack(args))



        renderConnection = run_service.Heartbeat:Connect(function()
            if not getgenv().MapPooperss then

                renderConnection:Disconnect()
                return
            end

            plr.Character.HumanoidRootPart.CFrame = originalpositon
            head.CFrame = old_cframe * CFrame.new(0, 0, offset / 2)
            upper_torso.CFrame = old_cframe * CFrame.new(0, -offset / 1232, 20)
            lower_torso.CFrame = old_cframe * CFrame.new(0, -offset / 1232, 20)

            right_upper_arm.CFrame = old_cframe * CFrame.new(offset, 1230, 0)
            right_lower_arm.CFrame = old_cframe * CFrame.new(offset * 1231.5, 0, 20)
            right_hand.CFrame = old_cframe * CFrame.new(offset * 2, 0, 0)
        
            left_upper_arm.CFrame = old_cframe * CFrame.new(-offset, 0, 0)
            left_lower_arm.CFrame = old_cframe * CFrame.new(-offset * 1123.5, 0, 20)
            left_hand.CFrame = old_cframe * CFrame.new(-offset * 2, 0, 0)
        
            right_upper_leg.CFrame = old_cframe * CFrame.new(offset / 2, -offset, 20)
            right_lower_leg.CFrame = old_cframe * CFrame.new(offset / 2, -offset * 123311.5, 20)
            right_foot.CFrame = old_cframe * CFrame.new(offset / 2, -offset * 1121233, 20)
        
            left_upper_leg.CFrame = old_cframe * CFrame.new(-offset / 2, -offset, 20)
            left_lower_leg.CFrame = old_cframe * CFrame.new(-offset / 2, -offset * 111233111.5, 20)
            left_foot.CFrame = old_cframe * CFrame.new(-offset / 2, -offset * 11112, 20)

            set_velocity_to_zero(head)
            set_velocity_to_zero(upper_torso)
            set_velocity_to_zero(lower_torso)
            set_velocity_to_zero(right_upper_arm)
            set_velocity_to_zero(right_lower_arm)
            set_velocity_to_zero(right_hand)
            set_velocity_to_zero(left_upper_arm)
            set_velocity_to_zero(left_lower_arm)
            set_velocity_to_zero(left_hand)
            set_velocity_to_zero(right_upper_leg)
            set_velocity_to_zero(right_lower_leg)
            set_velocity_to_zero(right_foot)
            set_velocity_to_zero(left_upper_leg)
            set_velocity_to_zero(left_lower_leg)
            set_velocity_to_zero(left_foot)
        end)
    end)

        local previousWidthR6 = 0
        local previousHeightR6 = 0
        local previousArmstR6 = 0

        function onCharacterDeath()
            if R6reanimated then
                R6reanimated = false
            local character = plr.Character or plr.CharacterAdded:Wait()
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                respawnPosition = humanoidRootPart.CFrame 
                wait(0.1)
                previousHipHeightR15 = 0
                ActualHipHeight = humanoid.HipHeight
                previousHeight = 0
                previousWidth = 0
                previousWidthR6 = 0
                previousHeightR6 = 0
                previousArmstR6 = 0
                walkSpeeder = 16
            end
            Message("Character has died!", "R6 Reanimate Inactive", 5)
        elseif R15reanimated then
                R15reanimated = false
                local character = plr.Character or plr.CharacterAdded:Wait()
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    respawnPosition = humanoidRootPart.CFrame 
                    wait(0.1)
                    previousHipHeightR15 = 0
                    ActualHipHeight = humanoid.HipHeight    
                    previousHeight = 0
                    previousWidth = 0
                    previousWidthR6 = 0
                    previousHeightR6 = 0
                    previousArmstR6 = 0
                    walkSpeeder = 16
                end
                Message("Character has died!", "R6 Reanimate Inactive", 5)
            elseif not R15reanimated or not R6reanimated then
                local character = plr.Character or plr.CharacterAdded:Wait()
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    respawnPosition = humanoidRootPart.CFrame 
                    wait(0.1)
                    previousHipHeightR15 = 0
                    ActualHipHeight = humanoid.HipHeight    
                    previousHeight = 0
                    previousWidth = 0
                    previousWidthR6 = 0
                    previousHeightR6 = 0
                    previousArmstR6 = 0
                    walkSpeeder = 16
                            end
                            previousHipHeightR15 = 0
                            ActualHipHeight = humanoid.HipHeight            
                previousHeight = 0
                previousWidth = 0
                previousWidthR6 = 0
                previousHeightR6 = 0
                previousArmstR6 = 0
                Message("Character has died!", "Respawning...", 5)

        end
    end
        function onCharacterAdded(character)
            character:WaitForChild("Humanoid").Died:Connect(onCharacterDeath)
            if respawnPosition then
                character:WaitForChild("HumanoidRootPart").CFrame = respawnPosition
                EmotePlayingR15 = false                
                if flying then
                if not IsOnMobile then
                    flying = true
                    local KeyDownFunction, KeyUpFunction
                
                    KeyDownFunction = mouse.KeyDown:Connect(function(key)
                        if flying then
                            if key:lower() == "w" then
                                ctrl.f = 1
                                PlayAnim(10714177846, 4.65, 0) 
                            elseif key:lower() == "s" then
                                ctrl.b = -1
                                PlayAnim(10147823318, 4.11, 0) 
                            elseif key:lower() == "a" then
                                ctrl.l = -1
                                PlayAnim(10147823318, 3.55, 0) 
                            elseif key:lower() == "d" then
                                ctrl.r = 1
                                PlayAnim(10147823318, 4.81, 0) 
                            end
                        end
                    end)
                
                    KeyUpFunction = mouse.KeyUp:Connect(function(key)
                        if flying then
                            if key:lower() == "w" then
                                ctrl.f = 0
                            elseif key:lower() == "s" then
                                ctrl.b = 0
                            elseif key:lower() == "a" then
                                ctrl.l = 0
                            elseif key:lower() == "d" then
                                ctrl.r = 0
                            end
                            StopAllAnims() 
                            if ctrl.f + ctrl.b + ctrl.l + ctrl.r == 0 then
                                PlayAnim(10714347256, 4, 0) 
                            end
                        end
                    end)
                
                    Fly()
                else
                    mobilefly(plr)
                end
                end
                wait(1)
                ActualHipHeight = plr.Character.Humanoid.HipHeight
            game.Workspace.Gravity = 196.2
            respawnPosition = nil
        end
    end
    
    
    plr.CharacterAdded:Connect(onCharacterAdded)
    
    
    if plr.Character then
        onCharacterAdded(plr.Character)
    end

    local StopAnim = true
    local AnimationActive = false
    local CurrentAnimationID = nil
    
    function isValidAnimationID(animationID)
        local success, asset = pcall(function()
            return game:GetObjects("rbxassetid://" .. animationID)[1]
        end)
        return success and asset ~= nil
    end
    
    local CurrentAnimTask = nil
    R157 = R157 or 1

    function stopCurrentAnimation()
        AnimationActive = false
        StopAnim = true
        if CurrentAnimTask then
            coroutine.close(CurrentAnimTask)
            CurrentAnimTask = nil
        end

        local character = game.Players.LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoid:FindFirstChild("Animator") then
                humanoid.Animator:Destroy()
            end
            if character:FindFirstChild("Animate") then
                character.Animate.Enabled = true
            end
        end
    end

    function getJoints(character)
        local jointMap = {
            ["Torso"] = "RootJoint", ["Head"] = "Neck", ["LeftUpperArm"] = "LeftShoulder",
            ["RightUpperArm"] = "RightShoulder", ["LeftUpperLeg"] = "LeftHip", ["RightUpperLeg"] = "RightHip",
            ["LeftFoot"] = "LeftAnkle", ["RightFoot"] = "RightAnkle", ["LeftHand"] = "LeftWrist",
            ["RightHand"] = "RightWrist", ["LeftLowerArm"] = "LeftElbow", ["RightLowerArm"] = "RightElbow",
            ["LeftLowerLeg"] = "LeftKnee", ["RightLowerLeg"] = "RightKnee", ["LowerTorso"] = "Root",
            ["UpperTorso"] = "Waist"
        }

        local joints = {}
        for partName, jointName in pairs(jointMap) do
            local part = character:FindFirstChild(partName)
            if part then
                local joint = part:FindFirstChild(jointName)
                if joint then
                    joints[partName] = joint
                end
            end
        end
        return joints
    end

    function applyKeyframes(kf1, kf2, alpha, joints)
        local cfs1, cfs2 = {}, {}

        for _, desc in ipairs(kf1:GetDescendants()) do
            if joints[desc.Name] then
                cfs1[desc.Name] = desc.CFrame
            end
        end
        for _, desc in ipairs(kf2:GetDescendants()) do
            if joints[desc.Name] then
                cfs2[desc.Name] = desc.CFrame
            end
        end

        for name, joint in pairs(joints) do
            local cf1, cf2 = cfs1[name], cfs2[name]
            if cf1 and cf2 then 
                joint.Transform = cf1:Lerp(cf2, alpha)
            elseif cf1 then
                joint.Transform = cf1   
            end
        end
    end

    function playAnimationFromAsset(animAsset)
        local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        local Joints = getJoints(character)
        local keyframes = animAsset:GetKeyframes()

        if #keyframes < 2 then return end

        table.sort(keyframes, function(a, b) return a.Time < b.Time end)
        local totalAnimTime = keyframes[#keyframes].Time
        local elapsedAnimTime = 0
        local lastTime = os.clock()

        R157 = R157 or 1
        AnimationActive = true
        StopAnim = false

        CurrentAnimTask = coroutine.create(function()
            while AnimationActive do
                if StopAnim then
                    break
                end

                local now = os.clock()
                local deltaTime = now - lastTime
                lastTime = now

                local speed = math.clamp(R157, 0, 10)
                if speed == 0 then
                    task.wait()
                    continue
                end

                elapsedAnimTime += deltaTime * speed
                if elapsedAnimTime > totalAnimTime then
                    elapsedAnimTime = 0
                end

                local currentKeyframe, nextKeyframe
                for i = 1, #keyframes - 1 do
                    local kf1, kf2 = keyframes[i], keyframes[i + 1]
                    if elapsedAnimTime >= kf1.Time and elapsedAnimTime <= kf2.Time then
                        currentKeyframe, nextKeyframe = kf1, kf2
                        break
                    end
                end

                if currentKeyframe and nextKeyframe then
                    local t0, t1 = currentKeyframe.Time, nextKeyframe.Time
                    local alpha = (t1 > t0) and math.clamp((elapsedAnimTime - t0) / (t1 - t0), 0, 1) or 1

                    local joints1, joints2 = {}, {}
                    for _, pose in ipairs(currentKeyframe:GetDescendants()) do
                        if pose:IsA("Pose") and Joints[pose.Name] then
                            joints1[pose.Name] = pose.CFrame
                        end
                    end

                    for _, pose in ipairs(nextKeyframe:GetDescendants()) do
                        if pose:IsA("Pose") and Joints[pose.Name] then
                            joints2[pose.Name] = pose.CFrame
                        end
                    end

                    for jointName, joint in pairs(Joints) do
                        local cf1, cf2 = joints1[jointName], joints2[jointName]
                        if cf1 and cf2 then
                            joint.Transform = cf1:Lerp(cf2, alpha)
                        elseif cf1 then
                            joint.Transform = cf1
                        end
                    end
                end

                task.wait()
            end

            AnimationActive = false
            StopAnim = true
        end)

        coroutine.resume(CurrentAnimTask)
    end


    function PlayAnimR15(AnimationID)
        if not R15reanimated then
            return
        end

        CurrentAnimationID = AnimationID

        local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            local animator = humanoid:FindFirstChild("Animator")
            if animator then animator:Destroy() end
        end

        local animate = character:FindFirstChild("Animate")
        if animate then animate.Enabled = false end


        if CachedKeyframes[AnimationID] then
            stopCurrentAnimation()
            playAnimationFromAsset(CachedKeyframes[AnimationID])
            return
        end


        if table.find(LoadingKeyFrames, AnimationID) then return end
        table.insert(LoadingKeyFrames, AnimationID)

        task.spawn(function()
            local success, animAsset = pcall(function()
                return game:GetObjects("rbxassetid://" .. AnimationID)[1]
            end)


            local index = table.find(LoadingKeyFrames, AnimationID)
            if index then
                table.remove(LoadingKeyFrames, index)
            end

            if not success or not animAsset then
                Message("Error:", "Failed to load animation asset: " .. AnimationID, 5)
                return
            end

            CachedKeyframes[AnimationID] = animAsset

            stopCurrentAnimation()
            playAnimationFromAsset(animAsset)
        end)
    end

    Reanimate:CreateBox("Animation ID", "string", function(AnimationID)
        if not R15reanimated then
            Message("R15 Reanimate Status:", "False.", 3)
            return
        end
        PlayAnimR15(AnimationID)

    end)
    
    local MarketplaceService = game:GetService("MarketplaceService")
    
    local r15AnimationList = {
        
    }
    
    local animationNames = {}
    local animationMap = {}
    
    
    for _, animationId in ipairs(r15AnimationList) do
        local success, productInfo = pcall(MarketplaceService.GetProductInfo, MarketplaceService, animationId)
    
        if success then
            table.insert(animationNames, productInfo.Name)
            animationMap[productInfo.Name] = animationId
        else
        end
    end
    
    local HttpService = game:GetService("HttpService")
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    
    local currentAnimation = nil
    local SavedAnimationsFile = {}
    local SavedAnimationsFileValues = {}
    local dropdownOptions = {}

    function saveConfig()
        if isfile("HaxterFelix/R15Animations.txt") then
            delfile("HaxterFelix/R15Animations.txt")
        end
    
        writefile("HaxterFelix/R15Animations.txt", HttpService:JSONEncode(SavedAnimationsFile))
    end
    
    if not isfile("HaxterFelix") then
        makefolder("HaxterFelix")
    end
    
    local ValuesOfR15Animations = {}
    
    function loadConfig()
        dropdownOptions = {}
        local configPath = "HaxterFelix/R15Animations.txt"
        local defaultConfig = {
            SavedAnimationsFile = {},
            ValuesOfR15Animations = {}
        }
    
        if isfile(configPath) then
            local fileContent = readfile(configPath)
            
            local lines = {}
            for line in fileContent:gmatch("[^\r\n]+") do
                table.insert(lines, line)
            end
    
            
            for _, line in ipairs(lines) do
                local animID, name = line:match("^(%d+) = (.+)$")
                if animID and name then
                    SavedAnimationsFile[tonumber(animID)] = name
                    ValuesOfR15Animations[name] = tonumber(animID)
                end
            end
    
            for _, name in pairs(SavedAnimationsFile) do
                table.insert(dropdownOptions, name)
            end
        else
            
            SavedAnimationsFile = defaultConfig.SavedAnimationsFile
            ValuesOfR15Animations = defaultConfig.ValuesOfR15Animations
        end
    end
    
    
    function selectAnimation(id)
        local animationName = SavedAnimationsFile[id]
        if animationName then
        else
        end
    end
    

    
    loadConfig()
    local R15DropdownScript
    function RefreshSavedAnimations()
        loadConfig()
        if R15DropdownScript then
            R15DropdownScript:Refresh(dropdownOptions)
        end
    end

    Reanimate:CreateButton("Save Animation", function()
        local animationID = CurrentAnimationID
        local animationName = MarketplaceService:GetProductInfo(animationID).Name

        if animationID and animationName and not ValuesOfR15Animations[animationName] then

            SavedAnimationsFile[animationID] = animationName
            ValuesOfR15Animations[animationName] = animationID

            local fileContent = ""
            for id, name in pairs(SavedAnimationsFile) do
                fileContent = fileContent .. id .. " = " .. name .. "\n"

            end

            writefile("HaxterFelix/R15Animations.txt", fileContent)

            for name, value in pairs(ValuesOfR15Animations) do
            end
            wait(0.3)
            RefreshSavedAnimations()
        else
        end
    end)

    Player:CreateToggle("Invis Cam", function(InvisCam)
        if InvisCam then
        game:GetService("Players").LocalPlayer.DevCameraOcclusionMode = "Invisicam"
    else
        game:GetService("Players").LocalPlayer.DevCameraOcclusionMode = "Zoom"
    end
    end)

    Reanimate:CreateButton("Stop Animation", function(StopAnimation)
        if not R15reanimated then 
            Message("Error:", "Please Reanimate", 5)
            return 
        end
        if not AnimationActive then 
            Message("Error:", "No Animation Playing", 5)
            return 
        end
        EmotePlayingR15 = false

        AnimationActive = false
        StopAnim = true
        local Animator = Instance.new('Animator', plr.Character.Humanoid)
        wait(0.05)
        plr.Character.Animate.Enabled = true
    end)
local EmotesTable = {}
if isfile("EmoteToPlay.lua") then
    local success, emotesData = pcall(function()
        return loadstring(readfile("EmoteToPlay.lua"))()
    end)
    if success and type(emotesData) == "table" then
        EmotesTable = emotesData
    else
        warn(" Failed to load or parse EmoteToPlay.lua")
    end
else
    warn(" EmoteToPlay.lua not found!")
end

-- Prepare dropdown
local dropdownOptions = {}
for emoteName, data in pairs(EmotesTable) do
    if type(data) == "table" and #data > 0 and type(data[1]) == "table" and data[1].Time and data[1].Data then
        print(" Found emote:", emoteName)
        table.insert(dropdownOptions, emoteName)
    else
        print(" Skipping non-emote entry:", emoteName)
    end
end

table.sort(dropdownOptions)

-- Create slider
Reanimate:CreateSlider("Animation Speed Adjuster", 0, 100, 50, function(R157Changer)
    R157 = R157Changer / 50  
end)

-- Create dropdown
local reanimater15 = Reanimate:CreateDropdown("Built In Animations", dropdownOptions, function(selected)
    if not R15reanimated then return end

    local animFrames = EmotesTable[selected]
    if not animFrames then
        Message("Error:", "Emote not found: " .. tostring(selected), 3)
        return
    end

    local animationState = {}

    local function beginPlayback(frames)
        animationState.keyframes = frames
        animationState.totalDuration = frames[#frames].Time

        local character = plr.Character or plr.CharacterAdded:Wait()
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            local animator = humanoid:FindFirstChild("Animator")
            if animator then animator:Destroy() end
        end

        local animate = character:FindFirstChild("Animate")
        if animate then animate.Enabled = false end

        local elapsedTime = 0
        local Joints = getJoints(character)

        R157 = R157 or 1
        AnimationActive = true
        StopAnim = false
        EmotePlayingR15 = true

        if CurrentAnimConnection then
            CurrentAnimConnection:Disconnect()
        end

        CurrentAnimConnection = RunService.Heartbeat:Connect(function(deltaTime)
            if not AnimationActive or StopAnim then
                AnimationActive = false
                StopAnim = true
                if CurrentAnimConnection then
                    CurrentAnimConnection:Disconnect()
                    CurrentAnimConnection = nil
                end
                return
            end

            local speed = math.clamp(R157, 0, 10)
            if speed == 0 then return end

            elapsedTime += deltaTime * speed
            if elapsedTime > animationState.totalDuration then
                elapsedTime = 0
            end

            local keyframes = animationState.keyframes
            local currentIndex = 1
            for i = 1, #keyframes - 1 do
                if elapsedTime >= keyframes[i].Time and elapsedTime <= keyframes[i + 1].Time then
                    currentIndex = i
                    break
                end
            end

            local kf1, kf2 = keyframes[currentIndex], keyframes[currentIndex + 1]
            local alpha = math.clamp((elapsedTime - kf1.Time) / (kf2.Time - kf1.Time), 0, 1)

            local joints1, joints2 = {}, {}

            for partName, cf in pairs(kf1.Data) do joints1[partName] = cf end
            for partName, cf in pairs(kf2.Data) do joints2[partName] = cf end

            for jointName, joint in pairs(Joints) do
                local cf1 = joints1[jointName]
                local cf2 = joints2[jointName]

                if cf1 and cf2 then
                    joint.Transform = cf1:Lerp(cf2, alpha)
                elseif cf1 then
                    joint.Transform = cf1
                end
            end
        end)
    end

    stopCurrentAnimation()
    beginPlayback(animFrames)
end)
function refreshDropdown()
    reanimater15:Refresh(dropdownOptions)
end




    R15DropdownScript = Reanimate:CreateDropdown("Saved Animations", dropdownOptions, function(SelectedR15Animation)
    if not R15reanimated then return end

    local animId = ValuesOfR15Animations[SelectedR15Animation]
    if not animId then
        Message("Error:", "No ID.", 3)
        return
    end

    local animationState = {}

    function beginPlayback(animAsset)
        animationState.currentId = animId
        animationState.keyframes = animAsset:GetKeyframes()
        animationState.totalDuration = animationState.keyframes[#animationState.keyframes].Time

        local character = plr.Character or plr.CharacterAdded:Wait()
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            local animator = humanoid:FindFirstChild("Animator")
            if animator then animator:Destroy() end
        end

        local animate = character:FindFirstChild("Animate")
        if animate then animate.Enabled = false end

        local elapsedTime = 0
        local Joints = getJoints(character)

        R157 = R157 or 1
        AnimationActive = true
        StopAnim = false
        CurrentAnimationID = animId
        EmotePlayingR15 = true

        if CurrentAnimConnection then
            CurrentAnimConnection:Disconnect()
        end

        CurrentAnimConnection = RunService.Heartbeat:Connect(function(deltaTime)
            if not AnimationActive or StopAnim then
                AnimationActive = false
                StopAnim = true
                if CurrentAnimConnection then
                    CurrentAnimConnection:Disconnect()
                    CurrentAnimConnection = nil
                end
                return
            end

            local speed = math.clamp(R157, 0, 10)
            if speed == 0 then return end

            elapsedTime += deltaTime * speed
            if elapsedTime > animationState.totalDuration then
                elapsedTime = 0
            end

            local keyframes = animationState.keyframes
            local currentIndex = 1
            for i = 1, #keyframes - 1 do
                if elapsedTime >= keyframes[i].Time and elapsedTime <= keyframes[i + 1].Time then
                    currentIndex = i
                    break
                end
            end

            local kf1, kf2 = keyframes[currentIndex], keyframes[currentIndex + 1]
            local alpha = math.clamp((elapsedTime - kf1.Time) / (kf2.Time - kf1.Time), 0, 1)

            local joints1, joints2 = {}, {}

            for _, pose in ipairs(kf1:GetDescendants()) do
                if pose:IsA("Pose") then
                    joints1[pose.Name] = pose.CFrame
                end
            end

            for _, pose in ipairs(kf2:GetDescendants()) do
                if pose:IsA("Pose") then
                    joints2[pose.Name] = pose.CFrame
                end
            end

            for jointName, joint in pairs(Joints) do
                local cf1 = joints1[jointName]
                local cf2 = joints2[jointName]

                if cf1 and cf2 then
                    joint.Transform = cf1:Lerp(cf2, alpha)
                elseif cf1 then
                    joint.Transform = cf1
                end
            end
        end)
    end

    
    if CachedKeyframes[SelectedR15Animation] then
        stopCurrentAnimation()
        beginPlayback(CachedKeyframes[SelectedR15Animation])
        return
    end

    if table.find(LoadingKeyFrames, SelectedR15Animation) then
        return
    end
    task.spawn(function()

    table.insert(LoadingKeyFrames, SelectedR15Animation)
    end)
    task.spawn(function()
        Message("Loading...", SelectedR15Animation, 1)
    end)

    task.spawn(function()
        local success, animAsset = pcall(function()
            return game:GetObjects("rbxassetid://" .. animId)[1]
        end)

        if not success or not animAsset then
            Message("Error:", "Failed to load animation asset.", 5)
            return
        end

        local keyframes = animAsset:GetKeyframes()
        table.sort(keyframes, function(a, b) return a.Time < b.Time end)

        CachedKeyframes[SelectedR15Animation] = animAsset

        stopCurrentAnimation()
        beginPlayback(animAsset)
    end)
    end)

    local BundleAnimations = {
        ["Ghoul"] = {
            Idle1 = "70375165570005",
            Idle2 = "125297495838364",
            Walk = "133384983792574",
            Jump = "90476847588208",
            Fall = "92476906497880",
        },
        ["Mario"] = {
            Idle1 = "123535545508396",
            Idle2 = "123535545508396",
            Walk = "113842454592753",
            Fall = "85998191316243",
        },
        ["Sonic"] = {
            Idle1 = "79959087101646",
            Idle2 = "93150740949815",
            Walk = "114083253231776",
            Run = "85348354340876",
            Fall = "124102683487743",
        },
        ["Steve"] = {
            Idle1 = "87940284786141",
            Idle2 = "86448640636041",
            Walk = "73797342305007",
            Run = "121737313718701",
            Fall = "90141209627024",
        },
        ["Sk8tr"] = {
            Idle1 = "123280654495775",
            Idle2 = "138829974274539",
            Walk = "102991148198373",
            Run = "132244227605169",
            Fall = "73107394153657",
        },
        ["Garry's Mod"] = {
            Idle1 = "135106186777948",
            Idle2 = "116448075157345",
            Walk = "138116381768231",
            Run = "133961206309287",
            Fall = "123007240693063",
        },
        ["Jolly"] = {
            Idle1 = "114744077527863",
            Idle2 = "80672406469860",
            Walk = "118910249151966",
            Run = "84568959237630",
            Fall = "100475529580950",
        },
    }

    local currentState
    local steppedConnection
    local idleCoroutine

    Reanimate:CreateDropdown("R15 Custom Bundles", CustomBundle, function(selectedMode)
        mode = selectedMode
        if steppedConnection then
            steppedConnection:Disconnect()
            steppedConnection = nil
        end
        if idleCoroutine then
            coroutine.close(idleCoroutine)
            idleCoroutine = nil
        end
        AnimationActive = false
        StopAnim = true
        currentState = nil
        if mode == "None" then
            return
        end
        if not R15reanimated then 
            Message("Error:", "Please Reanimate", 5)
            return 
        end
        local character = plr.Character or plr.CharacterAdded:Wait()
        local humanoid = character:FindFirstChild("Humanoid")
        local animate = character:FindFirstChild("Animate")
        local root = character:FindFirstChild("HumanoidRootPart")
        if humanoid then
            local animator = humanoid:FindFirstChild("Animator")
            if animator then animator:Destroy() end
            Instance.new("Animator", humanoid)
        end
        if animate then
            animate.Enabled = false
        end
        AnimationActive = true
        StopAnim = false

        local bundle = BundleAnimations[mode]
        if bundle and bundle.Idle1 then
            currentState = "Idle"
            PlayAnimR15(bundle.Idle1)
        end


        idleCoroutine = coroutine.create(function()
            while AnimationActive do
                if currentState == "Idle" and not EmotePlayingR15 then
                    task.wait(math.random(7, 20))
                    if currentState == "Idle" and not EmotePlayingR15 then
                        if bundle and bundle.Idle2 then
                            PlayAnimR15(bundle.Idle2)
                            task.wait(5.5)
                            if currentState == "Idle" and not EmotePlayingR15 then
                                PlayAnimR15(bundle.Idle1)
                            end
                        end
                    end
                else
                    task.wait(1)
                end
            end
        end)
        coroutine.resume(idleCoroutine)


        steppedConnection = game:GetService("RunService").Stepped:Connect(function()
            if not AnimationActive or not root or EmotePlayingR15 then return end

            local state = humanoid:GetState()
            local moving = humanoid.MoveDirection.Magnitude > 0
            local newState

            if state == Enum.HumanoidStateType.Freefall then
                newState = "Fall"
            elseif state == Enum.HumanoidStateType.Jumping then
                newState = "Jump"
            elseif moving then
                newState = "Walk"
            else
                newState = "Idle"
            end

            if newState ~= currentState then
                currentState = newState
                if not bundle then return end

                if currentState == "Idle" then
                    PlayAnimR15(bundle.Idle1)
                elseif currentState == "Jump" then
                    PlayAnimR15(bundle.Jump or bundle.Fall)
                elseif currentState == "Fall" then
                    PlayAnimR15(bundle.Fall)
                elseif currentState == "Walk" then
                    PlayAnimR15(bundle.Run or bundle.Walk)
                end
            end
        end)
    end)


    loadConfig()
    Reanimate:CreateButton("R6 Reanimate", function(state)
            if R15reanimated or plr.Character.Humanoid.Health == 0 then
                Message("R15 Reanimate Status:", "Active", 5)
                return 
            end
            if R6reanimated or plr.Character.Humanoid.Health == 0 then
                Message("R6 Reanimate Status:", "Active", 5)
                return 
            end
            R6reanimated = true
            if "HaxterFelix is the best" then
            
                local v3_net, v3_808 = Vector3.new(0, 0, 0), Vector3.new(0, 0, 0)    
                function getNetlessVelocity(realPartVelocity)
                    local mag = realPartVelocity.Magnitude
                    if mag > 0 then
                        local unit = realPartVelocity.Unit
                        if (unit.Y > 0.0) or (unit.Y < -0.0) then
                            return unit * (0.0 / unit.Y)
                        end
                    end
                    return v3_net + realPartVelocity * v3_808
                end
                local args = {
    	"Ball"
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Ragdoll"):FireServer(unpack(args))



                local simradius = "shp" 
                local simrad = 0 
                local healthHide = false 
                local reclaim = true 


                local novoid = true 
                local physp = nil 

                local noclipAllParts = false 
                local antiragdoll = false 
                local newanimate = false 
                local discharscripts = false 
                local R15toR6 = true 
                local hatcollide = false 
                local humState16 = true 
                local addtools = false 
                local hedafterneck = true 
                local loadtime = game:GetService("Players").RespawnTime + 0.5 
                local method = 3 


                local alignmode = 4 
                local flingpart = "HumanoidRootPart" 

                local lp = game:GetService("Players").LocalPlayer
                local rs, ws, sg = game:GetService("RunService"), game:GetService("Workspace"), game:GetService("StarterGui")    local stepped, heartbeat, renderstepped = rs.Stepped, rs.Heartbeat, rs.RenderStepped
                local twait, tdelay, rad, inf, abs, clamp = task.wait, task.delay, math.rad, math.huge, math.abs, math.clamp
                local cf, v3 = CFrame.new, Vector3.new
                local angles = CFrame.Angles
                local v3_0, cf_0 = v3(0, 0, 0), cf(0, 0, 0)

                local c = lp.Character
                if not (c and c.Parent) then
                    return
                end
            
                c:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not (c and c.Parent) then
                        c = nil
                    end
                end)
            
                local clone, destroy, getchildren, getdescendants, isa = c.Clone, c.Destroy, c.GetChildren, c.GetDescendants, c.IsA
            
                function gp(parent, name, className)
                    if typeof(parent) == "Instance" then
                        for i, v in pairs(getchildren(parent)) do
                            if (v.Name == name) and isa(v, className) then
                                return v
                            end
                        end
                    end
                    return nil
                end
            
                local fenv = getfenv()
            
                local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
                local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.setsimrad or fenv.set_sim_rad
            
                healthHide = healthHide and ((method == 0) or (method == 3)) and gp(c, "Head", "BasePart")
            
                local reclaim, lostpart = reclaim and c.PrimaryPart, nil
            
                function align(Part0, Part1)
                
                    local att0 = Instance.new("Attachment")
                    att0.Position, att0.Orientation, att0.Name = v3_0, v3_0, "att0_" .. Part0.Name
                    local att1 = Instance.new("Attachment")
                    att1.Position, att1.Orientation, att1.Name = v3_0, v3_0, "att1_" .. Part1.Name
                
                    if alignmode == 4 then
                    
                        local hide = false
                        if Part0 == healthHide then
                            healthHide = false
                            tdelay(0, function()
                                while twait(2.9) and Part0 and c do
                                    hide = #Part0:GetConnectedParts() == 1
                                    twait(0.1)
                                    hide = false
                                end
                            end)
                        end
                    
                        local rot = rad(0.05)
                        local con0, con1 = nil, nil
                        con0 = stepped:Connect(function()
                            if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
                            Part0.RotVelocity = Part1.RotVelocity
                        end)
                        local lastpos = Part0.Position
                        con1 = heartbeat:Connect(function(delta)
                            if not (Part0 and Part1 and att1) then return con0:Disconnect() and con1:Disconnect() end
                            if (not Part0.Anchored) and (Part0.ReceiveAge == 0) then
                                if lostpart == Part0 then
                                    lostpart = nil
                                end
                                rot = -rot
                                local newcf = Part1.CFrame * att1.CFrame * angles(0, 0, rot)
                                if Part1.Velocity.Magnitude > 0.01 then
                                    Part0.Velocity = getNetlessVelocity(Part1.Velocity)
                                else
                                    Part0.Velocity = getNetlessVelocity((newcf.Position - lastpos) / delta)
                                end
                                lastpos = newcf.Position
                                if lostpart and (Part0 == reclaim) then
                                    newcf = lostpart.CFrame
                                elseif hide then
                                    newcf += v3(0, 3000, 0)
                                end
                                if novoid and (newcf.Y < ws.FallenPartsDestroyHeight + 0.1) then
                                    newcf += v3(0, ws.FallenPartsDestroyHeight + 0.1 - newcf.Y, 0)
                                end
                                Part0.CFrame = newcf
                            elseif (not Part0.Anchored) and (abs(Part0.Velocity.X) < 45) and (abs(Part0.Velocity.Y) < 25) and (abs(Part0.Velocity.Z) < 45) then
                                lostpart = Part0
                            end
                        end)
                    
                    else
                    
                        Part0.CustomPhysicalProperties = physp
                        if (alignmode == 1) or (alignmode == 2) then
                            local ape = Instance.new("AlignPosition")
                            ape.MaxForce, ape.MaxVelocity, ape.Responsiveness = inf, inf, inf
                            ape.ReactionForceEnabled, ape.RigidityEnabled, ape.ApplyAtCenterOfMass = false, true, false
                            ape.Attachment0, ape.Attachment1, ape.Name = att0, att1, "AlignPositionRtrue"
                            ape.Parent = att0
                        end
                    
                        if (alignmode == 2) or (alignmode == 3) then
                            local apd = Instance.new("AlignPosition")
                            apd.MaxForce, apd.MaxVelocity, apd.Responsiveness = inf, inf, inf
                            apd.ReactionForceEnabled, apd.RigidityEnabled, apd.ApplyAtCenterOfMass = false, false, false
                            apd.Attachment0, apd.Attachment1, apd.Name = att0, att1, "AlignPositionRfalse"
                            apd.Parent = att0
                        end
                    
                        local ao = Instance.new("AlignOrientation")
                        ao.MaxAngularVelocity, ao.MaxTorque, ao.Responsiveness = inf, inf, inf
                        ao.PrimaryAxisOnly, ao.ReactionTorqueEnabled, ao.RigidityEnabled = false, false, false
                        ao.Attachment0, ao.Attachment1 = att0, att1
                        ao.Parent = att0
                    
                        local con0, con1 = nil, nil
                        local vel = Part0.Velocity
                        con0 = renderstepped:Connect(function()
                            if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
                            Part0.Velocity = vel
                        end)
                        local lastpos = Part0.Position
                        con1 = heartbeat:Connect(function(delta)
                            if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
                            vel = Part0.Velocity
                            if Part1.Velocity.Magnitude > 0.01 then
                                Part0.Velocity = getNetlessVelocity(Part1.Velocity)
                            else
                                Part0.Velocity = getNetlessVelocity((Part0.Position - lastpos) / delta)
                            end
                            lastpos = Part0.Position
                        end)
                    
                    end
                
                    att0:GetPropertyChangedSignal("Parent"):Connect(function()
                        Part0 = att0.Parent
                        if not isa(Part0, "BasePart") then
                            att0 = nil
                            if lostpart == Part0 then
                                lostpart = nil
                            end
                            Part0 = nil
                        end
                    end)
                    att0.Parent = Part0
                
                    att1:GetPropertyChangedSignal("Parent"):Connect(function()
                        Part1 = att1.Parent
                        if not isa(Part1, "BasePart") then
                            att1 = nil
                            Part1 = nil
                        end
                    end)
                    att1.Parent = Part1
                end
            
                function respawnrequest()
                    local ccfr, c = ws.CurrentCamera.CFrame, lp.Character
                    lp.Character = nil
                    lp.Character = c
                    local con = nil
                    con = ws.CurrentCamera.Changed:Connect(function(prop)
                        if (prop ~= "Parent") and (prop ~= "CFrame") then
                            return
                        end
                        ws.CurrentCamera.CFrame = ccfr
                        con:Disconnect()
                    end)
                end
            
                local destroyhum = (method == 4) or (method == 5)
                local breakjoints = (method == 0) or (method == 4)
                local antirespawn = (method == 0) or (method == 2) or (method == 3)
            
                hatcollide = hatcollide and (method == 0)
            
                addtools = addtools and lp:FindFirstChildOfClass("Backpack")
            
                if type(simrad) ~= "number" then simrad = 1000 end
                if shp and (simradius == "shp") then
                    tdelay(0, function()
                        while c do
                            shp(lp, "SimulationRadius", simrad)
                            heartbeat:Wait()
                        end
                    end)
                elseif ssr and (simradius == "ssr") then
                    tdelay(0, function()
                        while c do
                            ssr(simrad)
                            heartbeat:Wait()
                        end
                    end)
                end
            
                if antiragdoll then
                    antiragdoll = function(v)
                        if isa(v, "HingeConstraint") or isa(v, "BallSocketConstraint") then
                            v.Parent = nil
                        end
                    end
                    for i, v in pairs(getdescendants(c)) do
                        antiragdoll(v)
                    end
                    c.DescendantAdded:Connect(antiragdoll)
                end
            
                if antirespawn then

                end
            
                if method == 0 then
                    twait(loadtime)
                    if not c then
                        return
                    end
                end
            
                if discharscripts then
                    for i, v in pairs(getdescendants(c)) do
                        if isa(v, "LocalScript") then
                            v.Disabled = true
                        end
                    end
                elseif newanimate then
                    local animate = gp(c, "Animate", "LocalScript")
                    if animate and (not animate.Disabled) then
                        animate.Disabled = true
                    else
                        newanimate = false
                    end
                end
            
                if addtools then
                    for i, v in pairs(getchildren(addtools)) do
                        if isa(v, "Tool") then
                            v.Parent = c
                        end
                    end
                end
            
                pcall(function()
                    settings().Physics.AllowSleep = false
                    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
                end)
            
                local OLDscripts = {}
            
                for i, v in pairs(getdescendants(c)) do
                    if v.ClassName == "Script" then
                        OLDscripts[v.Name] = true
                    end
                end
            
                local scriptNames = {}
            
                for i, v in pairs(getdescendants(c)) do
                    if isa(v, "BasePart") then
                        local newName, exists = tostring(i), true
                        while exists do
                            exists = OLDscripts[newName]
                            if exists then
                            newName = newName .. "_"    
                        end
                    end
                    table.insert(scriptNames, newName)
                    Instance.new("Script", v).Name = newName
                end
            end
    
            local hum = c:FindFirstChildOfClass("Humanoid")
            if hum then
                for i, v in pairs(hum:GetPlayingAnimationTracks()) do
                    v:Stop()
                end
            end
            c.Archivable = true
            local cl = clone(c)
            if hum and humState16 then
                hum:ChangeState(Enum.HumanoidStateType.Physics)
                if destroyhum then
                    twait(1.6)
                end
            end
            if destroyhum then
                pcall(destroy, hum)
            end
    
            if not c then
                return
            end
    
            local head, torso, root = gp(c, "Head", "BasePart"), gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart"), gp(c, "HumanoidRootPart", "BasePart")
            if hatcollide then
                pcall(destroy, torso)
                pcall(destroy, root)
                pcall(destroy, c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script"))
            end
    
            local model = Instance.new("Model", c)
            model:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (model and model.Parent) then
                    model = nil
                end
            end)
    
            for i, v in pairs(getchildren(c)) do
                if v ~= model then
                    if addtools and isa(v, "Tool") then
                        for i1, v1 in pairs(getdescendants(v)) do
                            if v1 and v1.Parent and isa(v1, "BasePart") then
                                local bv = Instance.new("BodyVelocity")
                                bv.Velocity, bv.MaxForce, bv.P, bv.Name = v3_0, v3(1000, 1000, 1000), 1250, "bv_" .. v.Name
                                bv.Parent = v1
                            end
                        end
                    end
                    v.Parent = model
                end
            end
    
            if breakjoints then
                model:BreakJoints()
            else
                if head and torso then
                    for i, v in pairs(getdescendants(model)) do
                        if isa(v, "JointInstance") then
                            local save = false
                            if (v.Part0 == torso) and (v.Part1 == head) then
                                save = true
                            end
                            if (v.Part0 == head) and (v.Part1 == torso) then
                                save = true
                            end
                            if save then
                                if hedafterneck then
                                    hedafterneck = v
                                end
                            else
                                pcall(destroy, v)
                            end
                        end
                    end
                end
                if method == 3 then
                    task.delay(loadtime, pcall, model.BreakJoints, model)
                end
            end
    
            cl.Parent = ws
            for i, v in pairs(getchildren(cl)) do
                v.Parent = c
            end
            pcall(destroy, cl)
    
            local uncollide, noclipcon = nil, nil
            if noclipAllParts then
                uncollide = function()
                    if c then
                        for i, v in pairs(getdescendants(c)) do
                            if isa(v, "BasePart") then
                                v.CanCollide = false
                            end
                        end
                    else
                        noclipcon:Disconnect()
                    end
                end
            else
                uncollide = function()
                    if model then
                        for i, v in pairs(getdescendants(model)) do
                            if isa(v, "BasePart") then
                                v.CanCollide = false
                            end
                        end
                    else
                        noclipcon:Disconnect()
                    end
                end
            end
            noclipcon = stepped:Connect(uncollide)
            uncollide()
    
            for i, scr in pairs(getdescendants(model)) do
                if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
                    local Part0 = scr.Parent
                    if isa(Part0, "BasePart") then
                        for i1, scr1 in pairs(getdescendants(c)) do
                            if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
                                local Part1 = scr1.Parent
                                if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
                                    align(Part0, Part1)
                                    pcall(destroy, scr)
                                    pcall(destroy, scr1)
                                    break
                                end
                            end
                        end
                    end
                end
            end
    
            for i, v in pairs(getdescendants(c)) do
                if v and v.Parent and (not v:IsDescendantOf(model)) then
                    if isa(v, "Decal") then
                        v.Transparency = 1
                    elseif isa(v, "BasePart") then
                        v.Transparency = 1
                        v.Anchored = false
                    elseif isa(v, "ForceField") then
                        v.Visible = false
                    elseif isa(v, "Sound") then
                        v.Playing = false
                    elseif isa(v, "BillboardGui") or isa(v, "SurfaceGui") or isa(v, "ParticleEmitter") or isa(v, "Fire") or isa(v, "Smoke") or isa(v, "Sparkles") then
                        v.Enabled = false
                    end
                end
            end
    
            if newanimate then
                local animate = gp(c, "Animate", "LocalScript")
                if animate then
                    animate.Disabled = false
                end
            end
    
            if addtools then
                for i, v in pairs(getchildren(c)) do
                    if isa(v, "Tool") then
                        v.Parent = addtools
                    end
                end
            end
    
            local hum0, hum1 = model:FindFirstChildOfClass("Humanoid"), c:FindFirstChildOfClass("Humanoid")
            if hum0 then
                hum0:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not (hum0 and hum0.Parent) then
                        hum0 = nil
                    end
                end)
            end
            if hum1 then
                hum1:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not (hum1 and hum1.Parent) then
                        hum1 = nil
                    end
                end)
            
                ws.CurrentCamera.CameraSubject = hum1
                local camSubCon = nil
                function camSubFunc()
                    camSubCon:Disconnect()
                    if c and hum1 then
                        ws.CurrentCamera.CameraSubject = hum1
                    end
                end
                camSubCon = renderstepped:Connect(camSubFunc)
                if hum0 then
                    hum0:GetPropertyChangedSignal("Jump"):Connect(function()
                        if hum1 then
                            hum1.Jump = hum0.Jump
                        end
                    end)
                else
                    
                end
            end
    
            local rb = Instance.new("BindableEvent", c)
            rb.Event:Connect(function()
                pcall(destroy, rb)
                sg:SetCore("ResetButtonCallback", true)
                if destroyhum then
                    if c then c:BreakJoints() end
                    return
                end
                if model and hum0 and (hum0.Health > 0) then
                    model:BreakJoints()
                    hum0.Health = 0
                end
                if antirespawn then
                    
                end
            end)
            sg:SetCore("ResetButtonCallback", rb)
    
            tdelay(0, function()
                while c do
                    if hum0 and hum1 then
                        hum1.Jump = hum0.Jump
                    end
                    wait()
                end
                sg:SetCore("ResetButtonCallback", true)
            end)
    
            R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
            if R15toR6 then
                local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
                if part then
                    local cfr = part.CFrame
                    local R6parts = { 
                        head = {
                            Name = "Head",
                            Size = v3(2, 1, 1),
                            R15 = {
                                Head = 0
                            }
                        },
                        torso = {
                            Name = "Torso",
                            Size = v3(2, 2, 1),
                            R15 = {
                                UpperTorso = 0.2,
                                LowerTorso = -0.8
                            }
                        },
                        root = {
                            Name = "HumanoidRootPart",
                            Size = v3(2, 2, 1),
                            R15 = {
                                HumanoidRootPart = 0
                            }
                        },
                        leftArm = {
                            Name = "Left Arm",
                            Size = v3(1, 2, 1),
                            R15 = {
                                LeftHand = -0.849,
                                LeftLowerArm = -0.174,
                                LeftUpperArm = 0.415
                            }
                        },
                        rightArm = {
                            Name = "Right Arm",
                            Size = v3(1, 2, 1),
                            R15 = {
                                RightHand = -0.849,
                                RightLowerArm = -0.174,
                                RightUpperArm = 0.415
                            }
                        },
                        leftLeg = {
                            Name = "Left Leg",
                            Size = v3(1, 2, 1),
                            R15 = {
                                LeftFoot = -0.85,
                                LeftLowerLeg = -0.29,
                                LeftUpperLeg = 0.49
                            }
                        },
                        rightLeg = {
                            Name = "Right Leg",
                            Size = v3(1, 2, 1),
                            R15 = {
                                RightFoot = -0.85,
                                RightLowerLeg = -0.29,
                                RightUpperLeg = 0.49
                            }
                        }
                    }
                                for i, v in pairs(getchildren(c)) do
                        if isa(v, "BasePart") then
                            for i1, v1 in pairs(getchildren(v)) do
                                if isa(v1, "Motor6D") then
                                    v1.Part0 = nil
                                end
                            end
                        end
                    end
                    part.Archivable = true
                    for i, v in pairs(R6parts) do
                        local part = clone(part)
                        part:ClearAllChildren()
                        part.Name, part.Size, part.CFrame, part.Anchored, part.Transparency, part.CanCollide, part.Massless = v.Name, v.Size, cfr, false, 1, false, false
                        for i1, v1 in pairs(v.R15) do
                            local R15part = gp(c, i1, "BasePart")
                            local att = gp(R15part, "att1_" .. i1, "Attachment")
                            if R15part then
                                local weld = Instance.new("Weld")
                                weld.Part0, weld.Part1, weld.C0, weld.C1, weld.Name = part, R15part, cf(0, v1, 0), cf_0, "Weld_" .. i1
                                weld.Parent = R15part
                                R15part.Massless, R15part.Name = true, "R15_" .. i1
                                R15part.Parent = part
                                if att then
                                    att.Position = v3(0, v1, 0)
                                    att.Parent = part
                                end
                            end
                        end
                        part.Parent = c
                        R6parts[i] = part
                    end
                    local R6joints = {
                        neck = {
                            Parent = R6parts.torso,
                            Name = "Neck",
                            Part0 = R6parts.torso,
                            Part1 = R6parts.head,
                            C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                            C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
                        },
                        rootJoint = {
                            Parent = R6parts.root,
                            Name = "RootJoint" ,
                            Part0 = R6parts.root,
                            Part1 = R6parts.torso,
                            C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                            C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
                        },
                        rightShoulder = {
                            Parent = R6parts.torso,
                            Name = "Right Shoulder",
                            Part0 = R6parts.torso,
                            Part1 = R6parts.rightArm,
                            C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                            C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
                        },
                        leftShoulder = {
                            Parent = R6parts.torso,
                            Name = "Left Shoulder",
                            Part0 = R6parts.torso,
                            Part1 = R6parts.leftArm,
                            C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                            C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
                        },
                        rightHip = {
                            Parent = R6parts.torso,
                            Name = "Right Hip",
                            Part0 = R6parts.torso,
                            Part1 = R6parts.rightLeg,
                            C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                            C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
                        },
                        leftHip = {
                            Parent = R6parts.torso,
                            Name = "Left Hip" ,
                            Part0 = R6parts.torso,
                            Part1 = R6parts.leftLeg,
                            C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                            C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
                        }
                    }
                    for i, v in pairs(R6joints) do
                        local joint = Instance.new("Motor6D")
                        for prop, val in pairs(v) do
                            joint[prop] = val
                        end
                        R6joints[i] = joint
                    end
                    if hum1 then
                        hum1.RigType, hum1.HipHeight = Enum.HumanoidRigType.R6, 0
                    end
                end
            end
            function getJoint(name)
                for i,v in next,R6joints do
                    if v.Name==name then
                        return v
                    end
                end
                return {C0=cf_0,C1=cf_0}
            end
            local torso1 = torso
            torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
            if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
                local conNeck, conTorso, conTorso1 = nil, nil, nil
                local aligns = {}
                function enableAligns()
                    conNeck:Disconnect()
                    conTorso:Disconnect()
                    conTorso1:Disconnect()
                    for i, v in pairs(aligns) do
                        v.Enabled = true
                    end
                end
                conNeck = hedafterneck.Changed:Connect(function(prop)
                    if table.find({"Part0", "Part1", "Parent"}, prop) then
                        enableAligns()
                    end
                end)
                conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
                conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
                for i, v in pairs(getdescendants(head)) do
                    if isa(v, "AlignPosition") or isa(v, "AlignOrientation") then
                        i = tostring(i)
                        aligns[i] = v
                        v:GetPropertyChangedSignal("Parent"):Connect(function()
                            aligns[i] = nil
                        end)
                        v.Enabled = false
                    end
                end
            end
    
            local flingpart0 = gp(model, flingpart, "BasePart") or gp(gp(model, flingpart, "Accessory"), "Handle", "BasePart")
            local flingpart1 = gp(c, flingpart, "BasePart") or gp(gp(c, flingpart, "Accessory"), "Handle", "BasePart")
    
            local fling = function() end
            if flingpart0 and flingpart1 then
                flingpart0:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not (flingpart0 and flingpart0.Parent) then
                        flingpart0 = nil
                        fling = function() end
                    end
                end)
                flingpart0.Archivable = true
                flingpart1:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not (flingpart1 and flingpart1.Parent) then
                        flingpart1 = nil
                        fling = function() end
                    end
                end)
                local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
                local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
                if att0 and att1 then
                    att0:GetPropertyChangedSignal("Parent"):Connect(function()
                        if not (att0 and att0.Parent) then
                            att0 = nil
                            fling = function() end
                        end
                    end)
                    att1:GetPropertyChangedSignal("Parent"):Connect(function()
                        if not (att1 and att1.Parent) then
                            att1 = nil
                            fling = function() end
                        end
                    end)
                    local lastfling = nil
                    local mouse = lp:GetMouse()
                    fling = function(target, duration, rotVelocity)
                        if typeof(target) == "Instance" then
                            if isa(target, "BasePart") then
                                target = target.Position
                            elseif isa(target, "Model") then
                                target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                                if target then
                                    target = target.Position
                                else
                                    return
                                end
                            elseif isa(target, "Humanoid") then
                                target = target.Parent
                                if not (target and isa(target, "Model")) then
                                    return
                                end
                                target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                                if target then
                                    target = target.Position
                                else
                                    return
                                end
                            else
                                return
                            end
                        elseif typeof(target) == "CFrame" then
                            target = target.Position
                        elseif typeof(target) ~= "Vector3" then
                            target = mouse.Hit
                            if target then
                                target = target.Position
                            else
                                return
                            end
                        end
                        if target.Y < ws.FallenPartsDestroyHeight + 5 then
                            target = v3(target.X, ws.FallenPartsDestroyHeight + 5, target.Z)
                        end
                        lastfling = target
                        if type(duration) ~= "number" then
                            duration = tonumber(duration) or 0.5
                        end
                        if typeof(rotVelocity) ~= "Vector3" then
                            rotVelocity = v3(0, 0, 0)
                        end
                        if not (target and flingpart0 and flingpart1 and att0 and att1) then
                            return
                        end
                        flingpart0.Archivable = true
                        local flingpart = clone(flingpart0)
                        flingpart.Transparency = 1
                        flingpart.CanCollide = false
                        flingpart.Name = "flingpart_" .. flingpart0.Name
                        flingpart.Anchored = true
                        flingpart.Velocity = v3_0
                        flingpart.RotVelocity = v3_0
                        flingpart.Position = target
                        flingpart:GetPropertyChangedSignal("Parent"):Connect(function()
                            if not (flingpart and flingpart.Parent) then
                                flingpart = nil
                            end
                        end)
                        flingpart.Parent = flingpart1
                        if flingpart0.Transparency > 0.5 then
                            flingpart0.Transparency = 0.5
                        end
                        att1.Parent = flingpart
                        local con = nil
                        local rotchg = v3(0, rotVelocity.Unit.Y * -1000, 0)
                        con = heartbeat:Connect(function(delta)
                            if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                                flingpart.Orientation += rotchg * delta
                                flingpart0.RotVelocity = rotVelocity
                            else
                                con:Disconnect()
                            end
                        end)
                        if alignmode ~= 4 then
                            local con = nil
                            con = renderstepped:Connect(function()
                                if flingpart0 and target then
                                    flingpart0.RotVelocity = v3_0
                                else
                                    con:Disconnect()
                                end
                            end)
                        end
                        twait(duration)
                        if lastfling ~= target then
                            if flingpart then
                                if att1 and (att1.Parent == flingpart) then
                                    att1.Parent = flingpart1
                                end
                                pcall(destroy, flingpart)
                            end
                            return
                        end
                        target = nil
                        if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                            return
                        end
                        flingpart0.RotVelocity = v3_0
                        att1.Parent = flingpart1
                        pcall(destroy, flingpart)
                    end
                end
            end
        end
    
    
        local plrs = game:GetService("Players")
        local c = plrs.LocalPlayer.Character
        if not c then return end
        local ws = game:GetService("Workspace")
        local raycast = ws.Raycast
        c.AncestryChanged:Connect(function()
            if not c:IsDescendantOf(ws) then
                c = nil
            end
        end)
        local rs = game:GetService("RunService")
        local stepped, renderstepped, heartbeat = rs.Stepped, rs.RenderStepped, rs.Heartbeat
        function gp(parent, name, classname)
            if typeof(parent) == "Instance" then
                for i, v in pairs(parent:GetChildren()) do
                    if (v.Name == name) and v:IsA(classname) then
                        return v
                    end
                end
            end
            return nil
        end
    
        local mrandom, schar, supper = math.random, string.char, string.upper

    
        function addjoint(v)
            table.insert(staticjoints, {C0 = v.C0, C1 = v.C1, Part0 = v.Part0, Part1 = v.Part1})
        end
        for i, v in pairs(c:GetDescendants()) do
            if v:IsA("JointInstance") then 
                pcall(addjoint, v)
            end
        end
    
        for i, v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                local handle = gp(v, "Handle", "BasePart")
                handle.Parent = c
                v:Destroy()
            end
        end
        local staticjoints = {}
        function animjoint(name, parent, Part0, Part1, fakejoint)
            fakejoint.C0 = CFrame.new()
            fakejoint.C1 = CFrame.new()
            local joint = gp(parent, name, "Motor6D")
            if joint then
                for i, v in pairs(staticjoints) do
                    if (v.Part0 == Part0) and (v.Part1 == Part1) then
                        staticjoints[i] = nil
                        break
                    end
                end
                fakejoint.C0 = joint.C0
                fakejoint.C1 = joint.C1
                joint:Destroy()
                joint = nil
            end
            local fix = nil
            local con = nil
            fix = function()
                if not c then
                    return con:Disconnect()
                end
                if not joint then 
                    joint = Instance.new("Weld")
                    joint.Changed:Connect(fix)
                    joint.Destroying:Connect(function() joint = nil fix() end)
                end
                if joint.Part0 ~= Part0 then
                    joint.Part0 = Part0
                end
                if joint.Part1 ~= Part1 then
                    joint.Part1 = Part1
                end
                if joint.C0 ~= fakejoint.C0 then
                    joint.C0 = fakejoint.C0
                end
                if joint.C1 ~= fakejoint.C1 then
                    joint.C1 = fakejoint.C1
                end
                if joint.Name ~= name then
                    joint.Name = name
                end
                if joint.Parent ~= parent then
                    joint.Parent = parent
                end
            end
            con = stepped:Connect(fix)
        end

        local RootJoint = {}
        local RightShoulder = {}
        local LeftShoulder = {}
        local RightHip = {}
        local LeftHip = {}
        local Neck = {}
    

        for i, v in pairs(c:GetChildren()) do
            if v:IsA("Model") and v:FindFirstChildOfClass("Humanoid") then
                for i, v in pairs(v:GetDescendants()) do
                    if v:IsA("JointInstance") then
                        for i, v1 in pairs(staticjoints) do
                            if (v.Part0 == v1.Part0) and (v.Part1 == v1.Part1) then
                                staticjoints[i] = nil
                            end
                        end
                    end
                end
            end
        end

    
        for i, v in pairs(staticjoints) do
            local Part0, Part1, C0, C1 = v.Part0, v.Part1, v.C0, v.C1
            local fix, con, joint = nil, nil, nil
            fix = function()
                if not c then
                    return con:Disconnect()
                end
                if not joint then 
                    joint = Instance.new("Weld")
                    joint.Changed:Connect(fix)
                    joint.Destroying:Connect(function() joint = nil fix() end)
                end
                if joint.Part0 ~= Part0 then
                    joint.Part0 = Part0
                end
                if joint.Part1 ~= Part1 then
                    joint.Part1 = Part1
                end
                if joint.C0 ~= C0 then
                    joint.C0 = C0
                end
                if joint.C1 ~= C1 then
                    joint.C1 = C1
                end
                if joint.Name ~= name then
                    joint.Name = name
                end
                if joint.Parent ~= c then
                    joint.Parent = c
                end
            end
            con = stepped:Connect(fix)
        end

    
        local cf, v3 = CFrame.new, Vector3.new
        local v3_0, v3_101, v3_010, v3_d, v3_u = v3(0, 0, 0), v3(1, 0, 1), v3(0, 1, 0), v3(0, -10000, 0), v3(0, 10000, 0)
        local vel, raycastresult, onground = v3_0, nil, true
    
        local raycastparams = RaycastParams.new()
        raycastparams.FilterType = Enum.RaycastFilterType.Blacklist
        local rayfilter = {}
        local characters = {}
        function refreshrayfilter()
            for i, v in pairs(rayfilter) do
                if not table.find(characters, v) then
                    rayfilter[i] = nil
                end
            end
            for i, v in pairs(characters) do
                if not table.find(rayfilter, v) then
                    table.insert(rayfilter, v)
                end
            end
            raycastparams.FilterDescendantsInstances = rayfilter
        end
        function oncharacter(plr, c)
            characters[plr] = c
            refreshrayfilter()
        end
        function onplayer(v)
            oncharacter(v, v.Character)
            v.CharacterAdded:Connect(function(c)
                oncharacter(v, c)
            end)
        end
        for i, v in pairs(plrs:GetPlayers()) do onplayer(v) end
        plrs.PlayerAdded:Connect(onplayer)
        plrs.PlayerRemoving:Connect(function(v)
            oncharacter(v, nil)
        end)
    
        local legcfR, legcfL, legvec = cf(1, -1.5, 0), cf(-1, -1.5, 0), v3(0, -1.5, 0)
        function raycastlegs()
            local rY, lY = raycast(ws, (cfr * legcfR).Position, legvec, raycastparams), raycast(ws, (cfr * legcfL).Position, legvec, raycastparams)
            return rY and (rY.Position.Y - (cfr.Y - 3)) or 0, lY and (lY.Position.Y - (cfr.Y - 3)) or 0
        end
    
        local euler, sin, sine, abs, clamp = CFrame.fromEulerAnglesXYZ, math.sin, 0, math.abs, math.clamp
        local con = nil
        plr.Character.Humanoid.AutomaticScalingEnabled = false
        plr.Character.Animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=180435571"
        plr.Character.Animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=180435571"
        plr.Character.Animate.walk:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180426354"
        plr.Character.Animate.run:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180426354"
        plr.Character.Animate.jump:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=125750702"
        plr.Character.Animate.fall:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180436148"
        
    end)

    local CharacterWidthR6Global = nil

    Reanimate:CreateSlider("Width", 0, 50, 0, function(CharacterWidthR6)
        if not R6reanimated then
            return
        end
        CharacterWidthR6Global = CharacterWidthR6
        local offset = CharacterWidthR6Global
        local widthChange = offset - previousWidthR6

        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local Joints = {
            ["Torso"] = plr.Character.HumanoidRootPart["RootJoint"],
            ["Right Arm"] =  plr.Character.Torso["Right Shoulder"],
            ["Left Arm"] =  plr.Character.Torso["Left Shoulder"],
            ["Head"] =  plr.Character.Torso["Neck"],
            ["Left Leg"] =  plr.Character.Torso["Left Hip"],
            ["Right Leg"] =  plr.Character.Torso["Right Hip"]
        }

        for jointName, joint in pairs(Joints) do
            if joint then
                if jointName == "Left Arm" then
                    joint.C0 = joint.C0 + Vector3.new(-widthChange * 0.5, 0, 0) 
                elseif jointName == "Right Arm" then
                    joint.C0 = joint.C0 + Vector3.new(widthChange * 0.5, 0, 0) 
                elseif jointName == "Left Leg" then
                    joint.C0 = joint.C0 + Vector3.new(-widthChange * 0.5, 0, 0) 
                elseif jointName == "Right Leg" then
                    joint.C0 = joint.C0 + Vector3.new(widthChange * 0.5, 0, 0) 
                end
            else

            end
        end

        previousWidthR6 = offset
    end)



    Reanimate:CreateSlider("Height", 0, 50, 0, function(CharacterHeight)
    if not R6reanimated then
        return
    end

    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()

    local offset = CharacterHeight / 100
    local changeInHeight = CharacterHeight - previousHeightR6

    local Joints = {
        ["Torso"] = plr.Character.HumanoidRootPart["RootJoint"],
        ["Right Arm"] =  plr.Character.Torso["Right Shoulder"],
        ["Left Arm"] =  plr.Character.Torso["Left Shoulder"],
        ["Head"] =  plr.Character.Torso["Neck"],
        ["Left Leg"] =  plr.Character.Torso["Left Hip"],
        ["Right Leg"] =  plr.Character.Torso["Right Hip"]
    }

    for jointName, joint in pairs(Joints) do
        if joint then
            if jointName == "Torso" then
                joint.C0 = joint.C0 + Vector3.new(0, changeInHeight * 0.1, 0) 
            elseif jointName == "Left Leg" or jointName == "Right Leg" then
                joint.C0 = joint.C0 + Vector3.new(0, -changeInHeight * 0.1, 0) 
            end
        else

        end
    end

    previousHeightR6 = CharacterHeight 
    end)

    Reanimate:CreateSlider("Arms Y ", 0, 50, 0, function(CharacterArmsYaxis)
        if not R6reanimated then
            return
        end

        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        local offset = CharacterArmsYaxis / 100
        local changeInHeight = CharacterArmsYaxis - previousArmstR6

        local Joints = {
            ["Torso"] = plr.Character.HumanoidRootPart["RootJoint"],
            ["Right Arm"] =  plr.Character.Torso["Right Shoulder"],
            ["Left Arm"] =  plr.Character.Torso["Left Shoulder"],
            ["Head"] =  plr.Character.Torso["Neck"],
            ["Left Leg"] =  plr.Character.Torso["Left Hip"],
            ["Right Leg"] =  plr.Character.Torso["Right Hip"]
        }

        for jointName, joint in pairs(Joints) do
            if joint then
                if jointName == "Left Arm" or jointName == "Right Arm" then
                    joint.C0 = joint.C0 + Vector3.new(0, changeInHeight * 0.1, 0) 
            else

            end
            end
        end

        previousArmstR6 = CharacterArmsYaxis 
        end)

    local StopAnim = true
    local AnimationActive = false

    function isValidAnimationID(animationID)
        local success, asset = pcall(function()
            return game:GetObjects("rbxassetid://" .. animationID)[1]
        end)
        return success and asset ~= nil
    end
    Reanimate:CreateBox("Animation ID", "string", function(AnimationID)
        if not R6reanimated then
            Message("R6 Reanimate Status:", "False.", 3)
            return
        end
        local AnimationValue = AnimationID


    if AnimationID then
        CurrentAnimationID = AnimationID
        if not isValidAnimationID(AnimationID) then
            Message("Error:", "Animation Was Deleted!", 5)
            return
        end

            if AnimationActive or not StopAnim then
                StopAnim = true
                AnimationActive = false
                wait(0.085) 
            end

            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()

            local Joints = {
                ["Torso"] = plr.Character.HumanoidRootPart["RootJoint"],
                ["Right Arm"] =  plr.Character.Torso["Right Shoulder"],
                ["Left Arm"] =  plr.Character.Torso["Left Shoulder"],
                ["Head"] =  plr.Character.Torso["Neck"],
                ["Left Leg"] =  plr.Character.Torso["Left Hip"],
                ["Right Leg"] =  plr.Character.Torso["Right Hip"]
            }
            if character:FindFirstChild("Humanoid") and character.Humanoid:FindFirstChild("Animator") then
                character.Humanoid.Animator.Parent = nil
            end
            if character:FindFirstChild("Animate") then
                character.Animate.Enabled = false
            end

            local NeededAssets = game:GetObjects("rbxassetid://" .. AnimationID)[1]
            local TweenService = game:GetService('TweenService')
            local speed = 55
            StopAnim = false
            AnimationActive = true

            local AnimationSpeed = 0.2 
            local frameRate = 1 / 120

            while AnimationActive do
                if StopAnim then
                    AnimationActive = false
                    break
                end
            
                local keyframes = NeededAssets:GetKeyframes()
                for ii, frame in ipairs(keyframes) do
                    if StopAnim then break end
                

                    local rawDuration = keyframes[ii + 1] and (keyframes[ii + 1].Time - frame.Time) or frameRate
                

                    local jointStartCFs = {}
                    local jointGoalCFs = {}
                
                    for _, v in pairs(frame:GetDescendants()) do
                        local joint = Joints[v.Name]
                        if joint then
                            jointStartCFs[v.Name] = joint.Transform
                            jointGoalCFs[v.Name] = v.CFrame
                        end
                    end
                

                    local elapsed = 0
                    while true do
                        if StopAnim then
                            AnimationActive = false
                            break
                        end
                    

                        local duration = rawDuration * (0.65 / R157) * AnimationSpeed
                        local alpha = math.clamp(elapsed / duration, 0, 1)
                    
                        for jointName, startCF in pairs(jointStartCFs) do
                            local joint = Joints[jointName]
                            local goalCF = jointGoalCFs[jointName]
                            if joint and goalCF then
                                joint.Transform = startCF:Lerp(goalCF, alpha)
                            end
                        end
                    
                        if alpha >= 1 then break end
                    
                        task.wait(frameRate)
                        elapsed += frameRate
                    end
                
                    if StopAnim then break end
                end
            
                task.wait(1 / 240) 
            end
        else
            Message("Error:", "No ID.", 3)
        end
    end)

    Reanimate:CreateButton("Stop Animation", function(StopAnimationR6)
        if not R6reanimated then 
            Message("Error:", "Please Reanimate", 5)
            return 
        end
        if not AnimationActive then 
            Message("Error:", "No Animation Playing", 5)
            return 
        end
        plr.Character.Humanoid.Sit = false
        AnimationActive = false
        StopAnim = true


        if connection then
            connection:Disconnect()
            connection = nil
        end

        game.Workspace.Gravity = 196.2
        local Joints = {
            ["Torso"] = plr.Character.HumanoidRootPart["RootJoint"],
            ["Right Arm"] = plr.Character.Torso["Right Shoulder"],
            ["Left Arm"] = plr.Character.Torso["Left Shoulder"],
            ["Head"] = plr.Character.Torso["Neck"],
            ["Left Leg"] = plr.Character.Torso["Left Hip"],
            ["Right Leg"] = plr.Character.Torso["Right Hip"]
        }


        local OriginalCFrames = {
            ["Torso"] = {
                C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
            },
            ["Right Arm"] = {
                C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
            },
            ["Left Arm"] = {
                C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
            },
            ["Head"] = {
                C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
            },
            ["Left Leg"] = {
                C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
            },
            ["Right Leg"] = {
                C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
            }
        }


        for jointName, joint in pairs(Joints) do
            if joint then
                joint.C0 = OriginalCFrames[jointName].C0
                joint.C1 = OriginalCFrames[jointName].C1
            end
        end


        local Animator = Instance.new('Animator', plr.Character.Humanoid)
        wait(0.05)
        plr.Character.Animate.Enabled = true
        wait(0.01)
        plr.Character.Humanoid.AutomaticScalingEnabled = false
        plr.Character.Animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=180435571"
        plr.Character.Animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=180435571"
        plr.Character.Animate.walk:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180426354"
        plr.Character.Animate.run:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180426354"
        plr.Character.Animate.jump:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=125750702"
        plr.Character.Animate.fall:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180436148"
    end)

    Reanimate:CreateButton("Stop Animation", function(StopAnimationR6)
        if not R6reanimated then 
            Message("Error:", "Please Reanimate", 5)
            return 
        end
        if not AnimationActive then 
            Message("Error:", "No Animation Playing", 5)
            return 
        end

        AnimationActive = false
        StopAnim = true

            plr.Character.Humanoid.Sit = false

        if connection then
            connection:Disconnect()
            connection = nil
        end

        game.Workspace.Gravity = 196.2
        local cf = CFrame.new
        local Joints = {
            ["Torso"] = plr.Character.HumanoidRootPart["RootJoint"],
            ["Right Arm"] = plr.Character.Torso["Right Shoulder"],
            ["Left Arm"] = plr.Character.Torso["Left Shoulder"],
            ["Head"] = plr.Character.Torso["Neck"],
            ["Left Leg"] = plr.Character.Torso["Left Hip"],
            ["Right Leg"] = plr.Character.Torso["Right Hip"]
        }


        local OriginalCFrames = {
            ["Torso"] = {
                C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
            },
            ["Right Arm"] = {
                C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
            },
            ["Left Arm"] = {
                C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
            },
            ["Head"] = {
                C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
            },
            ["Left Leg"] = {
                C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
            },
            ["Right Leg"] = {
                C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
            }
        }


        for jointName, joint in pairs(Joints) do
            if joint then
                joint.C0 = OriginalCFrames[jointName].C0
                joint.C1 = OriginalCFrames[jointName].C1
            end
        end


        local Animator = Instance.new('Animator', plr.Character.Humanoid)
        wait(0.05)
        plr.Character.Animate.Enabled = true
        wait(0.01)
        plr.Character.Humanoid.AutomaticScalingEnabled = false
        plr.Character.Animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=180435571"
        plr.Character.Animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=180435571"
        plr.Character.Animate.walk:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180426354"
        plr.Character.Animate.run:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180426354"
        plr.Character.Animate.jump:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=125750702"
        plr.Character.Animate.fall:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180436148"
    end)


    local BuiltInAnimationsR6 = {

    ["bouncin"] = 18986228959,
    ["Rodeo"] = 9292118892,
    ["Slide"] = 119492771813670,
    ["PPG TIME"] = 10049457548,
    ["miss the rage"] = 111328470438058,
    ["dizzy animation"] = 180435792,
    ["Newtron Boogie"] = 111093010610650,
    ["Riding It"] = 8038132892,
    ["pogo"] = 8829798048,
    ["Get Sturdy"] = 12126389709,
    ["Box Swing"] = 140473666560735,
    ["sit"] = 4842017973,
    ["Legal Reasons (PewDiePie T Series Disstrack)"] = 16513267930,
    ["Billie Jean"] = 12764845252,
    ["walk and explode"] = 18517277884,
    ["Tootsee Roll"] = 12986187501,
    ["stock shuffle 2"] = 15039780593,
    ["Gangnam Style"] = 16883073608,
    ["Up Town Funk You Up"] = 10565486365,
    ["Caramelldansen"] = 110926505486019,
    ["tootsie roll"] = 12986187501,
    ["peanut butter jelly time"] = 8523791283,
    ["Kazotsky Kick"] = 101318053989317,
    ["Friday Night"] = 8723336030,
    ["bomb monkey"] = 5159955624,
    ["Explode"] = 18517277884,
    ["ah yes"] = 3383725246,
    ["rodeo lil nas x"] = 9292118892,
    ["Toprocking"] = 12986187501,
    ["peanutbutter jelly time"] = 10049457548,
    ["Groovy"] = 8208076144,
    ["Drip"] = 9836086127,
    ["Pop And Lock (TikTok Kesha)"] = 8083855559,
    ["fighter"] = 12126990018,
    ["Criss Cross Toprock"] = 15767639861,
    ["Holiday"] = 119715551234716,
    ["Reflex"] = 8580057295,
    ["Funky Jig"] = 10909214966,
    ["The Flop"] = 16513281388,
    ["Blinding Lights"] = 16615772082,
    ["Sit"] = 4842017973,
    ["Thriller"] = 4699820365,
    ["Dr. Livesey Walk"] = 71071097427597,
    ["im a mystery (fortnite emote)"] = 18945301513,
    ["insanity"] = 8575452869,
    ["Insanity"] = 8575452869,
    ["Hot Springs"] = 72570494324774,
    ["Keep Up"] = 120610031993046,
    ["Breakdance2005"] = 13806018931,
    ["boppin"] = 13579968035,
    ["Fly Dance (Rather Be)"] = 9730153158,
    ["metro boomin ric flair drip"] = 9836086127,
    
    ["H Cups"] = 14137491337,
    ["Women"] = 14607199830,
    ["Kaboom"] = 15847746754,
    ["Chipi Chipi Chapa Chapa"] = 15946752017,
    ["Rock Sus"] = 16266176150,
    ["Friend Came To House"] = 16544294550,
    ["All My Fellas"] = 15426897470,
    ["Crispy Fries"] = 16712782727,
    ["Bee"] = 16946409774,
    ["Clap Your Hands"] = 17337061768,
    ["hikanokonokonokokoshitantan"] = 17665944655,
    ["Momoi Blue Archieve"] = 17775539327,
    ["Wai Wei Wai Wei"] = 17775681478,
    ["English Or Spanish"] = 18235995346,
    ["Shake My Hand"] = 18722163055,
    ["How To Upper Cut"] = 123206429618710,
    ["Shiroko Mini"] = 78581685127990,
    ["Chocolate Strawberry Meme"] = 74081820207254,
    ["Rate Avatar"] = 72973235517229,
    ["Spinning Cat O I I A O I I A"] = 102131088545916,
    ["Ive Played These Games Before Squid Game"] = 88509345228983,
    ["Ill Give You Ten Dollar"] = 126351756230277,
    ["Rat Dance"] = 124632045260787,
    ["My Little Baby Boy"] = 78285256380463,
    ["Womenji911 Meme"] = 122599140049339,
    
    ["Stock Shuffle"] = 8875904299,
    ["Bling-Bang-Born"] = 16361564081,
    ["To the Beat"] = 133424881252105,
    ["Kazotsky Kick"] = 9158896160,
    ["Caramelldansen"] = 13499921607,
    ["Kemusan"] = 124210157097622,
    ["Slay Jump"] = 127993598199806,
    ["Spamton"] = 15093185505,
    ["Nuclear Bird"] = 14125486837,
    ["Hakari"] = 16143414597,
    ["Feel It"] = 94845993692069,
    ["Carlton"] = 8772535190,
    ["Razzle Dazzle"] = 98543006822769,
    ["Let Me In"] = 131658043622270,
    ["Rat Dance"] = 95554773857507,
    ["Peashooter"] = 15039779727,
    ["Ronald Insanity"] = 110124478952785,
    ["Beggin'"] = 8915458946,
    ["Club Ibuki"] = 14125474952,
    ["Sturdy"] = 14721291184,
    ["Takino"] = 16361576857,
    ["Pikuniku"] = 18985649800,
    ["Egypt"] = 100136360352723,
    ["Palm Tree Panic"] = 15115509387,
    ["Already Dead"] = 12474374184,
    ["Internet Yamero"] = 137765549462705,
    ["Jamspace"] = 14321704772,
    ["Rakuten"] = 18985726113,
    ["Smile"] = 105422344378204,
    ["Miku"] = 116375125220834,
    ["Penguin"] = 16362073134,
    ["Oktober Aid"] = 18985529359,
    ["Messy Hairstyle"] = 13542472660,
    ["Miss the Quiet"] = 126880865139406,
    ["Laugh"] = 13845017130,
    ["MishMash_Intro"] = 35654637,
    ["MishMash"] = 33796059,
    ["Friday Night"] = 12852328987,
    ["Peanut Butter"] = 10049457548,
    ["Conga"] = 18985751348,
    ["Pokedance"] = 18986687692,
    ["Boo'd Up Groove"] = 103736630097329,
    ["Boppin"] = 13579968035,
    ["Livesey Walk"] = 12581348761,
    ["Demo Kick"] = 132711053760986,
    ["Spooky Month"] = 15231364673,
    ["Dreamland"] = 14125434919,
    ["Window Glass"] = 106836244406405,
    ["Moongazer"] = 118766274919427,
    ["Anthony Shuffle"] = 7584192714,
    ["Skibidi"] = 15200323140,
    ["Teto Territory"] = 13703701856,
    ["Sherbert"] = 15509944325,
    ["Jevil"] = 8550316999,
    ["Lagtrain"] = 131559207454945,
    ["Doodle"] = 137721173051346,
    ["Stock Shuffle 2"] = 15039780593,
    ["Mio Honda"] = 97072681531610,
    ["Shuba Duck"] = 13357063395,
    ["Awooo"] = 13447037105,
    ["Lucid Dreams"] = 132200906002694,
    ["Internet Angel"] = 18986591475,
    ["Sisyphus"] = 13388916095,
    ["God of Romance"] = 13894522815,
    ["Prime"] = 13379720851,
    ["Chainsaw Dance"] = 14536793751,
    ["Nokotan"] = 96474371768104,
    ["Mannrobics"] = 8755445499,
    ["I'm a Mystery"] = 131401099812672,
    ["Smug Dance"] = 12331326670,
    ["Sweet Little Bumblebee"] = 10048786578,
    ["Hardstyle Shuffle"] = 14620787228,
    ["Parker"] = 18986200915,
    ["Monoko"] = 139889845987864,
    ["Pockets"] = 135126535467732,
    ["Mesmerizer"] = 107578737342278,
    ["Caramelldansen 2"] = 14281766612,
    ["Rabbit Platoon"] = 86947150862846,
    ["Not Responsible"] = 16729354942,
    ["Demon Swing"] = 8004387067,
    ["Unlock It"] = 121255731270377,
    ["Fly Away"] = 131084375511969,
    ["Mailbox"] = 12843537499,
    ["Rodeo"] = 15049488553,
    ["Heavy Kick"] = 93556320340117,
    ["Chirumiru"] = 12698847826,
    ["Burnice"] = 111366982175574,
    ["Direction Directive"] = 14037662848,
    ["Monster Mash"] = 14684864488,
    ["Funky"] = 13376581054,
    ["Thought I Was Dead"] = 75462948983147,
    ["Just Wanna Rock"] = 92110306103230,
    ["Chronoshift"] = 125834337223799,
    ["Po Pi Po"] = 13305408503,
    ["No Cure"] = 70636200474507,
    ["Stay Afloat"] = 101831164587635,
    ["Shigure Ui"] = 14887006269,
    ["Idol"] = 13272181711,
    ["Luxurious"] = 14487794376,
    ["Lethal"] = 15605418190,
    ["Yippee"] = 91260130273371,
    ["Bye Bye Bye"] = 102033341518359,
    ["Ready for Me"] = 14630791982,
    ["They Don't Know"] = 10194781333,
    ["Sniper Kick"] = 107389075592075,
    ["Billie Jean"] = 134166870573340,
    ["Falling Down"] = 111249002064299,
    ["Goopie"] = 7828640127,
    ["Gang Dance"] = 121267065315946,
    ["Outlaw"] = 117632426193831,
    ["Slickback"] = 18986357892,
    ["Addendum"] = 9191168242,
    ["Lanewyre"] = 10687500605,
    ["Patrick"] = 13230998921,
    ["Engineer"] = 8328359953,
    ["Engineer Kick"] = 122808745953182,
    ["Griddy"] = 13524047720,
    ["Medic Kick"] = 15271802495,
    ["Too Much Brain"] = 86485871533985,
    ["Hypnodancer"] = 97699704852712,
    ["Sponge"] = 13843669201,
    ["Hustle"] = 8678603200,
    ["Ketchup"] = 130070981484912,
    ["Hypnotic Data"] = 70376423342136,
    ["Exum Shuffle"] = 95530034966573,
    ["Check"] = 92069955401837,
    ["Thriller"] = 11434028691,
    ["Dance of Nights"] = 13456829762,
    ["Club Penguin"] = 8772459775,
    ["I Show Speed "] = 10353115061,
    ["God Is Good"] = 17639181311,
    
    ["Outlaw"] = 79048566727283,
    ["Party House"] = 113030438875320,
    ["New Donk"] = 111542909088526,
    ["Oddloop"] = 95650849617284,
    ["Kalyx"] = 137738597810830,
    ["Chase Me"] = 118311613925473,
    ["Jive"] = 133324659811186,
    ["Groovy"] = 88997109090699,
    ["Boomin'"] = 135207682507735,
    ["Over Drive"] = 118789281098407,
    ["Gangnam Style"] = 109451974680631,
    ["Shadow Dash"] = 126495344868322,
    ["expldoe"] = 113901618647384,
    ["BHop"] = 82234401429055,
    ["Frozen Pizza"] = 78457500452351,
    ["Entranced"] = 131726076631029,
    ["Boogie Bomb"] = 114817849347144,
    ["Click (Fortnite)"] = 76174442523796,
    ["Heel-Toe Hop"] = 98256622649150,
    ["Crack Down"] = 133188222109902,
    ["Break Dance 2005"] = 131296257768627,
    ["Soar Above"] = 92031051557681,
    ["Club Penguin"] = 89761302048916,
    ["Colossal"] = 93170660505618,
    ["Get To The Top!"] = 93228901518812,
    ["Funky Jig"] = 104720694407943,
    ["Pop & Lock"] = 113869158054586,
    ["Friday Night"] = 91741353599946,
    ["Kombonk"] = 88519824673842,
    ["Little Big"] = 78546390232203,
    ["Million"] = 109123683211464,
    ["Walk Of Pride"] = 137503210275698,
    ["Love Hate"] = 118446506171691,
    ["Running In Terror"] = 82063943309833,
    ["Jung Justice"] = 71723925114737,
    ["Oktober Aid"] = 127865309658292,
    ["Caramelldansen"] = 103597509139287,
    ["Squash & Stretch"] = 82430103452187,
    ["Goat Simulator"] = 129327004786530,
    ["Krab Borg"] = 84670621089927,
    ["Attitude"] = 129169655004423,
    ["Professional"] = 117672863086140,
    ["Hakari"] = 92699725136780,
    ["PoPiPo 2"] = 85390639051709,
    ["Chicken Dinner"] = 100643285137768,
    ["Dip (Fortnite)"] = 98242814708356,
    ["Stock Shuffle"] = 86067433847393,
    ["Han Solo"] = 84236497616039,
    ["Pop Lock (Fortnite)"] = 83789802032942,
    ["Carbohydrate Craving"] = 77887053847258,
    ["Lo-Fi Headbang"] = 84024656726416,
    ["Spring Loaded"] = 126001082682364,
    ["Prince of Egypt"] = 95986135548450,
    ["Hip Hop Hero"] = 129871001094710,
    ["Jumping Jacks"] = 86279418149917,
    ["The Roll"] = 70422527184550,
    ["Side Shuffle"] = 106696831887022,
    ["Addendum"] = 77926650795117,
    ["Rat Dance"] = 98260902889120,
    ["Poison"] = 99443468328797,
    ["Nerdy"] = 136250600208499,
    ["Star Striker"] = 126271443897103,
    ["Deep Fried Desire"] = 127846780529069,
    ["Thriller"] = 101170440834154,
    ["Bomb Monkey"] = 75616586799217,
    ["Bill"] = 120460931637912,
    ["Kazotsky Kick"] = 114036336168567,
    ["Downtown Funk"] = 103059790868580,
    ["Continental Drift"] = 105174222033892,
    ["Boogie Down (Fortnite)"] = 77558722177080,
    ["Fighter Stance"] = 118865990558686,
    ["Keep Up"] = 84765927391240,
    ["Rewind"] = 85595451831140,
    ["Garry's Dance 2"] = 139864071438673,
    ["Goat Simulator 2"] = 108846628611129,
    ["Drip"] = 100177280567649,
    ["Unlock It 2"] = 106623826710195,
    ["Mischiev. Function 2"] = 99703499782716,
    ["Billie Jean"] = 108805310510119,
    ["Scenario 2"] = 120912789271542,
    ["Unlock It"] = 95877864781663,
    ["Victory Sway"] = 118331988473361,
    ["Reflex"] = 104246452023047,
    ["Pick It Up"] = 106248669913767,
    ["Wednesday"] = 93029240528390,
    ["Check"] = 132280062505986,
    ["Well Rounded"] = 93832203745642,
    ["Floss"] = 107287295776925,
    ["Direction Directive"] = 100131309856257,
    ["Free Flow (Fortnite)"] = 79857999132283,
    ["Work It"] = 140046429691095,
    ["XO"] = 73559770055600,
    ["Calamity"] = 102026644002108,
    ["Conga"] = 115557579308566,
    ["ZomBeat"] = 130481163326164,
    ["Jay Walking"] = 107833895457998,
    ["Heli"] = 83247044041020,
    ["It's Complicated"] = 78717948152747,
    ["Mirage"] = 108895956412207,
    ["Garry's Dance"] = 102655274160157,
    ["New Jack Swingin'"] = 113494131456426,
    ["Texan Hoedown"] = 130942516783083,
    ["The Flop"] = 122878040721056,
    ["Break Dance"] = 132886479585903,
    ["Turnt Up"] = 95604282742916,
    ["Heel-Toe Toprock"] = 140670228658366,
    ["The M.D"] = 103541609182057,  
    ["Too Much Brain"] = 71228444263749,
    ["Tootsee Roll"] = 102931874666964,
    ["Miku"] = 82171050414030,
    ["Get Sturdy"] = 77773358394206,
    ["Hot Springs"] = 134527716461262,
    ["True Heart (Fortnite)"] = 139400505188520,
    ["Tai Chi v2 (Fortnite)"] = 139334740822475,
    ["Survivalist"] = 74820723472974,
    ["Springy"] = 96915228320599,
    ["Blinding Lights"] = 83245497290837,
    ["Spring Loaded"] = 116924278421652,
    ["Sponge Bob"] = 107928348961439,
    ["Magnetic"] = 91594002186875,
    ["Sonic Dash"] = 129700726680674,
    ["Electro Swing (Fortnite)"] = 93684150668786,
    ["Slow Down"] = 96225967263351,
    ["Breakin (Fortnite)"] = 131155721688011,
    ["Smooth Slide"] = 95051030054364,
    ["FEiN"] = 115727639577589,
    ["Slick"] = 112642355788128,
    ["Sit"] = 77436653907705,
    ["Criss Cross Toprock"] = 73116243097694,
    ["Box Swing"] = 75405139558088,
    ["Sidestep"] = 118256299900662,
    ["Rain Check"] = 104145748528942,
    ["Sicko Mode"] = 82639898531456,
    ["Scenario"] = 105424478944256,
    ["Infectious"] = 103230323718650,
    ["Moon Gazer"] = 94182828225901,
    ["Flapper (Fortnite)"] = 123373225244443,
    ["Club Penguin 2"] = 116538780276427,
    ["Fly Dance"] = 125627676172807,
    ["Ric Flair"] = 77103786363593,
    ["I'm A Mystery"] = 100523776393294,
    ["Rodeo"] = 139177767291866,
    ["Double Step"] = 138112012258643,
    ["Riding It"] = 110739557877639,
    ["Reject Step"] = 79440368381920,
    ["Smile"] = 102498054330233,
    ["Reanimated"] = 135638372997121,
    ["Electro Shuffle (Fortnite)"] = 136684924748195,
    ["Boogie"] = 125356421399032,
    ["Rage"] = 97891561277088,
    ["Crank That"] = 139148388599834,
    ["PoPiPo Extended"] = 115465103089127,
    ["Pogo"] = 109001339891602,
    ["Old School"] = 115558885277292,
    ["PoPiPo"] = 78991327797272,
    ["Drum Major"] = 116369780386936,
    ["Dragon's Dance"] = 75687257387850,
    ["Hip Shop"] = 103112841595182,
    ["Billy Bounce"] = 125962207089467,
    ["Cyber Bop"] = 129655276640546,
    ["Bullet Dodge Ballet"] = 98779400840597,
    ["Fright Funk"] = 70835462045983,
    ["Company Jig"] = 116614992219971,
    ["Flamenco (Fortnite)"] = 112606613683393,
    ["Top Rocking"] = 116248187570378,
    ["Lagtrain"] = 80764093560475,
    ["Mischiev. Function"] = 100305033962391,
    ["Bit Crushing"] = 135845625327739,
    ["Domino"] = 126683576461381,
    ["Black & Yellow"] = 132028118802766,
    ["Dragon of Dojima"] = 113052694384739,
    ["Royal Angst"] = 101917046845862,
    ["Neo"] = 107258078364252,
    ["Let's Groove"] = 109923692577857,
    ["Peanut Butter"] = 85717017003584,
    ["Legal Reasons"] = 78083829137149,
    ["Dynamic Shuffle"] = 78337295886429,
    ["PONPON"] = 109617660580282,
    ["ah yes"] = 121084882913556,
    ["Flippin Incredible (Fortnite)"] = 119560486682969,
    ["Jump Style"] = 115620519702324,
    ["Insanity"] = 139483347792972,
    ["Holiday"] = 85998810156809,
    ["Doodle"] = 90069083924245,
    ["Break Down"] = 100568904650591,
    ["Max Effort"] = 108526381474779,
    ["Free Stylin'"] = 125617918498526,
    ["Doom Mc Bringer"] = 123386245117713,
    
    }

    local BuiltInAnimationValuesR6 = {}
    for name, value in pairs(BuiltInAnimationsR6) do
        BuiltInAnimationValuesR6[value] = name
    end

    Reanimate:CreateSlider("Animation Speed Adjuster", 0, 100, 50, function(R67Changer)
        R67 = R67Changer / 50  
    end)

    Reanimate:CreateDropdown("Built In Animations", BuiltInAnimationValuesR6, function(BuiltInAnimationSR6elected)
        if not R6reanimated then
            Message("R6 Reanimate Status:", "False!", 5)
            return
        end

        local AnimationValue = BuiltInAnimationsR6[BuiltInAnimationSR6elected]
        AnimationActive = false
        StopAnim = true

        if connection then
            connection:Disconnect()
            connection = nil
        end

        local Joints = {
            ["Torso"] = plr.Character.HumanoidRootPart["RootJoint"],
            ["Right Arm"] = plr.Character.Torso["Right Shoulder"],
            ["Left Arm"] = plr.Character.Torso["Left Shoulder"],
            ["Head"] = plr.Character.Torso["Neck"],
            ["Left Leg"] = plr.Character.Torso["Left Hip"],
            ["Right Leg"] = plr.Character.Torso["Right Hip"]
        }
        local cf = CFrame.new
        local OriginalCFrames = {
            ["Torso"] = { C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
            ["Right Arm"] = { C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0), C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0) },
            ["Left Arm"] = { C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
            ["Head"] = { C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
            ["Left Leg"] = { C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
            ["Right Leg"] = { C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0), C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0) }
        }

        for jointName, joint in pairs(Joints) do
            if joint then
                joint.C0 = OriginalCFrames[jointName].C0
                joint.C1 = OriginalCFrames[jointName].C1
            end
        end

        local humanoid = plr.Character:FindFirstChild("Humanoid")
        if humanoid then
            local animator = humanoid:FindFirstChild("Animator")
            if animator then animator:Destroy() end
        end

        local animate = plr.Character:FindFirstChild("Animate")
        if animate then animate.Enabled = false end

        plr.Character.Humanoid.AutomaticScalingEnabled = false
        plr.Character.Animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=180435571"
        plr.Character.Animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=180435571"
        plr.Character.Animate.walk:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180426354"
        plr.Character.Animate.run:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180426354"
        plr.Character.Animate.jump:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=125750702"
        plr.Character.Animate.fall:FindFirstChildOfClass("Animation").AnimationId = "http://www.roblox.com/asset/?id=180436148"

        if not AnimationValue then
            Message("Error:", "No ID.", 3)
            return
        end

        if not isValidAnimationID(AnimationValue) then
            Message("Error:", "Animation Was Deleted!", 5)
            return
        end

        StopAnim = true
        AnimationActive = false
        wait(0.085)

        if plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid:FindFirstChild("Animator") then
            plr.Character.Humanoid.Animator:Destroy()
        end
        if plr.Character:FindFirstChild("Animate") then
            plr.Character.Animate.Enabled = false
        end

        local NeededAssets = game:GetObjects("rbxassetid://" .. AnimationValue)[1]
        local keyframes = NeededAssets:GetKeyframes()
        table.sort(keyframes, function(a, b) return a.Time < b.Time end)

        local totalAnimTime = keyframes[#keyframes].Time
        local elapsedTime = 0
        local lastTime = os.clock()
        R67 = R67 or 1

        AnimationActive = true
        StopAnim = false

        coroutine.wrap(function()
            while AnimationActive do
                if StopAnim then
                    AnimationActive = false
                    break
                end

                local now = os.clock()
                local deltaTime = now - lastTime
                lastTime = now

                local speed = math.clamp(R67, 0.01, 10)
                if speed == 0 then
                    task.wait()
                    continue
                end

                elapsedTime += deltaTime * speed
                if elapsedTime > totalAnimTime then
                    elapsedTime = 0
                end

                local currentKeyframe, nextKeyframe
                for i = 1, #keyframes - 1 do
                    if elapsedTime >= keyframes[i].Time and elapsedTime <= keyframes[i + 1].Time then
                        currentKeyframe = keyframes[i]
                        nextKeyframe = keyframes[i + 1]
                        break
                    end
                end

                if currentKeyframe and nextKeyframe then
                    local t0, t1 = currentKeyframe.Time, nextKeyframe.Time
                    local duration = t1 - t0
                    local alpha = duration > 0 and math.clamp((elapsedTime - t0) / duration, 0, 1) or 1

                    local cfStart = {}
                    local cfEnd = {}

                    for _, desc in pairs(currentKeyframe:GetDescendants()) do
                        if Joints[desc.Name] then
                            cfStart[desc.Name] = desc.CFrame
                        end
                    end
                    for _, desc in pairs(nextKeyframe:GetDescendants()) do
                        if Joints[desc.Name] then
                            cfEnd[desc.Name] = desc.CFrame
                        end
                    end

                    for jointName, joint in pairs(Joints) do
                        local cf1 = cfStart[jointName]
                        local cf2 = cfEnd[jointName]
                        if cf1 and cf2 then
                            joint.Transform = cf1:Lerp(cf2, alpha)
                        elseif cf1 then
                            joint.Transform = cf1
                        end
                    end
                end

                task.wait()
            end
            AnimationActive = false
            StopAnim = true
        end)()
    end)


    Reanimate:CreateDropdown("HaxterFelix Animations", HaxterFelix, function(selectedHax)
        mode = selectedHax

        if not R6reanimated then 
            Message("Error:", "Please Reanimate", 5)
            return 
        end


        AnimationActive = false
        StopAnim = true

        if connection then
            connection:Disconnect()
            connection = nil
        end


        local character = plr.Character or plr.CharacterAdded:Wait()
        local humanoid = character:FindFirstChild("Humanoid")
        local animate = character:FindFirstChild("Animate")

        if humanoid then
            local animator = humanoid:FindFirstChild("Animator")
            if animator then animator:Destroy() end
            humanoid.AutomaticScalingEnabled = false
        end

        if animate then
            animate.Enabled = false
        end


        local joints = {
            ["Torso"] = character.HumanoidRootPart:FindFirstChild("RootJoint"),
            ["Right Arm"] = character.Torso:FindFirstChild("Right Shoulder"),
            ["Left Arm"] = character.Torso:FindFirstChild("Left Shoulder"),
            ["Head"] = character.Torso:FindFirstChild("Neck"),
            ["Left Leg"] = character.Torso:FindFirstChild("Left Hip"),
            ["Right Leg"] = character.Torso:FindFirstChild("Right Hip")
        }

        local cf = CFrame.new
        local originalCFrames = {
            ["Torso"] = { C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
            ["Right Arm"] = { C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0), C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0) },
            ["Left Arm"] = { C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
            ["Head"] = { C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
            ["Left Leg"] = { C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
            ["Right Leg"] = { C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0), C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0) }
        }

        for jointName, joint in pairs(joints) do
            if joint then
                joint.C0 = originalCFrames[jointName].C0
                joint.C1 = originalCFrames[jointName].C1
                joint.Transform = CFrame.new() 
            end
        end


        local newAnimator = Instance.new("Animator")
        newAnimator.Parent = humanoid
        wait(0.05)
        StopAnim = false
        AnimationActive = true
        if animate then
            animate.Enabled = true
            local defaultAnimId = "http://www.roblox.com/asset/?id=180435571"
            animate.idle.Animation1.AnimationId = defaultAnimId
            animate.idle.Animation2.AnimationId = defaultAnimId
            animate.walk:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.run:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.jump:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.fall:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
        end
            wait(0.1)

            local character = plr.Character or plr.CharacterAdded:Wait()
            local humanoid = character:WaitForChild("Humanoid")
            local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
            local RootJoint = HumanoidRootPart["RootJoint"]
            local RightShoulder = character.Torso["Right Shoulder"]
            local LeftShoulder = character.Torso["Left Shoulder"]
            local Neck = character.Torso["Neck"]
            local LeftHip = character.Torso["Left Hip"]
            local RightHip = character.Torso["Right Hip"]

        if plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid:FindFirstChild("Animator") then
            plr.Character.Humanoid.Animator:Destroy()
        end
        if plr.Character:FindFirstChild("Animate") then
            plr.Character.Animate.Enabled = false
        end
            local animate = plr.Character:FindFirstChild("Animate")
        if animate then animate.Enabled = false end
                if connection then 
                    connection:Disconnect()  
                end
            
            
                local runService = game:GetService("RunService")
                local sine = 0
            
                connection = runService.RenderStepped:Connect(function(deltaTime)
                    sine += deltaTime * R67 / 1
                    deltaTime = clamp(deltaTime * 10, 0, 1)
                
                    local vel = HumanoidRootPart.Velocity
                    local onGround = humanoid:GetState() == Enum.HumanoidStateType.Freefall
            local humanoidRootPartVelocity  = character:FindFirstChild("HumanoidRootPart").Velocity 
                
                
                if vel.Magnitude < 1 then 
                    if mode == "Unknown" then
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.6,0.3-0.1*sin((sine+2)*2.5),-0.2),angles(-0.8726646259971648,-0.3490658503988659,-0.3490658503988659)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0.08726646259971647*sin((sine+2)*2.5),3.490658503988659)),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.2,-0.9+0.1*sin((sine+1.3)*2.5),0),angles(-0.8726646259971648+0.17453292519943295*sin((sine+2)*-2),-1.3089969389957472,-0.22689280275926285)),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.3-0.1*sin((sine+2)*2.5),-0.5),angles(0.17453292519943295*sin((sine+0.5)*2.5),-0.17453292519943295,-0.5235987755982988)),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,4-1*sin(sine*2),0),angles(-2.007128639793479+0.05235987755982989*sin((sine+0.5)*2.5),-0.17453292519943295+0.05235987755982989*sin((sine+0.5)*2.5),2.792526803190927)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.1,-0.8+0.1*sin((sine+1)*2.5),-0.5),angles(-0.6981317007977318+0.17453292519943295*sin((sine+2)*2),1.3089969389957472,0.2617993877991494)),deltaTime) 

                elseif mode == "Back Handstand" then 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,-0.6981317007977318,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.65+0.03*sin(sine*3),0),angles(-0.22689280275926285+0.017453292519943295*sin(sine*3),-15.707963267948966,3.141592653589793)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,1.0471975511965976,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,1.2217304763960306,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,-1.2217304763960306,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-0.5235987755982988,0.17453292519943295*sin(sine*1),3.141592653589793+0.5235987755982988*sin(sine*1))),deltaTime) 
                elseif mode == "Chest Lay" then
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1.5,0.7+0.04*sin(sine*1)),angles(0.8726646259971648-0.08726646259971647*sin(sine*2),0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1.3,1.2),angles(-2.897246558310587,-2.0943951023931953,-0.5235987755982988+0.06981317007977318*sin(sine*2))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.9+0.08*sin(sine*1.2),0),angles(2.4085543677521746+0.03490658503988659*sin(sine*2),0,3.141592653589793)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.6,0.8,0.5),angles(3.839724354387525,0.10471975511965978*sin(sine*1.5),0.5235987755982988+0.03490658503988659*sin(sine*1.5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1.2,0.8),angles(-2.705260340591211,1.7453292519943295,0.8726646259971648-0.06981317007977318*sin(sine*2))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.6,0.8,0.5),angles(3.839724354387525,-0.10471975511965978*sin(sine*1.5),-0.5235987755982988+0.03490658503988659*sin(sine*1.5))),deltaTime) 

                elseif mode == "Corruption" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.6,0,0.3), angles(-0.17453292519943295 + 0.08726646259971647 * sin((sine + 2) * 7), 0.4363323129985824 - 0.08726646259971647 * sin((sine + 2) * 7), -0.5235987755982988)), deltaTime)
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5, -1 - 0.1 * sin(sine * 1), 0.5), angles(-0.08726646259971647 + 0.08726646259971647 * sin((sine + 1) * 7), -0.08726646259971647, 0.05235987755982989)), deltaTime)
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5, -1 - 0.1 * sin(sine * 7), 0.5), angles(0.17453292519943295 + 0.08726646259971647 * sin((sine + 1) * 7), 0.08726646259971647, -0.05235987755982989)), deltaTime)
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0, 1, 0), angles(-1.6580627893946132 + 0.12217304763960307 * sin(sine * 7), 0, 3.141592653589793)), deltaTime)
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.7, 0, 0.3), angles(-0.17453292519943295 + 0.08726646259971647 * sin((sine + 2) * 7), -0.4363323129985824 + 0.08726646259971647 * sin((sine + 2) * 7), 0.5235987755982988)), deltaTime)
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0, 0.1 * sin(sine * 7), -0.1 * sin((sine + 1) * 7)), angles(-1.5707963267948966 - 0.08726646259971647 * sin((sine + 1) * 7), 0, 3.141592653589793)), deltaTime)
                elseif mode == "Sit Jerk" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,-0.7),angles(1.2217304763960306+0.2617993877991494*sin(sine*5),0,-0.8726646259971648)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.08726646259971647*sin((sine+1)*1),0,3.141592653589793+0.08726646259971647*sin(sine*0.5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1.5,0),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),0,0.3490658503988659)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,-0.2,0.4),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),-2.0943951023931953-0.08726646259971647*sin(sine*1),2.0943951023931953-0.08726646259971647*sin(sine*1))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.5+0.05*sin(sine*1),0.1 * sin(sine*1)),angles(-1.5707963267948966+0.08726646259971647*sin(sine*1),0,3.141592653589793+0.08726646259971647*sin(sine*0.5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1.5,0),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),0.17453292519943295,-0.3490658503988659)),deltaTime) 

                elseif mode == "Jerking Off" then 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.4,-1),angles(0.6981317007977318+0.2617993877991494*sin(sine*15),0,-0.8726646259971648)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0,1.5707963267948966,0)),deltaTime) 

                elseif mode == "Invisible" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,1000,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                end

            elseif vel.Y > 1 then 
                    if mode == "Unknown" then 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.1,-0.8+0.1*sin((sine+1)*2.5),-0.5),angles(-0.6981317007977318+0.17453292519943295*sin((sine+2)*2),1.3089969389957472,0.2617993877991494)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,-0.2),angles(-0.6981317007977318,0.08726646259971647*sin((sine+2)*2.5),3.490658503988659)),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,3-0.4*sin(sine*2),0),angles(-2.6179938779914944+0.05235987755982989*sin((sine+0.5)*2.5),-0.17453292519943295+0.05235987755982989*sin((sine+0.5)*2.5),2.792526803190927)),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.2,-0.9+0.1*sin((sine+1.3)*2.5),0),angles(-0.8726646259971648+0.17453292519943295*sin((sine+2)*-2),-1.3089969389957472,-0.22689280275926285)),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1-0.1*sin((sine+2)*2.5),-0.2),angles(2.0943951023931953+0.17453292519943295*sin((sine+0.5)*2.5),-0.17453292519943295,-0.5235987755982988)),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.6,0.3-0.1*sin((sine+2)*2.5),-0.2),angles(-0.8726646259971648,-0.3490658503988659,-0.3490658503988659)),deltaTime) 

        elseif mode == "Back Handstand" then 
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,-0.6981317007977318,0.05235987755982989*sin(sine*0.4))),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.65+0.03*sin(sine*3),0),angles(-0.22689280275926285+0.017453292519943295*sin(sine*3),-15.707963267948966,3.141592653589793)),deltaTime) 
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,1.0471975511965976,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,1.2217304763960306,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,-1.2217304763960306,0.05235987755982989*sin(sine*0.4))),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-0.5235987755982988,0.17453292519943295*sin(sine*1),3.141592653589793+0.5235987755982988*sin(sine*1))),deltaTime) 
        elseif mode == "Chest Lay" then
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1.3,1.2),angles(-2.897246558310587+0.2617993877991494*sin(sine*-6),-2.0943951023931953+0.13962634015954636*sin(sine*5),-0.5235987755982988+0.06981317007977318*sin(sine*2))),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1.5,0.7+0.1*sin(sine*4)),angles(0.8726646259971648+0.10471975511965978*sin(sine*5),0.06981317007977318*sin(sine*4),3.141592653589793-0.12217304763960307*sin(sine*-5))),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1.2,0.8),angles(-2.705260340591211+0.2617993877991494*sin(sine*-6),1.7453292519943295+0.13962634015954636*sin(sine*5),0.8726646259971648+0.15707963267948966*sin(sine*2))),deltaTime) 
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1,0.9),angles(2.9670597283903604+1.0471975511965976*sin(sine*6),-0.08726646259971647*sin(sine*2.5),0.17453292519943295)),deltaTime) 
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,1,0.9),angles(2.9670597283903604+0.6981317007977318*sin(sine*-6),-0.10471975511965978*sin(sine*-2.5),-0.17453292519943295)),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.6+0.1*sin(sine*1.2),0),angles(2.4085543677521746+0.10471975511965978*sin(sine*5),0.05235987755982989*sin(sine*1),3.141592653589793)),deltaTime) 

        elseif mode == "Corruption" then
        
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0.17453292519943295-0.3490658503988659*sin(sine*5),1.5707963267948966,0)),deltaTime) 
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(-0.3490658503988659*sin(sine*5),0,0.17453292519943295)),deltaTime) 
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(0.5235987755982988*sin(sine*5),0,-0.17453292519943295)),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.07 * sin(sine*5),0),angles(-1.7453292519943295+0.03490658503988659*sin(sine*3),0.0017453292519943296*sin((sine+2)*3),3.141592653589793+0.03490658503988659*sin(sine*3))),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0.17453292519943295+0.3490658503988659*sin(sine*5),-1.5707963267948966,0)),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295+0.010471975511965976*sin(sine*5),0.03490658503988659*sin((sine+2)*4),3.141592653589793+0.06981317007977318*sin(sine*3))),deltaTime) 

        elseif mode == "Sit Jerk" then
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,-0.7),angles(1.2217304763960306+0.2617993877991494*sin(sine*5),0,-0.8726646259971648)),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.08726646259971647*sin((sine+1)*1),0,3.141592653589793+0.08726646259971647*sin(sine*0.5))),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1.5,0),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),0,0.3490658503988659)),deltaTime) 
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,-0.2,0.4),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),-2.0943951023931953-0.08726646259971647*sin(sine*1),2.0943951023931953-0.08726646259971647*sin(sine*1))),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.5+0.05*sin(sine*1),0.1 * sin(sine*1)),angles(-1.5707963267948966+0.08726646259971647*sin(sine*1),0,3.141592653589793+0.08726646259971647*sin(sine*0.5))),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1.5,0),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),0.17453292519943295,-0.3490658503988659)),deltaTime) 

        elseif mode == "Jerking Off" then
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(0,-1.5707963267948966,0)),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.4,-1),angles(0.6981317007977318+0.2617993877991494*sin(sine*15),0,-0.8726646259971648)),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0,1.5707963267948966,0)),deltaTime) 

    elseif mode == "Invisible" then
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,1000,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 

                end
            elseif vel.Y < -1 then 

                if mode == "Unknown" then
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.1,-0.8+0.1*sin((sine+1)*2.5),-0.5),angles(-0.6981317007977318+0.17453292519943295*sin((sine+2)*2),1.3089969389957472,0.2617993877991494)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,-0.2),angles(-0.6981317007977318,0.08726646259971647*sin((sine+2)*2.5),3.490658503988659)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,3-0.4*sin(sine*2),0),angles(-2.6179938779914944+0.05235987755982989*sin((sine+0.5)*2.5),-0.17453292519943295+0.05235987755982989*sin((sine+0.5)*2.5),2.792526803190927)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.2,-0.9+0.1*sin((sine+1.3)*2.5),0),angles(-0.8726646259971648+0.17453292519943295*sin((sine+2)*-2),-1.3089969389957472,-0.22689280275926285)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1-0.1*sin((sine+2)*2.5),-0.2),angles(2.0943951023931953+0.17453292519943295*sin((sine+0.5)*2.5),-0.17453292519943295,-0.5235987755982988)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.6,0.3-0.1*sin((sine+2)*2.5),-0.2),angles(-0.8726646259971648,-0.3490658503988659,-0.3490658503988659)),deltaTime) 

                elseif mode == "Back Handstand" then 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,-0.6981317007977318,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.65+0.03*sin(sine*3),0),angles(-0.22689280275926285+0.017453292519943295*sin(sine*3),-15.707963267948966,3.141592653589793)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,1.0471975511965976,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,1.2217304763960306,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,-1.2217304763960306,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-0.5235987755982988,0.17453292519943295*sin(sine*1),3.141592653589793+0.5235987755982988*sin(sine*1))),deltaTime) 
                elseif mode == "Chest Lay" then
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1.3,1.2),angles(-2.897246558310587+0.2617993877991494*sin(sine*-6),-2.0943951023931953+0.13962634015954636*sin(sine*5),-0.5235987755982988+0.06981317007977318*sin(sine*2))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1.5,0.7+0.1*sin(sine*4)),angles(0.8726646259971648+0.10471975511965978*sin(sine*5),0.06981317007977318*sin(sine*4),3.141592653589793-0.12217304763960307*sin(sine*-5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1.2,0.8),angles(-2.705260340591211+0.2617993877991494*sin(sine*-6),1.7453292519943295+0.13962634015954636*sin(sine*5),0.8726646259971648+0.15707963267948966*sin(sine*2))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1,0.9),angles(2.9670597283903604+1.0471975511965976*sin(sine*6),-0.08726646259971647*sin(sine*2.5),0.17453292519943295)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,1,0.9),angles(2.9670597283903604+0.6981317007977318*sin(sine*-6),-0.10471975511965978*sin(sine*-2.5),-0.17453292519943295)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.6+0.1*sin(sine*1.2),0),angles(2.4085543677521746+0.10471975511965978*sin(sine*5),0.05235987755982989*sin(sine*1),3.141592653589793)),deltaTime) 

                elseif mode == "Corruption" then
                
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0.17453292519943295-0.3490658503988659*sin(sine*5),1.5707963267948966,0)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(-0.3490658503988659*sin(sine*5),0,0.17453292519943295)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(0.5235987755982988*sin(sine*5),0,-0.17453292519943295)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.07 * sin(sine*5),0),angles(-1.7453292519943295+0.03490658503988659*sin(sine*3),0.0017453292519943296*sin((sine+2)*3),3.141592653589793+0.03490658503988659*sin(sine*3))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0.17453292519943295+0.3490658503988659*sin(sine*5),-1.5707963267948966,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295+0.010471975511965976*sin(sine*5),0.03490658503988659*sin((sine+2)*4),3.141592653589793+0.06981317007977318*sin(sine*3))),deltaTime) 

                elseif mode == "Sit Jerk" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,-0.7),angles(1.2217304763960306+0.2617993877991494*sin(sine*5),0,-0.8726646259971648)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.08726646259971647*sin((sine+1)*1),0,3.141592653589793+0.08726646259971647*sin(sine*0.5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1.5,0),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),0,0.3490658503988659)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,-0.2,0.4),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),-2.0943951023931953-0.08726646259971647*sin(sine*1),2.0943951023931953-0.08726646259971647*sin(sine*1))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.5+0.05*sin(sine*1),0.1 * sin(sine*1)),angles(-1.5707963267948966+0.08726646259971647*sin(sine*1),0,3.141592653589793+0.08726646259971647*sin(sine*0.5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1.5,0),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),0.17453292519943295,-0.3490658503988659)),deltaTime) 

                elseif mode == "Jerking Off" then 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.4,-1),angles(0.6981317007977318+0.2617993877991494*sin(sine*15),0,-0.8726646259971648)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0,1.5707963267948966,0)),deltaTime) 

            elseif mode == "Invisible" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,1000,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 

                end
                else  
                    if mode == "Unknown" then
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.1,-0.8+0.1*sin((sine+1)*2.5),-0.5),angles(-0.6981317007977318+0.17453292519943295*sin((sine+2)*2),1.3089969389957472,0.2617993877991494)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,-0.2),angles(-0.6981317007977318,0.08726646259971647*sin((sine+2)*2.5),3.490658503988659)),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,3-0.4*sin(sine*2),0),angles(-2.6179938779914944+0.05235987755982989*sin((sine+0.5)*2.5),-0.17453292519943295+0.05235987755982989*sin((sine+0.5)*2.5),2.792526803190927)),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.2,-0.9+0.1*sin((sine+1.3)*2.5),0),angles(-0.8726646259971648+0.17453292519943295*sin((sine+2)*-2),-1.3089969389957472,-0.22689280275926285)),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1-0.1*sin((sine+2)*2.5),-0.2),angles(2.0943951023931953+0.17453292519943295*sin((sine+0.5)*2.5),-0.17453292519943295,-0.5235987755982988)),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.6,0.3-0.1*sin((sine+2)*2.5),-0.2),angles(-0.8726646259971648,-0.3490658503988659,-0.3490658503988659)),deltaTime) 

                    elseif mode == "Back Handstand" then
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.7,1.2,0.9+0.04*sin(sine*3)),angles(-1.7976891295541595+0.5235987755982988*sin(sine*4),1.5707963267948966,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.65+0.03*sin(sine*3),0),angles(-0.22689280275926285+0.017453292519943295*sin(sine*3),-15.707963267948966,3.141592653589793)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-0.3490658503988659+0.10471975511965978*sin(sine*4),0,3.141592653589793)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.8325957145940461-0.5235987755982988*sin(sine*4),1.5707963267948966,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.7,1.2,0.9+0.04*sin(sine*3)),angles(-1.7976891295541595-0.5235987755982988*sin(sine*4),-1.5707963267948966,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.8325957145940461+0.5235987755982988*sin(sine*4),-1.5707963267948966,0.05235987755982989*sin(sine*0.4))),deltaTime) 

                    elseif mode == "Chest Lay" then
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1.3,1.2),angles(-2.897246558310587+0.2617993877991494*sin(sine*-6),-2.0943951023931953+0.13962634015954636*sin(sine*5),-0.5235987755982988+0.06981317007977318*sin(sine*2))),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1.5,0.7+0.1*sin(sine*4)),angles(0.8726646259971648+0.10471975511965978*sin(sine*5),0.06981317007977318*sin(sine*4),3.141592653589793-0.12217304763960307*sin(sine*-5))),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1.2,0.8),angles(-2.705260340591211+0.2617993877991494*sin(sine*-6),1.7453292519943295+0.13962634015954636*sin(sine*5),0.8726646259971648+0.15707963267948966*sin(sine*2))),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1,0.9),angles(2.9670597283903604+1.0471975511965976*sin(sine*6),-0.08726646259971647*sin(sine*2.5),0.17453292519943295)),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,1,0.9),angles(2.9670597283903604+0.6981317007977318*sin(sine*-6),-0.10471975511965978*sin(sine*-2.5),-0.17453292519943295)),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.6+0.1*sin(sine*1.2),0),angles(2.4085543677521746+0.10471975511965978*sin(sine*5),0.05235987755982989*sin(sine*1),3.141592653589793)),deltaTime) 

                    elseif mode == "Corruption" then
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0.17453292519943295-0.3490658503988659*sin(sine*5),1.5707963267948966,0)),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(-0.3490658503988659*sin(sine*5),0,0.17453292519943295)),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(0.5235987755982988*sin(sine*5),0,-0.17453292519943295)),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.07 * sin(sine*5),0),angles(-1.7453292519943295+0.03490658503988659*sin(sine*3),0.0017453292519943296*sin((sine+2)*3),3.141592653589793+0.03490658503988659*sin(sine*3))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0.17453292519943295+0.3490658503988659*sin(sine*5),-1.5707963267948966,0)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295+0.010471975511965976*sin(sine*5),0.03490658503988659*sin((sine+2)*4),3.141592653589793+0.06981317007977318*sin(sine*3))),deltaTime) 

                    elseif mode == "Sit Jerk" then
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,-0.7),angles(1.2217304763960306+0.2617993877991494*sin(sine*5),0,-0.8726646259971648)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.08726646259971647*sin((sine+1)*1),0,3.141592653589793+0.08726646259971647*sin(sine*0.5))),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1.5,0),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),0,0.3490658503988659)),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,-0.2,0.4),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),-2.0943951023931953-0.08726646259971647*sin(sine*1),2.0943951023931953-0.08726646259971647*sin(sine*1))),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.5+0.05*sin(sine*1),0.1 * sin(sine*1)),angles(-1.5707963267948966+0.08726646259971647*sin(sine*1),0,3.141592653589793+0.08726646259971647*sin(sine*0.5))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1.5,0),angles(1.5707963267948966-0.08726646259971647*sin(sine*1),0.17453292519943295,-0.3490658503988659)),deltaTime) 

                    elseif mode == "Jerking Off" then 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.4,-1),angles(0.6981317007977318+0.2617993877991494*sin(sine*15),0,-0.8726646259971648)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0,1.5707963267948966,0)),deltaTime) 

                            elseif mode == "Invisible" then
                            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,1000,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                            
                    end


                end
            end)
        end)

        Reanimate:CreateDropdown("Solvex Animations", SolvexAnimation, function(selectedSolvexANim)
        mode = selectedSolvexANim
        if not R6reanimated then 
            Message("Error:", "Please Reanimate", 5)
            return 
        end


        AnimationActive = false
        StopAnim = true

        if connection then
            connection:Disconnect()
            connection = nil
        end


        local character = plr.Character or plr.CharacterAdded:Wait()
        local humanoid = character:FindFirstChild("Humanoid")
        local animate = character:FindFirstChild("Animate")

        if humanoid then
            local animator = humanoid:FindFirstChild("Animator")
            if animator then animator:Destroy() end
            humanoid.AutomaticScalingEnabled = false
        end

        if animate then
            animate.Enabled = false
        end


        local joints = {
            ["Torso"] = character.HumanoidRootPart:FindFirstChild("RootJoint"),
            ["Right Arm"] = character.Torso:FindFirstChild("Right Shoulder"),
            ["Left Arm"] = character.Torso:FindFirstChild("Left Shoulder"),
            ["Head"] = character.Torso:FindFirstChild("Neck"),
            ["Left Leg"] = character.Torso:FindFirstChild("Left Hip"),
            ["Right Leg"] = character.Torso:FindFirstChild("Right Hip")
        }

        local cf = CFrame.new
        local originalCFrames = {
            ["Torso"] = { C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
            ["Right Arm"] = { C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0), C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0) },
            ["Left Arm"] = { C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
            ["Head"] = { C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
            ["Left Leg"] = { C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
            ["Right Leg"] = { C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0), C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0) }
        }

        for jointName, joint in pairs(joints) do
            if joint then
                joint.C0 = originalCFrames[jointName].C0
                joint.C1 = originalCFrames[jointName].C1
                joint.Transform = CFrame.new() 
            end
        end


        local newAnimator = Instance.new("Animator")
        newAnimator.Parent = humanoid
        wait(0.05)
        StopAnim = false
        AnimationActive = true
        if animate then
            animate.Enabled = true
            local defaultAnimId = "http://www.roblox.com/asset/?id=180435571"
            animate.idle.Animation1.AnimationId = defaultAnimId
            animate.idle.Animation2.AnimationId = defaultAnimId
            animate.walk:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.run:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.jump:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.fall:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
        end
            wait(0.1)

            local character = plr.Character or plr.CharacterAdded:Wait()
            local humanoid = character:WaitForChild("Humanoid")
            local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
            local RootJoint = HumanoidRootPart["RootJoint"]
            local RightShoulder = character.Torso["Right Shoulder"]
            local LeftShoulder = character.Torso["Left Shoulder"]
            local Neck = character.Torso["Neck"]
            local LeftHip = character.Torso["Left Hip"]
            local RightHip = character.Torso["Right Hip"]

        if plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid:FindFirstChild("Animator") then
            plr.Character.Humanoid.Animator:Destroy()
        end
        if plr.Character:FindFirstChild("Animate") then
            plr.Character.Animate.Enabled = false
        end
            local animate = plr.Character:FindFirstChild("Animate")
        if animate then animate.Enabled = false end
                if connection then 
                    connection:Disconnect()  
                end
            
            
                local runService = game:GetService("RunService")
                local sine = 0
            
                connection = runService.RenderStepped:Connect(function(deltaTime)
                    sine += deltaTime * R67 / 1
                    deltaTime = clamp(deltaTime * 10, 0, 1)
                
                    local vel = HumanoidRootPart.Velocity
                    local onGround = humanoid:GetState() == Enum.HumanoidStateType.Freefall
            local humanoidRootPartVelocity  = character:FindFirstChild("HumanoidRootPart").Velocity 
                
                if vel.Magnitude < 1 then 
                if mode == "Cry baby" then
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.4,0.8-0.3*sin((sine+0.5)*2),-0.6),angles(3.3161255787892263,0.5235987755982988+0.08726646259971647*sin((sine+0.5)*2),0.6981317007977318-0.3490658503988659*sin((sine+0.5)*2))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.45,-1.1+0.05*sin(sine*2),0.5),angles(0.3490658503988659-0.17453292519943295*sin(sine*2),0.08726646259971647,-0.08726646259971647)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.45,-1.1-0.05*sin(sine*2),0.5),angles(0.3490658503988659+0.17453292519943295*sin(sine*2),-0.08726646259971647,0.08726646259971647)),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,0.8+0.2*sin((sine+0.5)*2),-0.6),angles(3.3161255787892263,-0.5235987755982988+0.08726646259971647*sin((sine+0.5)*2),-0.6981317007977318-0.3490658503988659*sin((sine+0.5)*2))),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295,-0.3490658503988659*sin((sine+0.5)*2),3.141592653589793+0.3490658503988659*sin((sine+1)*2))),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.2 * sin(sine*2),-0.2,0.3),angles(-1.9198621771937625,0.17453292519943295*sin(sine*2),3.141592653589793-0.3490658503988659*sin(sine*2))),deltaTime) 

                end

            elseif vel.Y > 1 then 
                    if mode == "Cry baby" then 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.4,0.8-0.3*sin((sine+0.25)*4),-0.6),angles(3.3161255787892263,0.5235987755982988+0.08726646259971647*sin((sine+0.25)*4),0.6981317007977318-0.3490658503988659*sin((sine+0.25)*4))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.45,-1.1+0.05*sin(sine*4),0.5),angles(-0.3490658503988659-0.17453292519943295*sin(sine*4),0.08726646259971647,-0.08726646259971647)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.45,-1.1-0.05*sin(sine*4),0.5),angles(-0.3490658503988659+0.17453292519943295*sin(sine*4),-0.08726646259971647,0.08726646259971647)),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,0.8+0.2*sin((sine+0.25)*4),-0.6),angles(3.3161255787892263,-0.5235987755982988+0.08726646259971647*sin((sine+0.25)*4),-0.6981317007977318-0.3490658503988659*sin((sine+0.25)*4))),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.3962634015954636,-0.3490658503988659*sin((sine+0.25)*4),3.141592653589793+0.3490658503988659*sin((sine+0.5)*4))),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.2 * sin(sine*4),0.1,0.3),angles(-1.2217304763960306,0.17453292519943295*sin(sine*4),3.141592653589793-0.3490658503988659*sin(sine*4))),deltaTime) 

                end
            elseif vel.Y < -1 then 
                if mode == "Cry baby" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.4,0.6-0.3*sin((sine+0.125)*8),-0.8),angles(3.3161255787892263,0.5235987755982988+0.08726646259971647*sin((sine+0.125)*8),0.6981317007977318-0.3490658503988659*sin((sine+0.125)*8))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.45,-1.1+0.05*sin(sine*8),0.5),angles(0.6981317007977318-0.17453292519943295*sin(sine*8),0.08726646259971647,-0.08726646259971647)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.45,-1.1-0.05*sin(sine*8),0.5),angles(0.6981317007977318+0.17453292519943295*sin(sine*8),-0.08726646259971647,0.08726646259971647)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,0.6+0.2*sin((sine+0.125)*8),-0.8),angles(3.3161255787892263,-0.5235987755982988+0.08726646259971647*sin((sine+0.125)*8),-0.6981317007977318-0.3490658503988659*sin((sine+0.125)*8))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-2.0943951023931953,-0.3490658503988659*sin((sine+0.125)*8),3.141592653589793+0.3490658503988659*sin((sine+0.25)*8))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.2 * sin(sine*8),0.1,0.3),angles(-2.2689280275926285,0.17453292519943295*sin(sine*8),3.141592653589793-0.3490658503988659*sin(sine*8))),deltaTime) 

                end
                else  
                    if mode == "Cry baby" then
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.6,0.1-0.2*sin((sine+0.4)*20),0.2),angles(-0.6981317007977318+0.3490658503988659*sin((sine+0.4)*20),0.5235987755982988+0.17453292519943295*sin((sine+0.5)*20),-0.3490658503988659-0.3490658503988659*sin((sine+0.5)*10))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.8-0.3*sin(sine*10),0.3+0.4*sin((sine+0.5)*10)),angles(-0.3490658503988659-1.2217304763960306*sin((sine+0.4)*10),0.17453292519943295*sin(sine*10),-0.08726646259971647)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.8+0.3*sin(sine*10),0.3-0.4*sin((sine+0.5)*10)),angles(-0.3490658503988659+1.2217304763960306*sin((sine+0.4)*10),0.17453292519943295*sin(sine*10),0.08726646259971647)),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.6,0.1-0.2*sin((sine+0.4)*20),0.2),angles(-0.6981317007977318+0.3490658503988659*sin((sine+0.4)*20),-0.5235987755982988-0.17453292519943295*sin((sine+0.5)*20),0.3490658503988659-0.3490658503988659*sin((sine+0.5)*10))),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976+0.3490658503988659*sin((sine+0.5)*20),-0.3490658503988659*sin((sine+0.4)*10),3.141592653589793+0.3490658503988659*sin((sine+0.4)*10))),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.2 * sin(sine*10),0.2 * sin(sine*20),0.3 * sin(sine*20)),angles(-1.3962634015954636-0.17453292519943295*sin((sine+0.4)*20),-0.17453292519943295*sin(sine*10),3.141592653589793-0.17453292519943295*sin(sine*10))),deltaTime) 

                    end
                    end
            end)
        end)


    Reanimate:CreateDropdown("Shavine Animations", Shavine, function(ShavinesModes)
        mode = ShavinesModes
        if not R6reanimated then 
            Message("Error:", "Please Reanimate", 5)
            return 
        end


        AnimationActive = false
        StopAnim = true

        if connection then
            connection:Disconnect()
            connection = nil
        end


        local character = plr.Character or plr.CharacterAdded:Wait()
        local humanoid = character:FindFirstChild("Humanoid")
        local animate = character:FindFirstChild("Animate")

        if humanoid then
            local animator = humanoid:FindFirstChild("Animator")
            if animator then animator:Destroy() end
            humanoid.AutomaticScalingEnabled = false
        end

        if animate then
            animate.Enabled = false
        end


        local joints = {
            ["Torso"] = character.HumanoidRootPart:FindFirstChild("RootJoint"),
            ["Right Arm"] = character.Torso:FindFirstChild("Right Shoulder"),
            ["Left Arm"] = character.Torso:FindFirstChild("Left Shoulder"),
            ["Head"] = character.Torso:FindFirstChild("Neck"),
            ["Left Leg"] = character.Torso:FindFirstChild("Left Hip"),
            ["Right Leg"] = character.Torso:FindFirstChild("Right Hip")
        }

        local cf = CFrame.new
        local originalCFrames = {
            ["Torso"] = { C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
            ["Right Arm"] = { C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0), C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0) },
            ["Left Arm"] = { C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
            ["Head"] = { C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
            ["Left Leg"] = { C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
            ["Right Leg"] = { C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0), C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0) }
        }

        for jointName, joint in pairs(joints) do
            if joint then
                joint.C0 = originalCFrames[jointName].C0
                joint.C1 = originalCFrames[jointName].C1
                joint.Transform = CFrame.new() 
            end
        end


        local newAnimator = Instance.new("Animator")
        newAnimator.Parent = humanoid
        wait(0.05)
        StopAnim = false
        AnimationActive = true
        if animate then
            animate.Enabled = true
            local defaultAnimId = "http://www.roblox.com/asset/?id=180435571"
            animate.idle.Animation1.AnimationId = defaultAnimId
            animate.idle.Animation2.AnimationId = defaultAnimId
            animate.walk:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.run:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.jump:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.fall:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
        end
            wait(0.1)

            local character = plr.Character or plr.CharacterAdded:Wait()
            local humanoid = character:WaitForChild("Humanoid")
            local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
            local RootJoint = HumanoidRootPart["RootJoint"]
            local RightShoulder = character.Torso["Right Shoulder"]
            local LeftShoulder = character.Torso["Left Shoulder"]
            local Neck = character.Torso["Neck"]
            local LeftHip = character.Torso["Left Hip"]
            local RightHip = character.Torso["Right Hip"]

        if plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid:FindFirstChild("Animator") then
            plr.Character.Humanoid.Animator:Destroy()
        end
        if plr.Character:FindFirstChild("Animate") then
            plr.Character.Animate.Enabled = false
        end
            local animate = plr.Character:FindFirstChild("Animate")
        if animate then animate.Enabled = false end
                if connection then 
                    connection:Disconnect()  
                end
            
            
                local runService = game:GetService("RunService")
                local sine = 0
            
                connection = runService.RenderStepped:Connect(function(deltaTime)
                    sine += deltaTime * R67 / 1
                    deltaTime = clamp(deltaTime * 10, 0, 1)
                
                    local vel = HumanoidRootPart.Velocity
                    local onGround = humanoid:GetState() == Enum.HumanoidStateType.Freefall
            local humanoidRootPartVelocity  = character:FindFirstChild("HumanoidRootPart").Velocity 
                
                if vel.Magnitude < 1 then 
                if mode == "Emoter" then 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1-0.1*sin(sine*5),0.5),angles(-0.08726646259971647*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4+0.1*sin((sine+1)*5),-0.5),angles(-0.17453292519943295*sin((sine+2)*5),0,-0.17453292519943295+0.08726646259971647*sin(sine*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.1 * sin(sine*5),0.1 * sin((sine+1)*5)),angles(-1.5707963267948966+0.08726646259971647*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.08726646259971647*sin((sine+2)*5),0,3.141592653589793)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4+0.1*sin((sine+1)*5),-0.5),angles(-0.17453292519943295*sin((sine+2)*5),0,0.17453292519943295-0.08726646259971647*sin(sine*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.1*sin(sine*5),0.5),angles(-0.08726646259971647*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 
                elseif mode == "spaghetti" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(-0.5+1*sin((sine+1)*5),1.5,1 * sin((sine+2)*5)),angles(1.5707963267948966,1.5707963267948966,1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(3 * sin((sine+2)*5),5,3 * sin((sine+3)*5)),angles(-1.5707963267948966+0.3490658503988659*sin((sine+3)*5),0.3490658503988659*sin((sine+2)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5+1*sin((sine+1)*5),-1,1 * sin((sine+2)*5)),angles(0,1.5707963267948966,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(0.5+2*sin((sine+2)*5),4.5,2 * sin((sine+3)*5)),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(1 * sin(sine*5),2,1 * sin((sine+1)*5)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5+2*sin((sine+2)*5),-3,2 * sin((sine+3)*5)),angles(0,-1.5707963267948966,0)),deltaTime) 

                elseif mode == "Dragged away" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4-0.1*sin(sine*2.5),0.5,0.8),angles(-2.443460952792061+0.2617993877991494*sin((sine+1)*5),0.5235987755982988+0.3490658503988659*sin(sine*2.5),0.3490658503988659*sin(sine*2.5))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-2.0943951023931953,-0.17453292519943295+0.08726646259971647*sin(sine*5),3.141592653589793+0.3490658503988659*sin(sine*5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,-0.5),angles(0.6981317007977318+0.3490658503988659*sin((sine+1)*5),-0.3490658503988659+0.17453292519943295*sin((sine+1)*2.5),-0.17453292519943295-0.08726646259971647*sin(sine*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.7+0.1*sin((sine+1)*2.5),-0.5),angles(1.0471975511965976-0.17453292519943295*sin(sine*5),-0.5235987755982988+0.17453292519943295*sin(sine*5),-0.3490658503988659+0.17453292519943295*sin(sine*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.2 * sin(sine*2.5),-1.7+0.1*sin(sine*5),0.2 * sin(sine*2.5)),angles(-2.0943951023931953+0.2617993877991494*sin((sine+1)*5),0.17453292519943295*sin(sine*2.5),0)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*2.5),0.1 * sin(sine*5)),angles(0.8726646259971648+0.3490658503988659*sin((sine+1)*5),0.3490658503988659,-0.17453292519943295-0.08726646259971647*sin(sine*5))),deltaTime) 

                elseif mode == "Bacon God" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.7,0.1 * sin(sine*5),0),angles(-0.5235987755982988,-0.5235987755982988,0.6981317007977318+0.17453292519943295*sin((sine+1)*5))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.9198621771937625+0.08726646259971647*sin(sine*5),0.08726646259971647*sin(sine*2.5),3.141592653589793-0.08726646259971647*sin(sine*2.5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.9,0.3),angles(-0.3490658503988659+0.17453292519943295*sin(sine*5),-0.3490658503988659,-0.17453292519943295+0.3490658503988659*sin(sine*2.5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.8+0.2*sin((sine+1)*5),0.5),angles(2.9670597283903604+0.3490658503988659*sin((sine+1)*5),0,-0.3490658503988659+0.08726646259971647*sin(sine*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.5 * sin(sine*2.5),1+0.5*sin(sine*5),0),angles(-1.0471975511965976-0.08726646259971647*sin((sine+1)*5),-0.3490658503988659+0.08726646259971647*sin(sine*2.5),3.141592653589793+0.08726646259971647*sin(sine*2.5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.3,-0.5),angles(-0.8726646259971648+0.17453292519943295*sin(sine*5),0.17453292519943295*sin(sine*2.5),-0.3490658503988659+0.17453292519943295*sin(sine*2.5))),deltaTime) 

                elseif mode == "ERRAH" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4-0.1*sin(sine*2.5),1,-0.5),angles(2.2689280275926285-0.17453292519943295*sin(sine*2.5),0.5235987755982988+0.3490658503988659*sin(sine*2.5),-0.17453292519943295*sin((sine+1)*1.25))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-2.0943951023931953+0.5235987755982988*sin(sine*105),0.5235987755982988*sin(sine*106),3.141592653589793+0.5235987755982988*sin(sine*107))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,-0.5),angles(-1.2217304763960306-0.17453292519943295*sin((sine+1)*2.5),-0.3490658503988659+0.17453292519943295*sin((sine+1)*2.5),-0.17453292519943295+0.08726646259971647*sin(sine*1.25))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.3,0.8+0.1*sin((sine+1)*2.5),-0.8),angles(2.0943951023931953-0.17453292519943295*sin(sine*105),0.6981317007977318+0.17453292519943295*sin(sine*106),1.0471975511965976+0.17453292519943295*sin(sine*107))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.3 * sin(sine*1.25),2+0.3*sin(sine*2.5),0.2 * sin(sine*2.5)),angles(2.443460952792061-0.17453292519943295*sin((sine+1)*2.5),0.17453292519943295*sin(sine*1.25),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.5+0.1*sin(sine*2.5),0.1 * sin(sine*5)),angles(-0.5235987755982988-0.2617993877991494*sin((sine+1)*2.5),0.3490658503988659,-0.17453292519943295-0.08726646259971647*sin(sine*1.25))),deltaTime) 

                elseif mode == "Creature" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,1.5,-1-0.2*sin((sine+1)*5)),angles(1.5707963267948966-0.17453292519943295*sin((sine+1)*5),0.17453292519943295,0.08726646259971647)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1.5,-0.5+0.1*sin((sine+1)*5)),angles(-0.17453292519943295*sin(sine*5),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1.5,-0.5+0.1*sin((sine+1)*5)),angles(1.5707963267948966-0.17453292519943295*sin((sine+1)*5),-0.17453292519943295,0.08726646259971647)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,1.5,-1-0.2*sin((sine+1)*5)),angles(1.5707963267948966-0.17453292519943295*sin((sine+1)*5),-0.17453292519943295,-0.08726646259971647)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.5,-0.1 * sin((sine+1)*5)),angles(3.141592653589793+0.08726646259971647*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1.5,-0.5+0.1*sin((sine+1)*5)),angles(1.5707963267948966-0.17453292519943295*sin((sine+1)*5),0.17453292519943295,-0.08726646259971647)),deltaTime) 

                elseif mode == "Sonic" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,0.5+0.1*sin(sine*5),-0.6),angles(0.8726646259971648+0.3490658503988659*sin((sine+1)*5),0.3490658503988659,0.17453292519943295)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.6580627893946132+0.17453292519943295*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.8-0.2*sin(sine*5),0.5 * sin(sine*5)),angles(-0.3490658503988659+0.3490658503988659*sin(sine*5),-0.08726646259971647,0.08726646259971647)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.4,0.5+0.1*sin(sine*5),-0.6),angles(0.8726646259971648+0.3490658503988659*sin((sine+1)*5),-0.3490658503988659,-0.17453292519943295)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.3+0.3*sin(sine*5),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.8-0.2*sin(sine*5),0.6 * sin(sine*5)),angles(-0.3490658503988659+0.3490658503988659*sin(sine*5),0.08726646259971647,-0.08726646259971647)),deltaTime) 

                elseif mode == "siezrure 2" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.5,-0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),0.3490658503988659*sin(sine*53))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),3.141592653589793+0.3490658503988659*sin(sine*53))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),0.3490658503988659*sin(sine*53))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.5,-0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*53),0.3490658503988659*sin(sine*52))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-2.5,0),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),3.141592653589793+0.3490658503988659*sin(sine*53))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1,0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*53),0.3490658503988659*sin(sine*53))),deltaTime) 

                elseif mode == "siezrure funnier" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(174532.90774614044*sin(sine*1),1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1),3.141592653589793+174532.90774614044*sin(sine*1))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(174532.90774614044*sin(sine*1),1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(174532.90774614044*sin(sine*1),-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(1 * sin(sine*25),1+3*sin(sine*20),1 * sin(sine*17)),angles(-1.5707963267948966-174532.90774614044*sin(sine*1),-174532.90774614044*sin(sine*1),3.141592653589793-174532.90774614044*sin(sine*1))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(174532.90774614044*sin(sine*1),-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 

                elseif mode == "fishy business" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(0,1.5707963267948966,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0,1.5707963267948966,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(10 * sin(sine*3),1+5*sin(sine*10),10 * sin(sine*5)),angles(-1.5707963267948966+1.7453292519943295*sin(sine*5),1.7453292519943295*sin(sine*3),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 

                elseif mode == "Pogo Stick" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.5+0.3*sin((sine+1)*10),-0.5),angles(0,0,1.5707963267948966-0.5235987755982988*sin(sine*10))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.3490658503988659*sin(sine*10),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0,-1,0.5),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.5+0.3*sin((sine+1)*10),-0.5),angles(0,0,-1.5707963267948966+0.5235987755982988*sin(sine*10))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,1.2+2*sin((sine+1)*10),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(0,-1,0.5),deltaTime) 

                elseif mode == "reverse ragdoll" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966-0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966+0.5235987755982988*sin((sine+3)*5),-1.5707963267948966)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.5 * sin((sine+3)*5),0,-0.5 * sin((sine+2)*5)),angles(-1.5707963267948966+0.5235987755982988*sin((sine+2)*5),0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 

                elseif mode == "Tornado" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(-0.5+5*sin(sine*4),0.5,5 * sin((sine+2)*4)),angles(1.5707963267948966+1.5707963267948966*sin(sine*4),1.5707963267948966*sin((sine+2)*4),-1.5707963267948966-1.5707963267948966*sin((sine+2)*4))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,-3-0.5*sin(sine*1),0),angles(-1.5707963267948966-0.08726646259971647*sin(sine*4),0.06981317007977318*sin((sine+2)*4),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5-6*sin((sine+2)*4),0,-6 * sin((sine+4)*4)),angles(1.5707963267948966+1.5707963267948966*sin((sine+2)*4),1.5707963267948966*sin((sine+4)*4),-1.5707963267948966-1.5707963267948966*sin((sine+4)*4))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.3 * sin((sine+2)*4),0.5 * sin(sine*1),0.3 * sin(sine*4)),angles(-1.5707963267948966+0.08726646259971647*sin(sine*4),-0.08726646259971647*sin((sine+2)*4),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5+6*sin((sine+2)*4),0,6 * sin((sine+4)*4)),angles(1.5707963267948966-1.5707963267948966*sin((sine+2)*4),-1.5707963267948966*sin((sine+4)*4),1.5707963267948966+1.5707963267948966*sin((sine+4)*4))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(0.5-5*sin(sine*4),0.5,-5 * sin((sine+2)*4)),angles(-1.5707963267948966+1.5707963267948966*sin(sine*4),-1.5707963267948966*sin((sine+2)*4),1.5707963267948966+1.5707963267948966*sin((sine+2)*1))),deltaTime) 

                elseif mode == "ragdoll" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966-0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.5235987755982988*sin((sine+2)*5),0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966+0.5235987755982988*sin((sine+3)*5),-1.5707963267948966)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.5 * sin((sine+1)*5),0,0.5 * sin(sine*5)),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),-0.08726646259971647*sin((sine+2)*5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 

                elseif mode == "mayhem" then
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.4,-1-0.2*sin(sine*5),0.2 * sin((sine+1)*5)),angles(-0.17453292519943295+0.17453292519943295*sin((sine+1)*5),-0.3490658503988659-0.17453292519943295*sin((sine+1)*5),0.08726646259971647*sin((sine+1)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5-0.1*sin((sine+1)*5),-0.7-0.2*sin((sine+1)*5),-0.3-0.3*sin(sine*5)),angles(0.3490658503988659-0.17453292519943295*sin(sine*5),0.3490658503988659+0.17453292519943295*sin((sine+1)*5),-0.3490658503988659+0.17453292519943295*sin((sine+1)*5))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1+0.1*sin((sine+2)*5),0.2,-1+0.1*sin((sine+2)*5)),angles(0.3490658503988659-0.2617993877991494*sin((sine+2)*5),0.5235987755982988-0.17453292519943295*sin((sine+2)*5),-0.17453292519943295+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin((sine+1)*5),-0.3+0.2*sin(sine*5),0.2 * sin((sine+1)*5)),angles(-1.9198621771937625+0.08726646259971647*sin((sine+1)*5),-0.08726646259971647+0.08726646259971647*sin((sine+1)*5),2.792526803190927)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.3962634015954636-0.08726646259971647*sin(sine*5),0.08726646259971647-0.08726646259971647*sin(sine*5),3.3161255787892263+0.2617993877991494*sin(sine*100))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1.3-0.3*sin((sine+1)*5),-0.5+0.1*sin((sine+1)*5)),angles(2.6179938779914944+0.17453292519943295*sin((sine+1)*5),0.8726646259971648,0.8726646259971648-0.2617993877991494*sin((sine+1)*5))),deltaTime) 

                elseif mode == "CHAOS" then
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.9198621771937625+0.08726646259971647*sin((sine+2)*5),-0.17453292519943295+0.17453292519943295*sin(sine*100),3.3161255787892263+0.17453292519943295*sin(sine*99))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1-0.1*sin(sine*5),-0.05 * sin(sine*5)),angles(0,-0.17453292519943295,-0.08726646259971647)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5-0.1*sin((sine+3)*5),0.4-0.2*sin((sine+2)*5),-0.7-0.1*sin((sine+2)*5)),angles(0.3490658503988659+0.3490658503988659*sin(sine*98),0.3490658503988659+0.17453292519943295*sin(sine*101),0.17453292519943295-0.2617993877991494*sin((sine+3)*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.5-0.2*sin((sine+2)*5),-0.5-0.1*sin((sine+2)*5)),angles(0.3490658503988659+0.3490658503988659*sin(sine*99),-0.3490658503988659+0.17453292519943295*sin(sine*100),-0.3490658503988659+0.2617993877991494*sin((sine+3)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7-0.1*sin(sine*5),-0.05 * sin(sine*5)),angles(0.3490658503988659,0.3490658503988659,-0.17453292519943295)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.02 * sin(sine*5),-0.3+0.1*sin(sine*5),0),angles(-1.9198621771937625,-0.08726646259971647,2.9670597283903604)),deltaTime) 

                elseif mode == "Laugh" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.15+0.15*sin(sine*10),0.5),angles(-0.7853981633974483,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7-0.1*sin(sine*10),0.5+0.1*sin(sine*10)),angles(-0.7853981633974483,0,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976,0,3.141592653589793)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.6-0.05*sin(sine*10),0.1 * sin(sine*10),-0.2+0.05*sin(sine*10)),angles(-0.8726646259971648,0.17453292519943295+0.08726646259971647*sin(sine*10),-0.17453292519943295-0.08726646259971647*sin(sine*10))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,0.7+0.1*sin(sine*10),-0.5),angles(2.9670597283903604+0.05235987755982989*sin((sine+0.5)*10),0.17453292519943295+0.05235987755982989*sin(sine*10),-0.9599310885968813)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.7-0.1*sin(sine*10),0.5+0.1*sin(sine*10)),angles(-0.7853981633974483,0,0)),deltaTime) 

                elseif mode == "No" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0.3490658503988659*sin((sine+1)*5),3.141592653589793-0.8726646259971648*sin((sine+1)*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4-0.2*sin((sine+3)*5),-0.5),angles(-0.5235987755982988*sin((sine+3)*5),0,-0.17453292519943295)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4+0.2*sin((sine+3)*5),-0.5),angles(0.5235987755982988*sin((sine+3)*5),0,0.17453292519943295)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5,-1,0.5),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0.5,-1,0.5),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.4 * sin(sine*5),0,0),angles(-1.5707963267948966,0.17453292519943295*sin(sine*5),3.141592653589793-0.5235987755982988*sin(sine*5))),deltaTime) 
                elseif mode == "Yes" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.5235987755982988*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4-0.2*sin((sine+2)*5),-0.5),angles(-0.3490658503988659*sin((sine+2)*5),0,-0.17453292519943295)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4-0.2*sin((sine+2)*5),-0.5),angles(-0.3490658503988659*sin((sine+2)*5),0,0.17453292519943295)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5,-1,0.5),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0.5,-1,0.5),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0,0.5 * sin(sine*5)),angles(-1.5707963267948966+0.17453292519943295*sin(sine*5),0,3.141592653589793)),deltaTime) 

                elseif mode == "Wave" then 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5+0.3*sin((sine+1)*10),1.3-0.3*sin((sine+1)*10),0.5),angles(3.141592653589793,0,0.6981317007977318-0.6981317007977318*sin((sine+3)*10))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(0,0,-0.3490658503988659-0.08726646259971647*sin((sine+1)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.45,-1-0.05*sin(sine*5),0.5),angles(0,0.08726646259971647,-0.13962634015954636+0.08726646259971647*sin(sine*5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.45,-1.1+0.05*sin(sine*5),0.5),angles(0,-0.08726646259971647,-0.05235987755982989+0.08726646259971647*sin(sine*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin(sine*5),0,0),angles(-1.5707963267948966,-0.08726646259971647+0.08726646259971647*sin(sine*5),3.141592653589793)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,-0.17453292519943295+0.17453292519943295*sin((sine+1)*5),3.141592653589793)),deltaTime) 

                elseif mode == "Point" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),0.08726646259971647-0.08726646259971647*sin(sine*5),2.792526803190927)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.2 * sin((sine+1)*5),-0.05+0.1*sin(sine*5),0),angles(-1.5707963267948966,-0.08726646259971647+0.05235987755982989*sin((sine+1)*5),3.490658503988659)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5+0.1*sin((sine+1)*5),-1-0.1*sin(sine*5),0.5),angles(0,-0.08726646259971647,0.05235987755982989-0.05235987755982989*sin((sine+1)*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.6,0.5+0.1*sin(sine*5),-0.3),angles(-0.17453292519943295,0.3490658503988659,-0.3490658503988659+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.1*sin(sine*5),0.5),angles(0,0.08726646259971647,-0.08726646259971647-0.03490658503988659*sin((sine+1)*5))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,1,-0.5+0.2*sin(sine*5)),angles(1.3962634015954636+0.08726646259971647*sin((sine+1)*5),0.5235987755982988+0.08726646259971647*sin(sine*5),0.3490658503988659)),deltaTime) 

                elseif mode == "Scared" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.08726646259971647*sin(sine*5),-0.2617993877991494*sin(sine*50),3.141592653589793+0.5235987755982988*sin(sine*1))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin(sine*50),-0.1 * sin(sine*5),-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),0.08726646259971647*sin(sine*50),3.141592653589793+0.08726646259971647*sin(sine*55))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1+0.1*sin(sine*50),0.5+0.1*sin(sine*52),-0.5+0.1*sin(sine*54)),angles(1.3962634015954636,-0.17453292519943295,-1.3962634015954636)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*5),0.5),angles(0.08726646259971647*sin((sine+1)*5),0.08726646259971647+0.08726646259971647*sin(sine*55),-0.08726646259971647+0.08726646259971647*sin(sine*50))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1+0.1*sin(sine*52),0.5+0.1*sin(sine*50),-0.6+0.1*sin(sine*54)),angles(1.2217304763960306+0.17453292519943295*sin(sine*5),0.17453292519943295,0.8726646259971648)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.4,-1+0.1*sin(sine*5),0.5),angles(0.08726646259971647*sin((sine+1)*5),-0.08726646259971647+0.08726646259971647*sin(sine*55),0.08726646259971647+0.08726646259971647*sin(sine*50))),deltaTime) 
                elseif mode == "AMOGUS" then 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.05-0.1*sin(sine*5),-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.1*sin(sine*5),0.5),angles(0.08726646259971647*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,-0.4-0.1*sin((sine+1)*5),-0.5+0.05*sin((sine+2)*5)),angles(-1.5707963267948966-0.08726646259971647*sin((sine+2)*5),0,3.141592653589793)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.25,0.4-0.05*sin((sine+1)*5),0.5),angles(0.08726646259971647,0.17453292519943295,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.25,0.4-0.05*sin((sine+1)*5),0.5),angles(0.08726646259971647,-0.17453292519943295,0)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*5),0.5),angles(0.08726646259971647*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 

                elseif mode == "Chase" then
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295-0.03490658503988659*sin((sine+1)*2),0,3.141592653589793)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5-0.01*sin((sine+2)*2),0.4-0.1*sin((sine+2)*2),-0.5+0.1*sin((sine+1)*2)),angles(-0.06981317007977318*sin((sine+2)*2),0.06981317007977318*sin((sine+2)*2),-0.17453292519943295-0.017453292519943295*sin(sine*-4.2))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1,-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966+0.03490658503988659*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,1,-0.3),angles(2.9670597283903604+0.2617993877991494*sin((sine+2)*5),2.792526803190927,0.6981317007977318)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.1*sin((sine+1)*3),0.5),angles(-0.06981317007977318*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin((sine+1)*3),0.5),angles(-0.06981317007977318*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 

                elseif mode == "equinox" then
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0.08726646259971647*sin((sine+2)*2.5),3.490658503988659)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.8+0.1*sin((sine+1)*2.5),0),angles(-0.3490658503988659+0.17453292519943295*sin((sine+2)*2.5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.6,0.3-0.1*sin((sine+2)*2.5),-0.2),angles(0,-0.3490658503988659,0.3490658503988659-0.17453292519943295*sin((sine+4)*2.5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.3-0.1*sin((sine+2)*2.5),-0.5),angles(0.17453292519943295*sin((sine+0.5)*2.5),-0.17453292519943295,-0.17453292519943295+0.08726646259971647*sin((sine+4)*1.25))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.5+0.1*sin((sine+1.3)*2.5),-0.5),angles(-0.6981317007977318-0.17453292519943295*sin((sine+2)*2.5),0.17453292519943295,-0.05235987755982989)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,1-0.3*sin(sine*2.5),0),angles(-1.5707963267948966+0.05235987755982989*sin((sine+0.5)*2.5),0.05235987755982989*sin((sine+0.5)*2.5),2.792526803190927)),deltaTime) 


                end
                elseif vel.Y > 1 then 
                if mode == "Emoter" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295+0.17453292519943295*sin((sine+3)*5),0,3.141592653589793)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,1.2-0.2*sin((sine+2)*5),-0.2 * sin((sine+3)*5)),angles(2.0943951023931953-0.3490658503988659*sin((sine+3)*5),0.5235987755982988,0.5235987755982988+0.08726646259971647*sin((sine+3)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.3,-0.5+0.1*sin((sine+2)*5),0),angles(-0.3490658503988659+0.17453292519943295*sin((sine+3)*5),0.3490658503988659,-0.17453292519943295)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(angles(-1.3962634015954636+0.08726646259971647*sin(sine*5),0,3.141592653589793),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.4,-0.9,0.3),angles(-0.3490658503988659+0.17453292519943295*sin((sine+2)*5),-0.3490658503988659,0.17453292519943295)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1.2-0.2*sin((sine+1)*5),-0.1 * sin((sine+2)*5)),angles(2.0943951023931953-0.3490658503988659*sin((sine+2)*5),-0.5235987755982988,-0.5235987755982988+0.08726646259971647*sin((sine+2)*5))),deltaTime) 
                elseif mode == "spaghetti" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(-0.5+1*sin((sine+1)*5),1.5,1 * sin((sine+2)*5)),angles(1.5707963267948966,1.5707963267948966,1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(3 * sin((sine+2)*5),5,3 * sin((sine+3)*5)),angles(-1.5707963267948966+0.3490658503988659*sin((sine+3)*5),0.3490658503988659*sin((sine+2)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5+1*sin((sine+1)*5),-1,1 * sin((sine+2)*5)),angles(0,1.5707963267948966,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(0.5+2*sin((sine+2)*5),4.5,2 * sin((sine+3)*5)),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(1 * sin(sine*5),2,1 * sin((sine+1)*5)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5+2*sin((sine+2)*5),-3,2 * sin((sine+3)*5)),angles(0,-1.5707963267948966,0)),deltaTime) 

                elseif mode == "Wave" then 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5+0.3*sin((sine+1)*10),1.3-0.3*sin((sine+1)*10),0.5),angles(3.141592653589793,0,0.6981317007977318-0.6981317007977318*sin((sine+3)*10))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(0,0,-0.3490658503988659-0.08726646259971647*sin((sine+1)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.45,-1-0.05*sin(sine*5),0.5),angles(0,0.08726646259971647,-0.13962634015954636+0.08726646259971647*sin(sine*5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.45,-1.1+0.05*sin(sine*5),0.5),angles(0,-0.08726646259971647,-0.05235987755982989+0.08726646259971647*sin(sine*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin(sine*5),0,0),angles(-1.5707963267948966,-0.08726646259971647+0.08726646259971647*sin(sine*5),3.141592653589793)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,-0.17453292519943295+0.17453292519943295*sin((sine+1)*5),3.141592653589793)),deltaTime) 

                elseif mode == "No" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0.3490658503988659*sin((sine+1)*5),3.141592653589793-0.8726646259971648*sin((sine+1)*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4-0.2*sin((sine+3)*5),-0.5),angles(-0.5235987755982988*sin((sine+3)*5),0,-0.17453292519943295)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4+0.2*sin((sine+3)*5),-0.5),angles(0.5235987755982988*sin((sine+3)*5),0,0.17453292519943295)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5,-1,0.5),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0.5,-1,0.5),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.4 * sin(sine*5),0,0),angles(-1.5707963267948966,0.17453292519943295*sin(sine*5),3.141592653589793-0.5235987755982988*sin(sine*5))),deltaTime) 
                elseif mode == "Yes" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.5235987755982988*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4-0.2*sin((sine+2)*5),-0.5),angles(-0.3490658503988659*sin((sine+2)*5),0,-0.17453292519943295)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4-0.2*sin((sine+2)*5),-0.5),angles(-0.3490658503988659*sin((sine+2)*5),0,0.17453292519943295)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5,-1,0.5),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0.5,-1,0.5),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0,0.5 * sin(sine*5)),angles(-1.5707963267948966+0.17453292519943295*sin(sine*5),0,3.141592653589793)),deltaTime) 

                elseif mode == "Point" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),0.08726646259971647-0.08726646259971647*sin(sine*5),2.792526803190927)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.2 * sin((sine+1)*5),-0.05+0.1*sin(sine*5),0),angles(-1.5707963267948966,-0.08726646259971647+0.05235987755982989*sin((sine+1)*5),3.490658503988659)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5+0.1*sin((sine+1)*5),-1-0.1*sin(sine*5),0.5),angles(0,-0.08726646259971647,0.05235987755982989-0.05235987755982989*sin((sine+1)*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.6,0.5+0.1*sin(sine*5),-0.3),angles(-0.17453292519943295,0.3490658503988659,-0.3490658503988659+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.1*sin(sine*5),0.5),angles(0,0.08726646259971647,-0.08726646259971647-0.03490658503988659*sin((sine+1)*5))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,1,-0.5+0.2*sin(sine*5)),angles(1.3962634015954636+0.08726646259971647*sin((sine+1)*5),0.5235987755982988+0.08726646259971647*sin(sine*5),0.3490658503988659)),deltaTime) 

                elseif mode == "Bacon God" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.3 * sin(sine*5),0.3 * sin((sine+2)*5)),angles(-2.356194490192345-0.08726646259971647*sin((sine+1)*5),0,3.141592653589793+0.08726646259971647*sin(sine*2.5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7,0.3),angles(-0.5235987755982988-0.17453292519943295*sin((sine+4)*5),0.3490658503988659,0)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.5+0.3*sin((sine+1)*5),-0.3),angles(-0.5235987755982988+0.17453292519943295*sin(sine*5),-0.3490658503988659,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976-0.08726646259971647*sin(sine*5),0,3.141592653589793-0.08726646259971647*sin(sine*2.5))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.17453292519943295*sin((sine+2)*5))),deltaTime) 

                elseif mode == "Tornado" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(-0.5+5*sin(sine*4),0.5,5 * sin((sine+2)*4)),angles(1.5707963267948966+1.5707963267948966*sin(sine*4),1.5707963267948966*sin((sine+2)*4),-1.5707963267948966-1.5707963267948966*sin((sine+2)*4))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,-3-0.5*sin(sine*1),0),angles(-1.5707963267948966-0.08726646259971647*sin(sine*4),0.06981317007977318*sin((sine+2)*4),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5-6*sin((sine+2)*4),0,-6 * sin((sine+4)*4)),angles(1.5707963267948966+1.5707963267948966*sin((sine+2)*4),1.5707963267948966*sin((sine+4)*4),-1.5707963267948966-1.5707963267948966*sin((sine+4)*4))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.3 * sin((sine+2)*4),0.5 * sin(sine*1),0.3 * sin(sine*4)),angles(-1.5707963267948966+0.08726646259971647*sin(sine*4),-0.08726646259971647*sin((sine+2)*4),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5+6*sin((sine+2)*4),0,6 * sin((sine+4)*4)),angles(1.5707963267948966-1.5707963267948966*sin((sine+2)*4),-1.5707963267948966*sin((sine+4)*4),1.5707963267948966+1.5707963267948966*sin((sine+4)*4))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(0.5-5*sin(sine*4),0.5,-5 * sin((sine+2)*4)),angles(-1.5707963267948966+1.5707963267948966*sin(sine*4),-1.5707963267948966*sin((sine+2)*4),1.5707963267948966+1.5707963267948966*sin((sine+2)*1))),deltaTime) 

                elseif mode == "equinox" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.3 * sin(sine*5),0.3 * sin((sine+2)*5)),angles(-2.356194490192345-0.08726646259971647*sin((sine+1)*5),0,3.141592653589793+0.08726646259971647*sin(sine*2.5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7,0.3),angles(-0.5235987755982988-0.17453292519943295*sin((sine+4)*5),0.3490658503988659,0)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.5+0.3*sin((sine+1)*5),-0.3),angles(-0.5235987755982988+0.17453292519943295*sin(sine*5),-0.3490658503988659,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976-0.08726646259971647*sin(sine*5),0,3.141592653589793-0.08726646259971647*sin(sine*2.5))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.17453292519943295*sin((sine+2)*5))),deltaTime) 

                elseif mode == "Creature" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,1.5-0.5*sin((sine+0.5)*10),-1+0.5*sin((sine+0.25)*10)),angles(1.5707963267948966-0.7853981633974483*sin((sine+0.5)*10),0,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1.5,-0.5),angles(0.17453292519943295*sin((sine+1)*20),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1.5+0.5*sin((sine+0.5)*10),-0.5+0.5*sin((sine+0.25)*10)),angles(1.5707963267948966+0.5235987755982988*sin(sine*10),-0.08726646259971647,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,1.5+0.5*sin((sine+0.5)*10),-1-0.5*sin((sine+0.25)*10)),angles(1.5707963267948966+0.7853981633974483*sin((sine+0.5)*10),0,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.6+0.2*sin(sine*20),-0.1 * sin(sine*20)),angles(-3.141592653589793+0.08726646259971647*sin((sine+0.5)*20),0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1.5-0.5*sin((sine+0.5)*10),-0.5-0.5*sin((sine+0.25)*10)),angles(1.5707963267948966-0.5235987755982988*sin(sine*10),0.08726646259971647,0)),deltaTime) 

                elseif mode == "ERRAH" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4-0.1*sin(sine*2.5),1,-0.8),angles(1.7453292519943295+0.17453292519943295*sin(sine*5),0.5235987755982988+0.3490658503988659*sin(sine*2.5),-0.17453292519943295*sin((sine+1)*2.5))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-2.0943951023931953+0.5235987755982988*sin(sine*105),-0.17453292519943295+0.5235987755982988*sin(sine*106),3.141592653589793+0.5235987755982988*sin(sine*107))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,-0.5),angles(0.6981317007977318-0.17453292519943295*sin((sine+1)*2.5),-0.3490658503988659+0.17453292519943295*sin((sine+1)*2.5),-0.17453292519943295+0.08726646259971647*sin(sine*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,1+0.1*sin((sine+1)*2.5),-0.8),angles(2.0943951023931953-0.17453292519943295*sin(sine*105),0.6981317007977318+0.17453292519943295*sin(sine*106),1.2217304763960306+0.17453292519943295*sin(sine*107))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.3 * sin(sine*2.5),2+0.3*sin(sine*5),0.2 * sin(sine*2.5)),angles(2.0943951023931953-0.17453292519943295*sin((sine+1)*5),0.17453292519943295*sin(sine*2.5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*2.5),0.1 * sin(sine*5)),angles(0.5235987755982988-0.2617993877991494*sin((sine+1)*2.5),0.3490658503988659,-0.17453292519943295-0.08726646259971647*sin(sine*5))),deltaTime) 

                elseif mode == "siezrure funnier" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(174532.90774614044*sin(sine*1),1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1),3.141592653589793+174532.90774614044*sin(sine*1))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(174532.90774614044*sin(sine*1),1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(174532.90774614044*sin(sine*1),-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(1 * sin(sine*25),1+3*sin(sine*20),1 * sin(sine*17)),angles(-1.5707963267948966-174532.90774614044*sin(sine*1),-174532.90774614044*sin(sine*1),3.141592653589793-174532.90774614044*sin(sine*1))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(174532.90774614044*sin(sine*1),-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 

                elseif mode == "siezrure 2" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.5,-0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),0.3490658503988659*sin(sine*53))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),3.141592653589793+0.3490658503988659*sin(sine*53))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),0.3490658503988659*sin(sine*53))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.5,-0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*53),0.3490658503988659*sin(sine*52))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-2.5,0),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),3.141592653589793+0.3490658503988659*sin(sine*53))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1,0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*53),0.3490658503988659*sin(sine*53))),deltaTime) 

                elseif mode == "Sonic" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.8+0.2*sin((sine+1)*20),0.3+0.3*sin((sine+1)*40),0),angles(-0.8726646259971648+0.3490658503988659*sin((sine+1)*40),-0.3490658503988659-0.5235987755982988*sin((sine+1)*20),0.5235987755982988)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976-0.08726646259971647*sin(sine*40),-0.17453292519943295*sin(sine*20),3.141592653589793-0.17453292519943295*sin(sine*20))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.5*sin((sine+0.5)*20),0.3-0.5*sin((sine+1)*20)),angles(1.7453292519943295*sin((sine+1)*20),0,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.8+0.2*sin((sine+1)*20),0.3+0.3*sin((sine+1)*40),0),angles(-0.8726646259971648+0.3490658503988659*sin((sine+1)*40),0.3490658503988659-0.5235987755982988*sin((sine+1)*20),-0.5235987755982988)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.3 * sin(sine*40),0.5 * sin((sine+1)*40)),angles(-2.181661564992912-0.17453292519943295*sin((sine+1)*40),0.08726646259971647*sin(sine*20),3.141592653589793+0.17453292519943295*sin(sine*20))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.5*sin((sine+0.5)*20),0.3+0.5*sin((sine+1)*20)),angles(-1.7453292519943295*sin((sine+1)*20),0,0)),deltaTime) 

                elseif mode == "Pogo Stick" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.5+0.3*sin((sine+1)*10),-0.5),angles(0,0,1.5707963267948966-0.5235987755982988*sin(sine*10))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.3490658503988659*sin(sine*10),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0,-1,0.5),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.5+0.3*sin((sine+1)*10),-0.5),angles(0,0,-1.5707963267948966+0.5235987755982988*sin(sine*10))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,1.2+2*sin((sine+1)*10),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(0,-1,0.5),deltaTime) 

                elseif mode == "fishy business" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(0,1.5707963267948966,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0,1.5707963267948966,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(10 * sin(sine*3),1+5*sin(sine*10),10 * sin(sine*5)),angles(-1.5707963267948966+1.7453292519943295*sin(sine*5),1.7453292519943295*sin(sine*3),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 

                elseif mode == "CHAOS" then
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.9198621771937625+0.08726646259971647*sin((sine+2)*5),0.17453292519943295*sin(sine*100),3.141592653589793+0.17453292519943295*sin(sine*99))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin(sine*2.5),0.2 * sin((sine+0.5)*2.5)),angles(0.17453292519943295-0.5235987755982988*sin((sine+0.5)*2.5),0,0)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4+0.1*sin(sine*2.5),0.3-0.3*sin(sine*2.5),-0.7+0.2*sin(sine*2.5)),angles(0.3490658503988659-0.5235987755982988*sin(sine*2.5),0.3490658503988659*sin(sine*101),0.17453292519943295*sin(sine*2.5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.4+0.1*sin(sine*2.5),0.3+0.3*sin(sine*2.5),-0.7-0.2*sin(sine*2.5)),angles(0.3490658503988659+0.5235987755982988*sin(sine*2.5),0.3490658503988659*sin(sine*100),0.17453292519943295*sin(sine*2.5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.2*sin(sine*2.5),-0.2 * sin((sine+0.5)*2.5)),angles(0.17453292519943295+0.5235987755982988*sin((sine+0.5)*2.5),0,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1 * sin(sine*5),0),angles(-1.9198621771937625,0,3.141592653589793)),deltaTime) 

                elseif mode == "Chase" then
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.8,0.5),angles(-0.5235987755982988,-0.08726646259971647,0.08726646259971647)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.3,1+0.3*sin((sine+1)*10),-0.5),angles(2.2689280275926285+0.2617993877991494*sin((sine+1)*20),-0.5235987755982988,-0.08726646259971647*sin((sine+1)*10))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.3,1-0.3*sin((sine+1)*10),-0.5),angles(2.2689280275926285+0.2617993877991494*sin((sine+1)*20),0.5235987755982988,-0.08726646259971647*sin((sine+1)*10))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.8,0.5),angles(-0.5235987755982988,0.08726646259971647,-0.08726646259971647)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(angles(-1.7453292519943295,0.17453292519943295*sin(sine*10),3.141592653589793+0.3490658503988659*sin(sine*10)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.2217304763960306+0.17453292519943295*sin((sine+2)*20),0.3490658503988659*sin((sine+1)*10),3.141592653589793-0.17453292519943295*sin(sine*10))),deltaTime) 
                elseif mode == "AMOGUS" then 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.05-0.1*sin(sine*5),-0.1 * sin((sine+1)*5)),angles(-1.2217304763960306+0.08726646259971647*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.1*sin(sine*5),0.5),angles(-0.5235987755982988-0.3490658503988659*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,-0.4-0.1*sin((sine+1)*5),-0.5+0.05*sin((sine+2)*5)),angles(-1.9198621771937625-0.08726646259971647*sin((sine+2)*5),0,3.141592653589793)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.25,0.4-0.05*sin((sine+1)*5),0.5),angles(0.08726646259971647,0.17453292519943295,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.25,0.4-0.05*sin((sine+1)*5),0.5),angles(0.08726646259971647,-0.17453292519943295,0)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*5),0.5),angles(-0.5235987755982988-0.3490658503988659*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 

                elseif mode == "Scared" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.08726646259971647*sin(sine*5),-0.2617993877991494*sin(sine*50),3.141592653589793+0.5235987755982988*sin(sine*1))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin(sine*50),-0.1 * sin(sine*5),-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),0.08726646259971647*sin(sine*50),3.141592653589793+0.08726646259971647*sin(sine*55))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1+0.1*sin(sine*50),0.5+0.1*sin(sine*52),-0.5+0.1*sin(sine*54)),angles(1.3962634015954636,-0.17453292519943295,-1.3962634015954636)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*5),0.5),angles(0.08726646259971647*sin((sine+1)*5),0.08726646259971647+0.08726646259971647*sin(sine*55),-0.08726646259971647+0.08726646259971647*sin(sine*50))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1+0.1*sin(sine*52),0.5+0.1*sin(sine*50),-0.6+0.1*sin(sine*54)),angles(1.2217304763960306+0.17453292519943295*sin(sine*5),0.17453292519943295,0.8726646259971648)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.4,-1+0.1*sin(sine*5),0.5),angles(0.08726646259971647*sin((sine+1)*5),-0.08726646259971647+0.08726646259971647*sin(sine*55),0.08726646259971647+0.08726646259971647*sin(sine*50))),deltaTime) 
                elseif mode == "Laugh" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.15+0.15*sin(sine*10),0.5),angles(-0.7853981633974483,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7-0.1*sin(sine*10),0.5+0.1*sin(sine*10)),angles(-0.7853981633974483,0,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976,0,3.141592653589793)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.6-0.05*sin(sine*10),0.1 * sin(sine*10),-0.2+0.05*sin(sine*10)),angles(-0.8726646259971648,0.17453292519943295+0.08726646259971647*sin(sine*10),-0.17453292519943295-0.08726646259971647*sin(sine*10))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,0.7+0.1*sin(sine*10),-0.5),angles(2.9670597283903604+0.05235987755982989*sin((sine+0.5)*10),0.17453292519943295+0.05235987755982989*sin(sine*10),-0.9599310885968813)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.7-0.1*sin(sine*10),0.5+0.1*sin(sine*10)),angles(-0.7853981633974483,0,0)),deltaTime) 

                elseif mode == "mayhem" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1+0.1*sin((sine+2)*5),0.2,-1+0.1*sin((sine+2)*5)),angles(0.3490658503988659-0.2617993877991494*sin((sine+2)*5),0.5235987755982988-0.17453292519943295*sin((sine+2)*5),-0.17453292519943295+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.3962634015954636-0.08726646259971647*sin(sine*5),0.08726646259971647-0.08726646259971647*sin(sine*5),3.3161255787892263+0.2617993877991494*sin(sine*100))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.4,-1-0.3*sin(sine*5),0.7 * sin((sine+1)*5)),angles(-0.5934119456780721-0.15707963267948966*sin((sine+1)*5),-0.3490658503988659,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1.3-0.3*sin((sine+1)*5),-0.5+0.1*sin((sine+1)*5)),angles(2.6179938779914944+0.17453292519943295*sin((sine+1)*5),0.8726646259971648,0.8726646259971648-0.2617993877991494*sin((sine+1)*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin((sine+1)*5),-0.3+0.2*sin(sine*5),0.2 * sin((sine+1)*5)),angles(-1.9198621771937625+0.08726646259971647*sin((sine+1)*5),-0.08726646259971647+0.08726646259971647*sin((sine+1)*5),2.792526803190927)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5-0.1*sin((sine+1)*5),-0.7,-0.3-0.2*sin(sine*5)),angles(-0.17453292519943295+0.5934119456780721*sin(sine*5),0.3490658503988659,-0.17453292519943295)),deltaTime) 

                elseif mode == "reverse ragdoll" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966-0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966+0.5235987755982988*sin((sine+3)*5),-1.5707963267948966)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.5 * sin((sine+3)*5),0,-0.5 * sin((sine+2)*5)),angles(-1.5707963267948966+0.5235987755982988*sin((sine+2)*5),0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 

                elseif mode == "ragdoll" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966-0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.5235987755982988*sin((sine+2)*5),0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966+0.5235987755982988*sin((sine+3)*5),-1.5707963267948966)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.5 * sin((sine+1)*5),0,0.5 * sin(sine*5)),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),-0.08726646259971647*sin((sine+2)*5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 


                end
            elseif vel.Y < -1 then 
                if mode == "Emoter" then 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.8+0.2*sin((sine+2)*5),-0.5),angles(0.17453292519943295+0.3490658503988659*sin((sine+2)*5),0,1.3962634015954636+0.08726646259971647*sin((sine+3)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.3,-0.3+0.1*sin((sine+2)*5),-0.5),angles(-0.6981317007977318+0.17453292519943295*sin((sine+3)*5),0.3490658503988659,-0.17453292519943295)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(angles(-1.7453292519943295+0.08726646259971647*sin(sine*5),0,3.141592653589793),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.4835298641951802+0.17453292519943295*sin((sine+3)*5),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.4,-0.9,0.3),angles(0.17453292519943295+0.17453292519943295*sin((sine+2)*5),-0.3490658503988659,0.17453292519943295)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.8+0.2*sin((sine+1)*5),-0.5),angles(0.17453292519943295+0.3490658503988659*sin((sine+1)*5),0,-1.3962634015954636+0.08726646259971647*sin((sine+2)*5))),deltaTime) 
                elseif mode == "spaghetti" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(-0.5+1*sin((sine+1)*5),1.5,1 * sin((sine+2)*5)),angles(1.5707963267948966,1.5707963267948966,1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(3 * sin((sine+2)*5),5,3 * sin((sine+3)*5)),angles(-1.5707963267948966+0.3490658503988659*sin((sine+3)*5),0.3490658503988659*sin((sine+2)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5+1*sin((sine+1)*5),-1,1 * sin((sine+2)*5)),angles(0,1.5707963267948966,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(0.5+2*sin((sine+2)*5),4.5,2 * sin((sine+3)*5)),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(1 * sin(sine*5),2,1 * sin((sine+1)*5)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5+2*sin((sine+2)*5),-3,2 * sin((sine+3)*5)),angles(0,-1.5707963267948966,0)),deltaTime) 

                elseif mode == "Wave" then 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5+0.3*sin((sine+1)*10),1.3-0.3*sin((sine+1)*10),0.5),angles(3.141592653589793,0,0.6981317007977318-0.6981317007977318*sin((sine+3)*10))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(0,0,-0.3490658503988659-0.08726646259971647*sin((sine+1)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.45,-1-0.05*sin(sine*5),0.5),angles(0,0.08726646259971647,-0.13962634015954636+0.08726646259971647*sin(sine*5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.45,-1.1+0.05*sin(sine*5),0.5),angles(0,-0.08726646259971647,-0.05235987755982989+0.08726646259971647*sin(sine*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin(sine*5),0,0),angles(-1.5707963267948966,-0.08726646259971647+0.08726646259971647*sin(sine*5),3.141592653589793)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,-0.17453292519943295+0.17453292519943295*sin((sine+1)*5),3.141592653589793)),deltaTime) 

                elseif mode == "No" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0.3490658503988659*sin((sine+1)*5),3.141592653589793-0.8726646259971648*sin((sine+1)*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4-0.2*sin((sine+3)*5),-0.5),angles(-0.5235987755982988*sin((sine+3)*5),0,-0.17453292519943295)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4+0.2*sin((sine+3)*5),-0.5),angles(0.5235987755982988*sin((sine+3)*5),0,0.17453292519943295)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5,-1,0.5),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0.5,-1,0.5),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.4 * sin(sine*5),0,0),angles(-1.5707963267948966,0.17453292519943295*sin(sine*5),3.141592653589793-0.5235987755982988*sin(sine*5))),deltaTime) 
                elseif mode == "Yes" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.5235987755982988*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4-0.2*sin((sine+2)*5),-0.5),angles(-0.3490658503988659*sin((sine+2)*5),0,-0.17453292519943295)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4-0.2*sin((sine+2)*5),-0.5),angles(-0.3490658503988659*sin((sine+2)*5),0,0.17453292519943295)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5,-1,0.5),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0.5,-1,0.5),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0,0.5 * sin(sine*5)),angles(-1.5707963267948966+0.17453292519943295*sin(sine*5),0,3.141592653589793)),deltaTime) 

                elseif mode == "Point" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),0.08726646259971647-0.08726646259971647*sin(sine*5),2.792526803190927)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.2 * sin((sine+1)*5),-0.05+0.1*sin(sine*5),0),angles(-1.5707963267948966,-0.08726646259971647+0.05235987755982989*sin((sine+1)*5),3.490658503988659)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5+0.1*sin((sine+1)*5),-1-0.1*sin(sine*5),0.5),angles(0,-0.08726646259971647,0.05235987755982989-0.05235987755982989*sin((sine+1)*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.6,0.5+0.1*sin(sine*5),-0.3),angles(-0.17453292519943295,0.3490658503988659,-0.3490658503988659+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.1*sin(sine*5),0.5),angles(0,0.08726646259971647,-0.08726646259971647-0.03490658503988659*sin((sine+1)*5))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,1,-0.5+0.2*sin(sine*5)),angles(1.3962634015954636+0.08726646259971647*sin((sine+1)*5),0.5235987755982988+0.08726646259971647*sin(sine*5),0.3490658503988659)),deltaTime) 

                elseif mode == "Creature" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,1.5-0.5*sin((sine+0.5)*10),-1+0.5*sin((sine+0.25)*10)),angles(1.5707963267948966-0.7853981633974483*sin((sine+0.5)*10),0,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1.5,-0.5),angles(0.17453292519943295*sin((sine+1)*20),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1.5+0.5*sin((sine+0.5)*10),-0.5+0.5*sin((sine+0.25)*10)),angles(1.5707963267948966+0.5235987755982988*sin(sine*10),-0.08726646259971647,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,1.5+0.5*sin((sine+0.5)*10),-1-0.5*sin((sine+0.25)*10)),angles(1.5707963267948966+0.7853981633974483*sin((sine+0.5)*10),0,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.6+0.2*sin(sine*20),-0.1 * sin(sine*20)),angles(-3.141592653589793+0.08726646259971647*sin((sine+0.5)*20),0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1.5-0.5*sin((sine+0.5)*10),-0.5-0.5*sin((sine+0.25)*10)),angles(1.5707963267948966-0.5235987755982988*sin(sine*10),0.08726646259971647,0)),deltaTime) 

                elseif mode == "Tornado" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(-0.5+5*sin(sine*4),0.5,5 * sin((sine+2)*4)),angles(1.5707963267948966+1.5707963267948966*sin(sine*4),1.5707963267948966*sin((sine+2)*4),-1.5707963267948966-1.5707963267948966*sin((sine+2)*4))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,-3-0.5*sin(sine*1),0),angles(-1.5707963267948966-0.08726646259971647*sin(sine*4),0.06981317007977318*sin((sine+2)*4),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5-6*sin((sine+2)*4),0,-6 * sin((sine+4)*4)),angles(1.5707963267948966+1.5707963267948966*sin((sine+2)*4),1.5707963267948966*sin((sine+4)*4),-1.5707963267948966-1.5707963267948966*sin((sine+4)*4))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.3 * sin((sine+2)*4),0.5 * sin(sine*1),0.3 * sin(sine*4)),angles(-1.5707963267948966+0.08726646259971647*sin(sine*4),-0.08726646259971647*sin((sine+2)*4),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5+6*sin((sine+2)*4),0,6 * sin((sine+4)*4)),angles(1.5707963267948966-1.5707963267948966*sin((sine+2)*4),-1.5707963267948966*sin((sine+4)*4),1.5707963267948966+1.5707963267948966*sin((sine+4)*4))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(0.5-5*sin(sine*4),0.5,-5 * sin((sine+2)*4)),angles(-1.5707963267948966+1.5707963267948966*sin(sine*4),-1.5707963267948966*sin((sine+2)*4),1.5707963267948966+1.5707963267948966*sin((sine+2)*1))),deltaTime) 

                elseif mode == "equinox" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.3 * sin(sine*5),0.3 * sin((sine+2)*5)),angles(-2.356194490192345-0.08726646259971647*sin((sine+1)*5),0,3.141592653589793+0.08726646259971647*sin(sine*2.5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7,0.3),angles(-0.5235987755982988-0.17453292519943295*sin((sine+4)*5),0.3490658503988659,0)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.5+0.3*sin((sine+1)*5),-0.3),angles(-0.5235987755982988+0.17453292519943295*sin(sine*5),-0.3490658503988659,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976-0.08726646259971647*sin(sine*5),0,3.141592653589793-0.08726646259971647*sin(sine*2.5))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.17453292519943295*sin((sine+2)*5))),deltaTime) 

                elseif mode == "Bacon God" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.3 * sin(sine*5),0.3 * sin((sine+2)*5)),angles(-2.356194490192345-0.08726646259971647*sin((sine+1)*5),0,3.141592653589793+0.08726646259971647*sin(sine*2.5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7,0.3),angles(-0.5235987755982988-0.17453292519943295*sin((sine+4)*5),0.3490658503988659,0)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.5+0.3*sin((sine+1)*5),-0.3),angles(-0.5235987755982988+0.17453292519943295*sin(sine*5),-0.3490658503988659,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976-0.08726646259971647*sin(sine*5),0,3.141592653589793-0.08726646259971647*sin(sine*2.5))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.17453292519943295*sin((sine+2)*5))),deltaTime) 

                elseif mode == "ERRAH" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4-0.1*sin(sine*2.5),1,-0.8),angles(1.7453292519943295+0.17453292519943295*sin(sine*5),0.5235987755982988+0.3490658503988659*sin(sine*2.5),-0.17453292519943295*sin((sine+1)*2.5))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-2.0943951023931953+0.5235987755982988*sin(sine*105),-0.17453292519943295+0.5235987755982988*sin(sine*106),3.141592653589793+0.5235987755982988*sin(sine*107))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,-0.5),angles(0.6981317007977318-0.17453292519943295*sin((sine+1)*2.5),-0.3490658503988659+0.17453292519943295*sin((sine+1)*2.5),-0.17453292519943295+0.08726646259971647*sin(sine*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,1+0.1*sin((sine+1)*2.5),-0.8),angles(2.0943951023931953-0.17453292519943295*sin(sine*105),0.6981317007977318+0.17453292519943295*sin(sine*106),1.2217304763960306+0.17453292519943295*sin(sine*107))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.3 * sin(sine*2.5),2+0.3*sin(sine*5),0.2 * sin(sine*2.5)),angles(2.0943951023931953-0.17453292519943295*sin((sine+1)*5),0.17453292519943295*sin(sine*2.5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*2.5),0.1 * sin(sine*5)),angles(0.5235987755982988-0.2617993877991494*sin((sine+1)*2.5),0.3490658503988659,-0.17453292519943295-0.08726646259971647*sin(sine*5))),deltaTime) 

                elseif mode == "Dragged away" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4-0.1*sin(sine*2.5),0.5,0.8),angles(-2.443460952792061+0.2617993877991494*sin((sine+1)*5),0.5235987755982988+0.3490658503988659*sin(sine*2.5),0.3490658503988659*sin(sine*2.5))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-2.0943951023931953,-0.17453292519943295+0.08726646259971647*sin(sine*5),3.141592653589793+0.3490658503988659*sin(sine*5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,-0.5),angles(0.6981317007977318+0.3490658503988659*sin((sine+1)*5),-0.3490658503988659+0.17453292519943295*sin((sine+1)*2.5),-0.17453292519943295-0.08726646259971647*sin(sine*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.7+0.1*sin((sine+1)*2.5),-0.5),angles(1.0471975511965976-0.17453292519943295*sin(sine*5),-0.5235987755982988+0.17453292519943295*sin(sine*5),-0.3490658503988659+0.17453292519943295*sin(sine*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.2 * sin(sine*2.5),-1.7+0.1*sin(sine*5),0.2 * sin(sine*2.5)),angles(-2.0943951023931953+0.2617993877991494*sin((sine+1)*5),0.17453292519943295*sin(sine*2.5),0)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*2.5),0.1 * sin(sine*5)),angles(0.8726646259971648+0.3490658503988659*sin((sine+1)*5),0.3490658503988659,-0.17453292519943295-0.08726646259971647*sin(sine*5))),deltaTime) 

                elseif mode == "siezrure funnier" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(174532.90774614044*sin(sine*1),1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1),3.141592653589793+174532.90774614044*sin(sine*1))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(174532.90774614044*sin(sine*1),1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(174532.90774614044*sin(sine*1),-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(1 * sin(sine*25),1+3*sin(sine*20),1 * sin(sine*17)),angles(-1.5707963267948966-174532.90774614044*sin(sine*1),-174532.90774614044*sin(sine*1),3.141592653589793-174532.90774614044*sin(sine*1))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(174532.90774614044*sin(sine*1),-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 

                elseif mode == "siezrure 2" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.5,-0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),0.3490658503988659*sin(sine*53))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),3.141592653589793+0.3490658503988659*sin(sine*53))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),0.3490658503988659*sin(sine*53))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.5,-0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*53),0.3490658503988659*sin(sine*52))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-2.5,0),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),3.141592653589793+0.3490658503988659*sin(sine*53))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1,0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*53),0.3490658503988659*sin(sine*53))),deltaTime) 

                elseif mode == "Sonic" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.8+0.2*sin((sine+1)*20),0.3+0.3*sin((sine+1)*40),0),angles(-0.8726646259971648+0.3490658503988659*sin((sine+1)*40),-0.3490658503988659-0.5235987755982988*sin((sine+1)*20),0.5235987755982988)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976-0.08726646259971647*sin(sine*40),-0.17453292519943295*sin(sine*20),3.141592653589793-0.17453292519943295*sin(sine*20))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.5*sin((sine+0.5)*20),0.3-0.5*sin((sine+1)*20)),angles(1.7453292519943295*sin((sine+1)*20),0,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.8+0.2*sin((sine+1)*20),0.3+0.3*sin((sine+1)*40),0),angles(-0.8726646259971648+0.3490658503988659*sin((sine+1)*40),0.3490658503988659-0.5235987755982988*sin((sine+1)*20),-0.5235987755982988)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.3 * sin(sine*40),0.5 * sin((sine+1)*40)),angles(-2.181661564992912-0.17453292519943295*sin((sine+1)*40),0.08726646259971647*sin(sine*20),3.141592653589793+0.17453292519943295*sin(sine*20))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.5*sin((sine+0.5)*20),0.3+0.5*sin((sine+1)*20)),angles(-1.7453292519943295*sin((sine+1)*20),0,0)),deltaTime) 

                elseif mode == "Twerk" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.2,0.5,-0.7),angles(0.6981317007977318-0.5235987755982988*sin(sine*20),0.3490658503988659,-0.5235987755982988+0.3490658503988659*sin(sine*20))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976,-0.3490658503988659*sin(sine*20),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.3,-1.5+0.3*sin(sine*20),0.3+0.3*sin(sine*10)),angles(1.2217304763960306,-0.17453292519943295,0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.2,0.5,-0.7),angles(0.6981317007977318+0.5235987755982988*sin(sine*20),-0.3490658503988659,0.5235987755982988+0.3490658503988659*sin(sine*20))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.3 * sin(sine*20),-0.6,0),angles(-2.2689280275926285+0.17453292519943295*sin(sine*10),0.17453292519943295*sin(sine*20),3.141592653589793+0.3490658503988659*sin(sine*20))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.3,-1.5-0.3*sin(sine*20),0.3+0.3*sin(sine*10)),angles(1.2217304763960306,0.17453292519943295,-0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 

                elseif mode == "Pogo Stick" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.5+0.3*sin((sine+1)*10),-0.5),angles(0,0,1.5707963267948966-0.5235987755982988*sin(sine*10))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.3490658503988659*sin(sine*10),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0,-1,0.5),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.5+0.3*sin((sine+1)*10),-0.5),angles(0,0,-1.5707963267948966+0.5235987755982988*sin(sine*10))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,1.2+2*sin((sine+1)*10),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(0,-1,0.5),deltaTime) 

                elseif mode == "fishy business" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(0,1.5707963267948966,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0,1.5707963267948966,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(10 * sin(sine*3),1+5*sin(sine*10),10 * sin(sine*5)),angles(-1.5707963267948966+1.7453292519943295*sin(sine*5),1.7453292519943295*sin(sine*3),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 

                elseif mode == "spaghetti" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(-0.5+1*sin((sine+1)*5),1.5,1 * sin((sine+2)*5)),angles(1.5707963267948966,1.5707963267948966,1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(3 * sin((sine+2)*5),5,3 * sin((sine+3)*5)),angles(-1.5707963267948966+0.3490658503988659*sin((sine+3)*5),0.3490658503988659*sin((sine+2)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5+1*sin((sine+1)*5),-1,1 * sin((sine+2)*5)),angles(0,1.5707963267948966,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(0.5+2*sin((sine+2)*5),4.5,2 * sin((sine+3)*5)),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(1 * sin(sine*5),2,1 * sin((sine+1)*5)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5+2*sin((sine+2)*5),-3,2 * sin((sine+3)*5)),angles(0,-1.5707963267948966,0)),deltaTime) 

                elseif mode == "Classic r6" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(2.6179938779914944+0.3490658503988659*sin((sine+1)*8),1.5707963267948966,0)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0,1.5707963267948966,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(2.6179938779914944+0.3490658503988659*sin(sine*8),-1.5707963267948966,0)),deltaTime) 

                elseif mode == "CHAOS" then
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.9198621771937625+0.08726646259971647*sin((sine+2)*5),0.17453292519943295*sin(sine*100),3.141592653589793+0.17453292519943295*sin(sine*99))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin(sine*2.5),0.2 * sin((sine+0.5)*2.5)),angles(0.17453292519943295-0.5235987755982988*sin((sine+0.5)*2.5),0,0)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4+0.1*sin(sine*2.5),0.3-0.3*sin(sine*2.5),-0.7+0.2*sin(sine*2.5)),angles(0.3490658503988659-0.5235987755982988*sin(sine*2.5),0.3490658503988659*sin(sine*101),0.17453292519943295*sin(sine*2.5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.4+0.1*sin(sine*2.5),0.3+0.3*sin(sine*2.5),-0.7-0.2*sin(sine*2.5)),angles(0.3490658503988659+0.5235987755982988*sin(sine*2.5),0.3490658503988659*sin(sine*100),0.17453292519943295*sin(sine*2.5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.2*sin(sine*2.5),-0.2 * sin((sine+0.5)*2.5)),angles(0.17453292519943295+0.5235987755982988*sin((sine+0.5)*2.5),0,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1 * sin(sine*5),0),angles(-1.9198621771937625,0,3.141592653589793)),deltaTime) 

                elseif mode == "Chase" then
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.8,0.5),angles(-0.5235987755982988,-0.08726646259971647,0.08726646259971647)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.3,1+0.3*sin((sine+1)*10),-0.5),angles(2.2689280275926285+0.2617993877991494*sin((sine+1)*20),-0.5235987755982988,-0.08726646259971647*sin((sine+1)*10))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.3,1-0.3*sin((sine+1)*10),-0.5),angles(2.2689280275926285+0.2617993877991494*sin((sine+1)*20),0.5235987755982988,-0.08726646259971647*sin((sine+1)*10))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.8,0.5),angles(-0.5235987755982988,0.08726646259971647,-0.08726646259971647)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(angles(-2.443460952792061,0.17453292519943295*sin(sine*10),3.141592653589793+0.3490658503988659*sin(sine*10)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.2217304763960306+0.17453292519943295*sin((sine+2)*20),0.3490658503988659*sin((sine+1)*10),3.141592653589793-0.17453292519943295*sin(sine*10))),deltaTime) 
                elseif mode == "AMOGUS" then 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.05-0.1*sin(sine*5),-0.1 * sin((sine+1)*5)),angles(-1.9198621771937625+0.08726646259971647*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.1*sin(sine*5),0.5),angles(0.5235987755982988-0.3490658503988659*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,-0.4-0.1*sin((sine+1)*5),-0.5+0.05*sin((sine+2)*5)),angles(-1.9198621771937625-0.08726646259971647*sin((sine+2)*5),0,3.141592653589793)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.25,0.4-0.05*sin((sine+1)*5),0.5),angles(0.08726646259971647,0.17453292519943295,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.25,0.4-0.05*sin((sine+1)*5),0.5),angles(0.08726646259971647,-0.17453292519943295,0)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*5),0.5),angles(0.5235987755982988-0.3490658503988659*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 

                elseif mode == "Scared" then 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.08726646259971647*sin(sine*5),-0.2617993877991494*sin(sine*50),3.141592653589793+0.5235987755982988*sin(sine*1))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin(sine*50),-0.1 * sin(sine*5),-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),0.08726646259971647*sin(sine*50),3.141592653589793+0.08726646259971647*sin(sine*55))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1+0.1*sin(sine*50),0.5+0.1*sin(sine*52),-0.5+0.1*sin(sine*54)),angles(1.3962634015954636,-0.17453292519943295,-1.3962634015954636)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*5),0.5),angles(0.08726646259971647*sin((sine+1)*5),0.08726646259971647+0.08726646259971647*sin(sine*55),-0.08726646259971647+0.08726646259971647*sin(sine*50))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1+0.1*sin(sine*52),0.5+0.1*sin(sine*50),-0.6+0.1*sin(sine*54)),angles(1.2217304763960306+0.17453292519943295*sin(sine*5),0.17453292519943295,0.8726646259971648)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.4,-1+0.1*sin(sine*5),0.5),angles(0.08726646259971647*sin((sine+1)*5),-0.08726646259971647+0.08726646259971647*sin(sine*55),0.08726646259971647+0.08726646259971647*sin(sine*50))),deltaTime) 
                elseif mode == "Laugh" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.15+0.15*sin(sine*10),0.5),angles(-0.7853981633974483,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7-0.1*sin(sine*10),0.5+0.1*sin(sine*10)),angles(-0.7853981633974483,0,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976,0,3.141592653589793)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.6-0.05*sin(sine*10),0.1 * sin(sine*10),-0.2+0.05*sin(sine*10)),angles(-0.8726646259971648,0.17453292519943295+0.08726646259971647*sin(sine*10),-0.17453292519943295-0.08726646259971647*sin(sine*10))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,0.7+0.1*sin(sine*10),-0.5),angles(2.9670597283903604+0.05235987755982989*sin((sine+0.5)*10),0.17453292519943295+0.05235987755982989*sin(sine*10),-0.9599310885968813)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.7-0.1*sin(sine*10),0.5+0.1*sin(sine*10)),angles(-0.7853981633974483,0,0)),deltaTime) 

                elseif mode == "mayhem" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1+0.1*sin((sine+2)*5),0.2,-1+0.1*sin((sine+2)*5)),angles(0.3490658503988659-0.2617993877991494*sin((sine+2)*5),0.5235987755982988-0.17453292519943295*sin((sine+2)*5),-0.17453292519943295+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.3962634015954636-0.08726646259971647*sin(sine*5),0.08726646259971647-0.08726646259971647*sin(sine*5),3.3161255787892263+0.2617993877991494*sin(sine*100))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.4,-1-0.3*sin(sine*5),0.7 * sin((sine+1)*5)),angles(-0.5934119456780721-0.15707963267948966*sin((sine+1)*5),-0.3490658503988659,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1.3-0.3*sin((sine+1)*5),-0.5+0.1*sin((sine+1)*5)),angles(2.6179938779914944+0.17453292519943295*sin((sine+1)*5),0.8726646259971648,0.8726646259971648-0.2617993877991494*sin((sine+1)*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin((sine+1)*5),-0.3+0.2*sin(sine*5),0.2 * sin((sine+1)*5)),angles(-1.9198621771937625+0.08726646259971647*sin((sine+1)*5),-0.08726646259971647+0.08726646259971647*sin((sine+1)*5),2.792526803190927)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5-0.1*sin((sine+1)*5),-0.7,-0.3-0.2*sin(sine*5)),angles(-0.17453292519943295+0.5934119456780721*sin(sine*5),0.3490658503988659,-0.17453292519943295)),deltaTime) 

                elseif mode == "reverse ragdoll" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966-0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966+0.5235987755982988*sin((sine+3)*5),-1.5707963267948966)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.5 * sin((sine+3)*5),0,-0.5 * sin((sine+2)*5)),angles(-1.5707963267948966+0.5235987755982988*sin((sine+2)*5),0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 

                elseif mode == "ragdoll" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966-0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.5235987755982988*sin((sine+2)*5),0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966+0.5235987755982988*sin((sine+3)*5),-1.5707963267948966)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.5 * sin((sine+1)*5),0,0.5 * sin(sine*5)),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),-0.08726646259971647*sin((sine+2)*5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 


                end
                else  
                    if mode == "Emoter" then
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5+0.2*sin((sine+0.1)*5),0.5-0.3*sin((sine+0.1)*5),-0.5+0.3*sin((sine+0.1)*5)),angles(0.17453292519943295-0.6981317007977318*sin((sine+0.1)*5),-0.3490658503988659*sin((sine+0.1)*5),0.17453292519943295+0.17453292519943295*sin((sine+0.1)*5))),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.4835298641951802+0.08726646259971647*sin(sine*10),-0.08726646259971647*sin((sine+1)*5),3.141592653589793+0.08726646259971647*sin(sine*5))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.85+0.3*sin((sine+1)*5),0.1+0.2*sin(sine*5)),angles(-0.6981317007977318*sin(sine*5),0.08726646259971647,-0.08726646259971647*sin(sine*5))),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.85-0.3*sin((sine+1)*5),0.1-0.2*sin(sine*5)),angles(0.6981317007977318*sin(sine*5),-0.08726646259971647,-0.08726646259971647*sin(sine*5))),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5+0.2*sin((sine+0.1)*5),0.5+0.3*sin((sine+0.1)*5),-0.5-0.3*sin((sine+0.1)*5)),angles(0.17453292519943295+0.6981317007977318*sin((sine+0.1)*5),-0.3490658503988659*sin((sine+0.1)*5),-0.17453292519943295+0.17453292519943295*sin((sine+0.1)*5))),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.1 * sin(sine*10),0),angles(-1.8325957145940461+0.10471975511965978*sin((sine+1)*10),-0.05235987755982989*sin(sine*5),3.141592653589793-0.08726646259971647*sin(sine*5))),deltaTime) 
                    elseif mode == "spaghetti" then

                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(-0.5+1*sin((sine+1)*5),1.5,1 * sin((sine+2)*5)),angles(1.5707963267948966,1.5707963267948966,1.5707963267948966)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(3 * sin((sine+2)*5),5,3 * sin((sine+3)*5)),angles(-1.5707963267948966+0.3490658503988659*sin((sine+3)*5),0.3490658503988659*sin((sine+2)*5),3.141592653589793)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5+1*sin((sine+1)*5),-1,1 * sin((sine+2)*5)),angles(0,1.5707963267948966,0)),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(0.5+2*sin((sine+2)*5),4.5,2 * sin((sine+3)*5)),angles(0,-1.5707963267948966,0)),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(1 * sin(sine*5),2,1 * sin((sine+1)*5)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5+2*sin((sine+2)*5),-3,2 * sin((sine+3)*5)),angles(0,-1.5707963267948966,0)),deltaTime) 

                    elseif mode == "Wave" then 

                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5+0.3*sin((sine+1)*10),1.3-0.3*sin((sine+1)*10),0.5),angles(3.141592653589793,0,0.6981317007977318-0.6981317007977318*sin((sine+3)*10))),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(0,0,-0.3490658503988659-0.08726646259971647*sin((sine+1)*5))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.45,-1-0.05*sin(sine*5),0.5),angles(0,0.08726646259971647,-0.13962634015954636+0.08726646259971647*sin(sine*5))),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.45,-1.1+0.05*sin(sine*5),0.5),angles(0,-0.08726646259971647,-0.05235987755982989+0.08726646259971647*sin(sine*5))),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin(sine*5),0,0),angles(-1.5707963267948966,-0.08726646259971647+0.08726646259971647*sin(sine*5),3.141592653589793)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,-0.17453292519943295+0.17453292519943295*sin((sine+1)*5),3.141592653589793)),deltaTime) 

                    elseif mode == "No" then 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0.3490658503988659*sin((sine+1)*5),3.141592653589793-0.8726646259971648*sin((sine+1)*5))),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4-0.2*sin((sine+3)*5),-0.5),angles(-0.5235987755982988*sin((sine+3)*5),0,-0.17453292519943295)),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4+0.2*sin((sine+3)*5),-0.5),angles(0.5235987755982988*sin((sine+3)*5),0,0.17453292519943295)),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5,-1,0.5),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cf(0.5,-1,0.5),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.4 * sin(sine*5),0,0),angles(-1.5707963267948966,0.17453292519943295*sin(sine*5),3.141592653589793-0.5235987755982988*sin(sine*5))),deltaTime) 
                    elseif mode == "Yes" then 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.5235987755982988*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4-0.2*sin((sine+2)*5),-0.5),angles(-0.3490658503988659*sin((sine+2)*5),0,-0.17453292519943295)),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4-0.2*sin((sine+2)*5),-0.5),angles(-0.3490658503988659*sin((sine+2)*5),0,0.17453292519943295)),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5,-1,0.5),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cf(0.5,-1,0.5),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0,0.5 * sin(sine*5)),angles(-1.5707963267948966+0.17453292519943295*sin(sine*5),0,3.141592653589793)),deltaTime) 

                    elseif mode == "Point" then 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),0.08726646259971647-0.08726646259971647*sin(sine*5),2.792526803190927)),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.2 * sin((sine+1)*5),-0.05+0.1*sin(sine*5),0),angles(-1.5707963267948966,-0.08726646259971647+0.05235987755982989*sin((sine+1)*5),3.490658503988659)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5+0.1*sin((sine+1)*5),-1-0.1*sin(sine*5),0.5),angles(0,-0.08726646259971647,0.05235987755982989-0.05235987755982989*sin((sine+1)*5))),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.6,0.5+0.1*sin(sine*5),-0.3),angles(-0.17453292519943295,0.3490658503988659,-0.3490658503988659+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.1*sin(sine*5),0.5),angles(0,0.08726646259971647,-0.08726646259971647-0.03490658503988659*sin((sine+1)*5))),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,1,-0.5+0.2*sin(sine*5)),angles(1.3962634015954636+0.08726646259971647*sin((sine+1)*5),0.5235987755982988+0.08726646259971647*sin(sine*5),0.3490658503988659)),deltaTime) 

                    elseif mode == "equinox" then
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.3 * sin(sine*5),0.3 * sin((sine+2)*5)),angles(-2.356194490192345-0.08726646259971647*sin((sine+1)*5),0,3.141592653589793+0.08726646259971647*sin(sine*2.5))),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7,0.3),angles(-0.5235987755982988-0.17453292519943295*sin((sine+4)*5),0.3490658503988659,0)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.5+0.3*sin((sine+1)*5),-0.3),angles(-0.5235987755982988+0.17453292519943295*sin(sine*5),-0.3490658503988659,0)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976-0.08726646259971647*sin(sine*5),0,3.141592653589793-0.08726646259971647*sin(sine*2.5))),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.17453292519943295*sin((sine+2)*5))),deltaTime) 

                    elseif mode == "Tornado" then
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(-0.5+5*sin(sine*4),0.5,5 * sin((sine+2)*4)),angles(1.5707963267948966+1.5707963267948966*sin(sine*4),1.5707963267948966*sin((sine+2)*4),-1.5707963267948966-1.5707963267948966*sin((sine+2)*4))),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,-3-0.5*sin(sine*1),0),angles(-1.5707963267948966-0.08726646259971647*sin(sine*4),0.06981317007977318*sin((sine+2)*4),3.141592653589793)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5-6*sin((sine+2)*4),0,-6 * sin((sine+4)*4)),angles(1.5707963267948966+1.5707963267948966*sin((sine+2)*4),1.5707963267948966*sin((sine+4)*4),-1.5707963267948966-1.5707963267948966*sin((sine+4)*4))),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.3 * sin((sine+2)*4),0.5 * sin(sine*1),0.3 * sin(sine*4)),angles(-1.5707963267948966+0.08726646259971647*sin(sine*4),-0.08726646259971647*sin((sine+2)*4),3.141592653589793)),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5+6*sin((sine+2)*4),0,6 * sin((sine+4)*4)),angles(1.5707963267948966-1.5707963267948966*sin((sine+2)*4),-1.5707963267948966*sin((sine+4)*4),1.5707963267948966+1.5707963267948966*sin((sine+4)*4))),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(0.5-5*sin(sine*4),0.5,-5 * sin((sine+2)*4)),angles(-1.5707963267948966+1.5707963267948966*sin(sine*4),-1.5707963267948966*sin((sine+2)*4),1.5707963267948966+1.5707963267948966*sin((sine+2)*1))),deltaTime) 

                    elseif mode == "Bacon God" then
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.3 * sin(sine*5),0.3 * sin((sine+2)*5)),angles(-2.356194490192345-0.08726646259971647*sin((sine+1)*5),0,3.141592653589793+0.08726646259971647*sin(sine*2.5))),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7,0.3),angles(-0.5235987755982988-0.17453292519943295*sin((sine+4)*5),0.3490658503988659,0)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.5+0.3*sin((sine+1)*5),-0.3),angles(-0.5235987755982988+0.17453292519943295*sin(sine*5),-0.3490658503988659,0)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976-0.08726646259971647*sin(sine*5),0,3.141592653589793-0.08726646259971647*sin(sine*2.5))),deltaTime) 
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.7,0.4-0.3*sin((sine+2)*5),-0.2 * sin((sine+1)*5)),angles(-0.17453292519943295-0.3490658503988659*sin((sine+1)*5),-0.5235987755982988+0.3490658503988659*sin((sine+1)*5),0.5235987755982988-0.17453292519943295*sin((sine+2)*5))),deltaTime) 

                    elseif mode == "Dragged away" then
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4-0.1*sin(sine*2.5),0.5,0.8),angles(-2.443460952792061+0.2617993877991494*sin((sine+1)*5),0.5235987755982988+0.3490658503988659*sin(sine*2.5),0.3490658503988659*sin(sine*2.5))),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-2.0943951023931953,-0.17453292519943295+0.08726646259971647*sin(sine*5),3.141592653589793+0.3490658503988659*sin(sine*5))),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,-0.5),angles(0.6981317007977318+0.3490658503988659*sin((sine+1)*5),-0.3490658503988659+0.17453292519943295*sin((sine+1)*2.5),-0.17453292519943295-0.08726646259971647*sin(sine*5))),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.7+0.1*sin((sine+1)*2.5),-0.5),angles(1.0471975511965976-0.17453292519943295*sin(sine*5),-0.5235987755982988+0.17453292519943295*sin(sine*5),-0.3490658503988659+0.17453292519943295*sin(sine*5))),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.2 * sin(sine*2.5),-1.7+0.1*sin(sine*5),0.2 * sin(sine*2.5)),angles(-2.0943951023931953+0.2617993877991494*sin((sine+1)*5),0.17453292519943295*sin(sine*2.5),0)),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*2.5),0.1 * sin(sine*5)),angles(0.8726646259971648+0.3490658503988659*sin((sine+1)*5),0.3490658503988659,-0.17453292519943295-0.08726646259971647*sin(sine*5))),deltaTime) 

                    elseif mode == "Creature" then
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,1.5-0.5*sin((sine+0.5)*10),-1+0.5*sin((sine+0.25)*10)),angles(1.5707963267948966-0.7853981633974483*sin((sine+0.5)*10),0,0)),deltaTime) 
                        Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1.5,-0.5),angles(0.17453292519943295*sin((sine+1)*20),0,3.141592653589793)),deltaTime) 
                        RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1.5+0.5*sin((sine+0.5)*10),-0.5+0.5*sin((sine+0.25)*10)),angles(1.5707963267948966+0.5235987755982988*sin(sine*10),-0.08726646259971647,0)),deltaTime) 
                        LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,1.5+0.5*sin((sine+0.5)*10),-1-0.5*sin((sine+0.25)*10)),angles(1.5707963267948966+0.7853981633974483*sin((sine+0.5)*10),0,0)),deltaTime) 
                        RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.6+0.2*sin(sine*20),-0.1 * sin(sine*20)),angles(-3.141592653589793+0.08726646259971647*sin((sine+0.5)*20),0,3.141592653589793)),deltaTime) 
                        LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1.5-0.5*sin((sine+0.5)*10),-0.5-0.5*sin((sine+0.25)*10)),angles(1.5707963267948966-0.5235987755982988*sin(sine*10),0.08726646259971647,0)),deltaTime) 

                    elseif mode == "ERRAH" then
                        RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4-0.1*sin(sine*2.5),1,-0.8),angles(1.7453292519943295+0.17453292519943295*sin(sine*5),0.5235987755982988+0.3490658503988659*sin(sine*2.5),-0.17453292519943295*sin((sine+1)*2.5))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-2.0943951023931953+0.5235987755982988*sin(sine*105),-0.17453292519943295+0.5235987755982988*sin(sine*106),3.141592653589793+0.5235987755982988*sin(sine*107))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,-0.5),angles(0.6981317007977318-0.17453292519943295*sin((sine+1)*2.5),-0.3490658503988659+0.17453292519943295*sin((sine+1)*2.5),-0.17453292519943295+0.08726646259971647*sin(sine*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,1+0.1*sin((sine+1)*2.5),-0.8),angles(2.0943951023931953-0.17453292519943295*sin(sine*105),0.6981317007977318+0.17453292519943295*sin(sine*106),1.2217304763960306+0.17453292519943295*sin(sine*107))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.3 * sin(sine*2.5),2+0.3*sin(sine*5),0.2 * sin(sine*2.5)),angles(2.0943951023931953-0.17453292519943295*sin((sine+1)*5),0.17453292519943295*sin(sine*2.5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.1*sin(sine*2.5),0.1 * sin(sine*5)),angles(0.5235987755982988-0.2617993877991494*sin((sine+1)*2.5),0.3490658503988659,-0.17453292519943295-0.08726646259971647*sin(sine*5))),deltaTime) 
                    
                elseif mode == "siezrure funnier" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(174532.90774614044*sin(sine*1),1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1),3.141592653589793+174532.90774614044*sin(sine*1))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(174532.90774614044*sin(sine*1),1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(174532.90774614044*sin(sine*1),-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(1 * sin(sine*25),1+3*sin(sine*20),1 * sin(sine*17)),angles(-1.5707963267948966-174532.90774614044*sin(sine*1),-174532.90774614044*sin(sine*1),3.141592653589793-174532.90774614044*sin(sine*1))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(174532.90774614044*sin(sine*1),-1.5707963267948966+174532.90774614044*sin(sine*1),174532.90774614044*sin(sine*1))),deltaTime) 
                    
                elseif mode == "siezrure 2" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.5,-0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),0.3490658503988659*sin(sine*53))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),3.141592653589793+0.3490658503988659*sin(sine*53))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1,0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),0.3490658503988659*sin(sine*53))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.5,-0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*53),0.3490658503988659*sin(sine*52))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-2.5,0),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*52),3.141592653589793+0.3490658503988659*sin(sine*53))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1,0.5),angles(0.3490658503988659*sin(sine*51),0.3490658503988659*sin(sine*53),0.3490658503988659*sin(sine*53))),deltaTime) 
                    
                elseif mode == "Sonic" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.8+0.2*sin((sine+1)*20),0.3+0.3*sin((sine+1)*40),0),angles(-0.8726646259971648+0.3490658503988659*sin((sine+1)*40),-0.3490658503988659-0.5235987755982988*sin((sine+1)*20),0.5235987755982988)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976-0.08726646259971647*sin(sine*40),-0.17453292519943295*sin(sine*20),3.141592653589793-0.17453292519943295*sin(sine*20))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.5*sin((sine+0.5)*20),0.3-0.5*sin((sine+1)*20)),angles(1.7453292519943295*sin((sine+1)*20),0,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.8+0.2*sin((sine+1)*20),0.3+0.3*sin((sine+1)*40),0),angles(-0.8726646259971648+0.3490658503988659*sin((sine+1)*40),0.3490658503988659-0.5235987755982988*sin((sine+1)*20),-0.5235987755982988)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.3 * sin(sine*40),0.5 * sin((sine+1)*40)),angles(-2.181661564992912-0.17453292519943295*sin((sine+1)*40),0.08726646259971647*sin(sine*20),3.141592653589793+0.17453292519943295*sin(sine*20))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.5*sin((sine+0.5)*20),0.3+0.5*sin((sine+1)*20)),angles(-1.7453292519943295*sin((sine+1)*20),0,0)),deltaTime) 
                    
                elseif mode == "Pogo Stick" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.5+0.3*sin((sine+1)*10),-0.5),angles(0,0,1.5707963267948966-0.5235987755982988*sin(sine*10))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.3490658503988659*sin(sine*10),0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0,-1,0.5),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.5+0.3*sin((sine+1)*10),-0.5),angles(0,0,-1.5707963267948966+0.5235987755982988*sin(sine*10))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,1.2+2*sin((sine+1)*10),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(0,-1,0.5),deltaTime) 
                    
                elseif mode == "fishy business" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(0,1.5707963267948966,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(0,1.5707963267948966,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(10 * sin(sine*3),1+5*sin(sine*10),10 * sin(sine*5)),angles(-1.5707963267948966+1.7453292519943295*sin(sine*5),1.7453292519943295*sin(sine*3),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
                    
                elseif mode == "CHAOS" then
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.9198621771937625+0.08726646259971647*sin((sine+2)*5),0.17453292519943295*sin(sine*100),3.141592653589793+0.17453292519943295*sin(sine*99))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin(sine*2.5),0.2 * sin((sine+0.5)*2.5)),angles(0.17453292519943295-0.5235987755982988*sin((sine+0.5)*2.5),0,0)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4+0.1*sin(sine*2.5),0.3-0.3*sin(sine*2.5),-0.7+0.2*sin(sine*2.5)),angles(0.3490658503988659-0.5235987755982988*sin(sine*2.5),0.3490658503988659*sin(sine*101),0.17453292519943295*sin(sine*2.5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.4+0.1*sin(sine*2.5),0.3+0.3*sin(sine*2.5),-0.7-0.2*sin(sine*2.5)),angles(0.3490658503988659+0.5235987755982988*sin(sine*2.5),0.3490658503988659*sin(sine*100),0.17453292519943295*sin(sine*2.5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1-0.2*sin(sine*2.5),-0.2 * sin((sine+0.5)*2.5)),angles(0.17453292519943295+0.5235987755982988*sin((sine+0.5)*2.5),0,0)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1 * sin(sine*5),0),angles(-1.9198621771937625,0,3.141592653589793)),deltaTime) 
                    
                elseif mode == "mayhem" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1+0.1*sin((sine+2)*5),0.2,-1+0.1*sin((sine+2)*5)),angles(0.3490658503988659-0.2617993877991494*sin((sine+2)*5),0.5235987755982988-0.17453292519943295*sin((sine+2)*5),-0.17453292519943295+0.17453292519943295*sin((sine+2)*5))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.3962634015954636-0.08726646259971647*sin(sine*5),0.08726646259971647-0.08726646259971647*sin(sine*5),3.3161255787892263+0.2617993877991494*sin(sine*100))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.4,-1-0.3*sin(sine*5),0.7 * sin((sine+1)*5)),angles(-0.5934119456780721-0.15707963267948966*sin((sine+1)*5),-0.3490658503988659,0)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1.3-0.3*sin((sine+1)*5),-0.5+0.1*sin((sine+1)*5)),angles(2.6179938779914944+0.17453292519943295*sin((sine+1)*5),0.8726646259971648,0.8726646259971648-0.2617993877991494*sin((sine+1)*5))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.1 * sin((sine+1)*5),-0.3+0.2*sin(sine*5),0.2 * sin((sine+1)*5)),angles(-1.9198621771937625+0.08726646259971647*sin((sine+1)*5),-0.08726646259971647+0.08726646259971647*sin((sine+1)*5),2.792526803190927)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5-0.1*sin((sine+1)*5),-0.7,-0.3-0.2*sin(sine*5)),angles(-0.17453292519943295+0.5934119456780721*sin(sine*5),0.3490658503988659,-0.17453292519943295)),deltaTime) 
                    
                elseif mode == "Chase" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.3,1+0.3*sin((sine+1)*10),-0.5+0.4*sin(sine*10)),angles(2.0943951023931953+0.3490658503988659*sin((sine+1)*10),-0.5235987755982988-0.5235987755982988*sin((sine+1)*10),-0.08726646259971647*sin((sine+1)*10))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.8-0.5*sin((sine+3)*10),0.3 * sin((sine+1)*10)),angles(0.17453292519943295-1.2217304763960306*sin((sine+1)*10),0.08726646259971647-0.17453292519943295*sin(sine*10),-0.08726646259971647+0.17453292519943295*sin(sine*10))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.2217304763960306+0.17453292519943295*sin((sine+2)*20),0.3490658503988659*sin((sine+1)*10),3.141592653589793-0.17453292519943295*sin(sine*10))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.8+0.5*sin((sine+3)*10),-0.3 * sin((sine+1)*10)),angles(1.2217304763960306*sin((sine+1)*10),-0.08726646259971647-0.17453292519943295*sin(sine*10),0.08726646259971647+0.17453292519943295*sin(sine*10))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,0.3 * sin(sine*20),0.2 * sin(sine*20)),angles(-2.0943951023931953-0.17453292519943295*sin((sine+1)*20),0.08726646259971647*sin(sine*10),3.141592653589793+0.17453292519943295*sin(sine*10))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.3,1-0.3*sin((sine+1)*10),-0.5-0.4*sin(sine*10)),angles(2.0943951023931953-0.3490658503988659*sin((sine+1)*10),0.5235987755982988-0.5235987755982988*sin((sine+1)*10),-0.08726646259971647*sin((sine+1)*10))),deltaTime) 
                elseif mode == "Scared" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,1-0.3*sin(sine*20),0.5),angles(3.490658503988659+0.3490658503988659*sin(sine*20),0.3490658503988659,0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.3962634015954636-0.17453292519943295*sin((sine+1)*20),-0.17453292519943295*sin(sine*10),3.141592653589793-0.17453292519943295*sin(sine*10))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,1-0.3*sin(sine*20),0.5),angles(3.490658503988659+0.3490658503988659*sin((sine+1)*20),-0.3490658503988659,-0.3490658503988659-0.3490658503988659*sin(sine*20))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.2 * sin((sine+1)*10),0.5 * sin(sine*20),-0.3 * sin((sine+1)*20)),angles(-1.2217304763960306-0.17453292519943295*sin((sine+1)*20),-0.17453292519943295*sin((sine+1)*10),3.141592653589793+0.17453292519943295*sin((sine+1)*10))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.9+0.6*sin(sine*10),0.3+1*sin((sine+2)*10)),angles(-0.3490658503988659-1.7453292519943295*sin(sine*10),0.17453292519943295*sin(sine*10),0.08726646259971647)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.9-0.6*sin(sine*10),0.3-1*sin((sine+2)*10)),angles(-0.3490658503988659+1.7453292519943295*sin(sine*10),0.08726646259971647+0.08726646259971647*sin(sine*10),-0.08726646259971647)),deltaTime) 
                
                elseif mode == "AMOGUS" then 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1 * sin(sine*10),0.1 * sin((sine+0.5)*10)),angles(-1.6580627893946132-0.08726646259971647*sin((sine+0.5)*10),0.08726646259971647*sin(sine*5),3.141592653589793+0.17453292519943295*sin(sine*5))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.8+0.3*sin((sine+2)*5),0.3+0.5*sin((sine+1)*5)),angles(-0.3490658503988659-0.6981317007977318*sin((sine+1)*5),-0.08726646259971647-0.17453292519943295*sin(sine*5),0.05235987755982989+0.08726646259971647*sin(sine*5))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,-0.4-0.1*sin((sine+0.5)*10),-0.5+0.05*sin((sine+1)*10)),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*10),0.08726646259971647*sin((sine+1)*5),3.141592653589793-0.17453292519943295*sin(sine*5))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.25,0.4+0.07*sin((sine+1)*5),0.5),angles(0.08726646259971647,0.17453292519943295,0.17453292519943295*sin((sine+1)*5))),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.25,0.4-0.07*sin((sine+1)*5),0.5),angles(0.08726646259971647,-0.17453292519943295,0.17453292519943295*sin((sine+1)*5))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.8-0.3*sin((sine+2)*5),0.3-0.5*sin((sine+1)*5)),angles(-0.3490658503988659+0.6981317007977318*sin((sine+1)*5),0.08726646259971647-0.17453292519943295*sin(sine*5),-0.05235987755982989+0.08726646259971647*sin(sine*5))),deltaTime) 
                    
                elseif mode == "Laugh" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.15+0.15*sin(sine*10),0.5),angles(-0.7853981633974483,0,3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-0.7-0.1*sin(sine*10),0.5+0.1*sin(sine*10)),angles(-0.7853981633974483,0,0)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976,0,3.141592653589793)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.6-0.05*sin(sine*10),0.1 * sin(sine*10),-0.2+0.05*sin(sine*10)),angles(-0.8726646259971648,0.17453292519943295+0.08726646259971647*sin(sine*10),-0.17453292519943295-0.08726646259971647*sin(sine*10))),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.4,0.7+0.1*sin(sine*10),-0.5),angles(2.9670597283903604+0.05235987755982989*sin((sine+0.5)*10),0.17453292519943295+0.05235987755982989*sin(sine*10),-0.9599310885968813)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-0.7-0.1*sin(sine*10),0.5+0.1*sin(sine*10)),angles(-0.7853981633974483,0,0)),deltaTime) 
                    
                elseif mode == "reverse ragdoll" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966-0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966+0.5235987755982988*sin((sine+3)*5),-1.5707963267948966)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(-0.5 * sin((sine+3)*5),0,-0.5 * sin((sine+2)*5)),angles(-1.5707963267948966+0.5235987755982988*sin((sine+2)*5),0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    
                elseif mode == "ragdoll" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.5,0),angles(-1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966-0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.5707963267948966+0.5235987755982988*sin((sine+2)*5),0.5235987755982988*sin((sine+3)*5),3.141592653589793)),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),1.5707963267948966+0.5235987755982988*sin((sine+3)*5),-1.5707963267948966)),deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.5,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.5 * sin((sine+1)*5),0,0.5 * sin(sine*5)),angles(-1.5707963267948966-0.08726646259971647*sin((sine+1)*5),-0.08726646259971647*sin((sine+2)*5),3.141592653589793)),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1,-1,0),angles(1.5707963267948966-0.5235987755982988*sin((sine+2)*5),-1.5707963267948966+0.5235987755982988*sin((sine+3)*5),1.5707963267948966)),deltaTime) 
                    
    
                end


            end
        end)

    end)


    Reanimate:CreateDropdown("Random Animations", Random, function(RandomModes)
    mode = RandomModes
    if not R6reanimated then 
        Message("Error:", "Please Reanimate", 5)
        return 
    end

    
    AnimationActive = false
    StopAnim = true

    if connection then
        connection:Disconnect()
        connection = nil
    end

    
    local character = plr.Character or plr.CharacterAdded:Wait()
    local humanoid = character:FindFirstChild("Humanoid")
    local animate = character:FindFirstChild("Animate")
    
    if humanoid then
        local animator = humanoid:FindFirstChild("Animator")
        if animator then animator:Destroy() end
        humanoid.AutomaticScalingEnabled = false
    end

    if animate then
        animate.Enabled = false
    end

    
    local joints = {
        ["Torso"] = character.HumanoidRootPart:FindFirstChild("RootJoint"),
        ["Right Arm"] = character.Torso:FindFirstChild("Right Shoulder"),
        ["Left Arm"] = character.Torso:FindFirstChild("Left Shoulder"),
        ["Head"] = character.Torso:FindFirstChild("Neck"),
        ["Left Leg"] = character.Torso:FindFirstChild("Left Hip"),
        ["Right Leg"] = character.Torso:FindFirstChild("Right Hip")
    }

    local cf = CFrame.new
    local originalCFrames = {
        ["Torso"] = { C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
        ["Right Arm"] = { C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0), C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0) },
        ["Left Arm"] = { C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
        ["Head"] = { C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
        ["Left Leg"] = { C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
        ["Right Leg"] = { C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0), C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0) }
    }

    for jointName, joint in pairs(joints) do
        if joint then
            joint.C0 = originalCFrames[jointName].C0
            joint.C1 = originalCFrames[jointName].C1
            joint.Transform = CFrame.new() 
        end
    end

    
    local newAnimator = Instance.new("Animator")
    newAnimator.Parent = humanoid
    wait(0.05)
    StopAnim = false
    AnimationActive = true
    if animate then
        animate.Enabled = true
        local defaultAnimId = "http://www.roblox.com/asset/?id=180435571"
        animate.idle.Animation1.AnimationId = defaultAnimId
        animate.idle.Animation2.AnimationId = defaultAnimId
        animate.walk:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
        animate.run:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
        animate.jump:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
        animate.fall:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
    end
        wait(0.1)
    
        local character = plr.Character or plr.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
        local RootJoint = HumanoidRootPart["RootJoint"]
        local RightShoulder = character.Torso["Right Shoulder"]
        local LeftShoulder = character.Torso["Left Shoulder"]
        local Neck = character.Torso["Neck"]
        local LeftHip = character.Torso["Left Hip"]
        local RightHip = character.Torso["Right Hip"]
        
    if plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid:FindFirstChild("Animator") then
        plr.Character.Humanoid.Animator:Destroy()
    end
    if plr.Character:FindFirstChild("Animate") then
        plr.Character.Animate.Enabled = false
    end
        local animate = plr.Character:FindFirstChild("Animate")
    if animate then animate.Enabled = false end
            if connection then 
                connection:Disconnect()  
            end
        
        
            local runService = game:GetService("RunService")
            local sine = 0
        
            connection = runService.RenderStepped:Connect(function(deltaTime)
                sine += deltaTime * R67 / 1
                deltaTime = clamp(deltaTime * 10, 0, 1)
        
                local vel = HumanoidRootPart.Velocity
                local onGround = humanoid:GetState() == Enum.HumanoidStateType.Freefall
        local humanoidRootPartVelocity  = character:FindFirstChild("HumanoidRootPart").Velocity 
    
        
            if vel.Magnitude < 1 then 
                if mode == "goofy trolus" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), 2.792526803190927, 0.6981317007977318), deltaTime)
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), -2.792526803190927, -0.6981317007977318), deltaTime)
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.9198621771937625 - 0.10471975511965978 * sin((sine + 0.3) * 2), 0, 3.141592653589793), deltaTime)
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -2.45 - 0.05 * sin(sine * 2), 0) * euler(0.03490658503988659 * sin(sine * 2), 0, 3.141592653589793), deltaTime)
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), 1.3089969389957472, -0.9599310885968813), deltaTime)
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966 - 0.03490658503988659 * sin(sine * 2), -1.3089969389957472, 1.5707963267948966), deltaTime)
        elseif mode == "laying" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), -2.792526803190927, -0.6981317007977318), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), 2.792526803190927, 0.6981317007977318), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.9198621771937625 - 0.10471975511965978 * sin((sine + 0.3) * 2), 0, 3.141592653589793), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -2.45 - 0.05 * sin(sine * 2), 0) * euler(0.03490658503988659 * sin(sine * 2), 0, 3.141592653589793), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), 1.3089969389957472, -0.9599310885968813), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966 - 0.03490658503988659 * sin(sine * 2), -1.3089969389957472, 1.5707963267948966), deltaTime) 
                    
        elseif mode == "sit" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.9, 0.4 + 0.1 * sin(sine * 2), 0.3 - 0.15 * sin(sine * 2)) * euler(-1.0471975511965976 - 0.12217304763960307 * sin(sine * 2), -1.3962634015954636, -0.6981317007977318), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.85 - 0.1 * sin((sine + 0.2) * 2), 0) * euler(-1.3962634015954636 + 0.03490658503988659 * sin(sine * 2), -0.08726646259971647, 3.141592653589793), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.4 + 0.1 * sin(sine * 2), 0.2 - 0.15 * sin(sine * 2)) * euler(0.6108652381980153 - 0.12217304763960307 * sin(sine * 2), 1.2217304763960306, -0.7853981633974483), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.6580627893946132 - 0.03490658503988659 * sin((sine + 0.6) * 2), 0.10471975511965978 + 0.06981317007977318 * sin(sine * 0.66), 3.141592653589793 + 0.3490658503988659 * sin(sine * 0.66)), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, 0.2 + 0.15 * sin((sine + 0.2) * 2), -0.7 + 0.1 * sin(sine * 2)) * euler(1.4835298641951802 + 0.03490658503988659 * sin(sine * 2), 1.4835298641951802, -1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.75 + 0.1 * sin((sine + 0.2) * 2), -0.5) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), -1.6580627893946132, 0), deltaTime) 
                    
        elseif mode == "Back Handstand" then 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,-0.6981317007977318,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.65+0.03*sin(sine*3),0),angles(-0.22689280275926285+0.017453292519943295*sin(sine*3),-15.707963267948966,3.141592653589793)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,1.0471975511965976,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,1.2217304763960306,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,-1.2217304763960306,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-0.5235987755982988,0.17453292519943295*sin(sine*1),3.141592653589793+0.5235987755982988*sin(sine*1))),deltaTime) 
        
        elseif mode == "rickroll" then
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.9 - 0.2 * sin(sine * 2), 0) * euler(1.5707963267948966, 1.6580627893946132 - 0.17453292519943295 * sin(sine + 0.8), -1.5707963267948966), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0.3 * sin(sine + 0.8), -0.1 + 0.2 * sin(sine * 2), 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.08726646259971647 * sin((sine - 0.5) * 2), 0.08726646259971647 * sin(sine - 1), -3.141592653589793 + 0.2617993877991494 * sin(sine * 5)), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1 + 0.1 * sin(sine * 7), 0.2 - 0.1 * sin(sine + 0.8), -0.25) * euler(1.5707963267948966 + 0.5235987755982988 * sin(sine * 7), -0.6981317007977318, 0.3490658503988659 * sin(sine * 7)), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.9 - 0.2 * sin(sine * 2), 0) * euler(1.5707963267948966, -1.6580627893946132 - 0.17453292519943295 * sin(sine + 0.8), 1.5707963267948966), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1 + 0.1 * sin(sine * 7), 0.2 + 0.1 * sin(sine + 0.8), -0.25) * euler(1.5707963267948966 - 0.5235987755982988 * sin(sine * 7), 0.6981317007977318, 0.3490658503988659 * sin(sine * 7)), deltaTime) 
                    
    
        elseif mode == "wave" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.5, 0) * euler(1.5707963267948966, -1.6580627893946132 + 0.08726646259971647 * sin((sine - 0.3) * 4), 1.5707963267948966), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1 + 0.15 * sin((sine - 0.4) * 4), 1.42, 0) * euler(1.5707963267948966, 1.4835298641951802 - 0.3490658503988659 * sin((sine - 0.4) * 4), 1.5707963267948966), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.4835298641951802, 0.04363323129985824 - 0.08726646259971647 * sin((sine + 0.1) * 4), -3.141592653589793 + 0.04363323129985824 * sin(sine * 4)), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0.1 * sin(sine * 4), 0, 0) * euler(-1.5707963267948966, -0.08726646259971647 + 0.08726646259971647 * sin(sine * 4), -3.141592653589793), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1.1 + 0.1 * sin(sine * 4), 0) * euler(1.5707963267948966, 1.5707963267948966 + 0.08726646259971647 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1 - 0.02 * sin(sine * 4), -0.925 - 0.07 * sin(sine * 4), 0) * euler(1.5707963267948966, -1.7453292519943295 + 0.08726646259971647 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                    
    
        elseif mode == "dab" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.5, 0.5, 0) * euler(-1.7453292519943295, 0.17453292519943295 - 0.04363323129985824 * sin(sine * 2), -1.4835298641951802), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.9000000953674316 - 0.1 * sin(sine * 2), 0) * euler(-1.3962634015954636, 1.3962634015954636, 1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1.0000001192092896 - 0.1 * sin(sine * 2), 0) * euler(-1.5707963267948966, -1.3962634015954636, -1.5707963267948966), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-2.0943951023931953 + 0.08726646259971647 * sin((sine - 1) * 2), -0.08726646259971647, 2.792526803190927), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 1.2000000476837158, 0) * euler(2.6179938779914944 + 0.08726646259971647 * sin((sine - 1) * 2), 0.6981317007977318, -1.3962634015954636), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.1 * sin(sine * 2), 0) * euler(-1.6580627893946132, 0.08726646259971647, 3.0543261909900767), deltaTime) 
                    
    
        elseif mode == "blaze" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.75 + 0.25 * sin(sine * 2), 0) * euler(-1.5707963267948966, 0, 3.141592653589793), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1.5 - 0.1 * sin((sine + 0.2) * 2), 0) * euler(-1.5707963267948966 - 0.08726646259971647 * sin((sine + 0.4) * 2), 0, 3.141592653589793 + 0.3490658503988659 * sin(sine * 0.66)), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5 - 1 * sin((sine + 0.2) * 2.2), -0.75 - 0.25 * sin(sine * 2), 1 * sin((sine + 0.95) * 2.2)) * euler(0, -1.5707963267948966, 0), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0.5 + 1 * sin((sine + 0.2) * 2.2), -0.75 - 0.25 * sin(sine * 2), -1 * sin((sine + 0.95) * 2.2)) * euler(0, 1.5707963267948966, 0), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(-0.5 - 1.85 * sin(sine * 2), 0.8 - 0.5 * sin(sine * 2), -1.85 * sin((sine + 0.75) * 2)) * euler(0, 1.5707963267948966, 0), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(0.5 + 1.85 * sin(sine * 2), 0.8 - 0.5 * sin(sine * 2), 1.85 * sin((sine + 0.75) * 2)) * euler(0, -1.5707963267948966, 0), deltaTime) 
                    
    
        elseif mode == "T" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1.5, 0.5, 0) * euler(1.5707963267948966, 3.141592653589793, -1.5707963267948966), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(0, 1.5707963267948966, 0), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.5, 0.5, 0) * euler(1.5707963267948966, 3.141592653589793, 1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(0, -1.5707963267948966, 0), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                    
    
        elseif mode == "float" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.5, 0) * euler(-1.7453292519943295, 1.5707963267948966 + 0.17453292519943295 * sin((sine + 1) * 2), 1.5707963267948966), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(1 * sin(sine * 2), 2 + 0.5 * sin(sine * 1), 0) * euler(-1.3962634015954636, 0.08726646259971647 * sin(sine * 2), 3.141592653589793), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.3962634015954636, -1.5707963267948966 + 0.08726646259971647 * sin((sine + 2) * 2), 1.5707963267948966), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.5, 0) * euler(1.3962634015954636, -1.5707963267948966 - 0.17453292519943295 * sin((sine + 1) * 2), 1.5707963267948966), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636, 1.5707963267948966 + 0.08726646259971647 * sin((sine + 2) * 2), -1.5707963267948966), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.0471975511965976 + 0.17453292519943295 * sin((sine + 1) * 1), -0.17453292519943295 * sin((sine + 0.5) * 2), 3.141592653589793 + 0.17453292519943295 * sin((sine + 0.2) * 2)), deltaTime) 
                    
    
        elseif mode == "floss" then
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.04363323129985824 * sin((sine + 0.125) * 16), -0.2617993877991494 * sin((sine + 0.05) * 8), -3.141592653589793 + 0.5235987755982988 * sin(sine * 1.1)), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.9 + 0.4 * sin(sine * 8), 0.5, -0.5 * sin((sine - 0.35) * 4)) * euler(1.5707963267948966 + 0.6981317007977318 * sin(sine * 4), 1.5707963267948966 + 0.8726646259971648 * sin(sine * 8), -1.5707963267948966 + 0.17453292519943295 * sin((sine - 0.35) * 4)), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(-0.1 * sin((sine + 0.4) * 8), 0, 0) * euler(-1.5707963267948966, 0.3490658503988659 * sin(sine * 8), -3.141592653589793), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.4 * sin((sine - 0.01) * 8), 0) * euler(1.5707963267948966, -1.7453292519943295 + 0.5235987755982988 * sin(sine * 8), 1.5707963267948966), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.4 * sin((sine - 0.01) * 8), 0) * euler(1.5707963267948966, 1.7453292519943295 + 0.5235987755982988 * sin(sine * 8), -1.5707963267948966), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.9 + 0.4 * sin(sine * 8), 0.5, 0.5 * sin((sine + 0.25) * 4)) * euler(1.5707963267948966, -1.5707963267948966 + 0.8726646259971648 * sin(sine * 8), 1.5707963267948966 + 0.6981317007977318 * sin((sine + 0.25) * 4)), deltaTime) 
                    
    
        elseif mode == "emote" then
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, -0.4363323129985824 * sin(sine * 8), -3.141592653589793), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.3 * sin(sine * 8), 0) * euler(1.5707963267948966, 1.5707963267948966 + 0.5235987755982988 * sin(sine * 8), -1.5707963267948966), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.5, 1, 0) * euler(-0.5235987755982988, -1.5707963267948966 - 0.5235987755982988 * sin(sine * 8), 3.141592653589793), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.5, 1, 0) * euler(-0.5235987755982988, 1.5707963267948966 - 0.5235987755982988 * sin(sine * 8), 3.141592653589793), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(-0.1 * sin(sine * 8), 0.2 * sin((sine + 0.1) * 16), 0) * euler(-1.5707963267948966, 0.2617993877991494 * sin(sine * 8), -3.141592653589793), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.3 * sin(sine * 8), 0) * euler(1.5707963267948966, -1.5707963267948966 + 0.5235987755982988 * sin(sine * 8), 1.5707963267948966), deltaTime) 
                    
    
        elseif mode == "pushups" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1.2 - 0.3 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), 0.4 - 0.6 * sin(sine * 4)) * euler(3.0543261909900767 - 0.17453292519943295 * sin(sine * 4), 1.3962634015954636 + 0.17453292519943295 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, 0, 3.141592653589793), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966, -1.3962634015954636, 1.5707963267948966), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.5707963267948966, 1.3962634015954636, -1.5707963267948966), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.99 + 0.5 * sin(sine * 4), 0.15 * sin(sine * 4)) * euler(3.3161255787892263 + 0.17453292519943295 * sin(sine * 4), 0, 3.141592653589793), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.2 + 0.3 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), 0.4 - 0.6 * sin(sine * 4)) * euler(3.0543261909900767 - 0.17453292519943295 * sin(sine * 4), -1.3962634015954636 - 0.17453292519943295 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                    
    
        elseif mode == "kazotsky" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.8 + 0.1 * sin(sine * 4), 0.5 - 0.15 * sin(sine * 4), -0.2) * euler(3.141592653589793 + 0.17453292519943295 * sin((sine + 0.6) * 8), -0.17453292519943295, 1.5707963267948966 - 0.08726646259971647 * sin(sine * 4)), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -0.5 + 0.3 * sin((sine + 0.25) * 8), 0) * euler(-1.3962634015954636 + 0.08726646259971647 * sin((sine + 0.5) * 8), 0.08726646259971647 * sin((sine + 0.1) * 4), 3.141592653589793), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.8 + 0.1 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), -0.2) * euler(3.141592653589793 + 0.17453292519943295 * sin((sine + 0.6) * 8), 0.17453292519943295, -1.5707963267948966 - 0.08726646259971647 * sin(sine * 4)), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.6580627893946132 - 0.08726646259971647 * sin((sine + 0.5) * 8), -0.08726646259971647 * sin((sine + 0.2) * 4), 3.141592653589793), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.5 - 0.5 * sin((sine + 0.6) * 8), -0.5) * euler(1.7453292519943295 + 1.0471975511965976 * sin(sine * 4), 1.5707963267948966 + 0.2617993877991494 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.5 - 0.5 * sin((sine + 0.6) * 8), -0.5) * euler(1.7453292519943295 - 1.0471975511965976 * sin(sine * 4), -1.5707963267948966 + 0.017453292519943295 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                    
    
        elseif mode == "L" then
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.04363323129985824 * sin((sine + 0.1) * 1), -0.17453292519943295 * sin((sine + 0.1) * 5), -3.141592653589793), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.2 * sin(sine * 5), -0.2 + 0.2 * sin(sine * 5)) * euler(2.181661564992912 - 0.8726646259971648 * sin(sine * 5), 1.9198621771937625 - 0.3490658503988659 * sin(sine * 5), -1.5707963267948966), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.7, 0.8, 0) * euler(1.0471975511965976 + 0.03490658503988659 * sin(sine * 10), 2.0943951023931953 + 0.10471975511965978 * sin((sine + 0.1) * 5), 1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.2 * sin(sine * 5), -0.2 - 0.2 * sin(sine * 5)) * euler(2.181661564992912 + 0.8726646259971648 * sin(sine * 5), -1.9198621771937625 - 0.3490658503988659 * sin(sine * 5), 1.5707963267948966), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.15 + 0.4 * sin((sine - 0.5) * 10), 0) * euler(-1.4835298641951802, 0.17453292519943295 * sin(sine * 5), -3.141592653589793), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.7, 0.5, -0.3) * euler(1.7453292519943295, -0.8726646259971648, 1.5707963267948966), deltaTime) 
                    
                elseif mode == "fe creepy crawler" then
                    Neck.C0 = Neck.C0:Lerp(cf(0, 0, 0.5) * euler(0.08726646259971647 * sin((sine + 20) * 0.05), 0, 3.141592653589793 + 0.3490658503988659 * sin((sine + -30) * 0.025)), 0.2) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.5 + 0.1 * sin(sine * 0.05), 0) * euler(3.141592653589793, 0, -3.1590459461097367 + 0.05235987755982989 * sin(sine * 0.025)), 0.2) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 1.5, -0.1 * sin(sine * 0.05)) * euler(1.5707963267948966, 0, 0.08726646259971647 * sin(sine * 0.025)), 0.2) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 1.5, -0.1 * sin(sine * 0.05)) * euler(1.5707963267948966, 0, 0.08726646259971647 * sin(sine * 0.025)), 0.2) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1.5, 0.5 + -0.1 * sin((sine + 10) * 0.05)) * euler(1.5707963267948966, 0, 0.08726646259971647 * sin(sine * 0.025)), 0.2) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1.5, 0.5 + -0.1 * sin((sine + 10) * 0.05)) * euler(1.5707963267948966, 0, 0.08726646259971647 * sin(sine * 0.025)), 0.2) 
    end
        elseif vel.Y > 1 then 
            if mode == "goofy trolus" then
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), 2.792526803190927, 0.6981317007977318), deltaTime)
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), -2.792526803190927, -0.6981317007977318), deltaTime)
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.9198621771937625 - 0.10471975511965978 * sin((sine + 0.3) * 2), 0, 3.141592653589793), deltaTime)
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -2.45 - 0.05 * sin(sine * 2), 0) * euler(0.03490658503988659 * sin(sine * 2), 0, 3.141592653589793), deltaTime)
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), 1.3089969389957472, -0.9599310885968813), deltaTime)
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966 - 0.03490658503988659 * sin(sine * 2), -1.3089969389957472, 1.5707963267948966), deltaTime)
    elseif mode == "laying" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), -2.792526803190927, -0.6981317007977318), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), 2.792526803190927, 0.6981317007977318), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.9198621771937625 - 0.10471975511965978 * sin((sine + 0.3) * 2), 0, 3.141592653589793), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -2.45 - 0.05 * sin(sine * 2), 0) * euler(0.03490658503988659 * sin(sine * 2), 0, 3.141592653589793), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), 1.3089969389957472, -0.9599310885968813), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966 - 0.03490658503988659 * sin(sine * 2), -1.3089969389957472, 1.5707963267948966), deltaTime) 
                
    elseif mode == "sit" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.9, 0.4 + 0.1 * sin(sine * 2), 0.3 - 0.15 * sin(sine * 2)) * euler(-1.0471975511965976 - 0.12217304763960307 * sin(sine * 2), -1.3962634015954636, -0.6981317007977318), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.85 - 0.1 * sin((sine + 0.2) * 2), 0) * euler(-1.3962634015954636 + 0.03490658503988659 * sin(sine * 2), -0.08726646259971647, 3.141592653589793), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.4 + 0.1 * sin(sine * 2), 0.2 - 0.15 * sin(sine * 2)) * euler(0.6108652381980153 - 0.12217304763960307 * sin(sine * 2), 1.2217304763960306, -0.7853981633974483), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.6580627893946132 - 0.03490658503988659 * sin((sine + 0.6) * 2), 0.10471975511965978 + 0.06981317007977318 * sin(sine * 0.66), 3.141592653589793 + 0.3490658503988659 * sin(sine * 0.66)), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, 0.2 + 0.15 * sin((sine + 0.2) * 2), -0.7 + 0.1 * sin(sine * 2)) * euler(1.4835298641951802 + 0.03490658503988659 * sin(sine * 2), 1.4835298641951802, -1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.75 + 0.1 * sin((sine + 0.2) * 2), -0.5) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), -1.6580627893946132, 0), deltaTime) 
                
    elseif mode == "Back Handstand" then 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,-0.6981317007977318,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.65+0.03*sin(sine*3),0),angles(-0.22689280275926285+0.017453292519943295*sin(sine*3),-15.707963267948966,3.141592653589793)),deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,1.0471975511965976,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,1.2217304763960306,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,-1.2217304763960306,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-0.5235987755982988,0.17453292519943295*sin(sine*1),3.141592653589793+0.5235987755982988*sin(sine*1))),deltaTime) 
    
    elseif mode == "rickroll" then
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.9 - 0.2 * sin(sine * 2), 0) * euler(1.5707963267948966, 1.6580627893946132 - 0.17453292519943295 * sin(sine + 0.8), -1.5707963267948966), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0.3 * sin(sine + 0.8), -0.1 + 0.2 * sin(sine * 2), 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.08726646259971647 * sin((sine - 0.5) * 2), 0.08726646259971647 * sin(sine - 1), -3.141592653589793 + 0.2617993877991494 * sin(sine * 5)), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1 + 0.1 * sin(sine * 7), 0.2 - 0.1 * sin(sine + 0.8), -0.25) * euler(1.5707963267948966 + 0.5235987755982988 * sin(sine * 7), -0.6981317007977318, 0.3490658503988659 * sin(sine * 7)), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.9 - 0.2 * sin(sine * 2), 0) * euler(1.5707963267948966, -1.6580627893946132 - 0.17453292519943295 * sin(sine + 0.8), 1.5707963267948966), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1 + 0.1 * sin(sine * 7), 0.2 + 0.1 * sin(sine + 0.8), -0.25) * euler(1.5707963267948966 - 0.5235987755982988 * sin(sine * 7), 0.6981317007977318, 0.3490658503988659 * sin(sine * 7)), deltaTime) 
                

    elseif mode == "wave" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.5, 0) * euler(1.5707963267948966, -1.6580627893946132 + 0.08726646259971647 * sin((sine - 0.3) * 4), 1.5707963267948966), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1 + 0.15 * sin((sine - 0.4) * 4), 1.42, 0) * euler(1.5707963267948966, 1.4835298641951802 - 0.3490658503988659 * sin((sine - 0.4) * 4), 1.5707963267948966), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.4835298641951802, 0.04363323129985824 - 0.08726646259971647 * sin((sine + 0.1) * 4), -3.141592653589793 + 0.04363323129985824 * sin(sine * 4)), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0.1 * sin(sine * 4), 0, 0) * euler(-1.5707963267948966, -0.08726646259971647 + 0.08726646259971647 * sin(sine * 4), -3.141592653589793), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1.1 + 0.1 * sin(sine * 4), 0) * euler(1.5707963267948966, 1.5707963267948966 + 0.08726646259971647 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1 - 0.02 * sin(sine * 4), -0.925 - 0.07 * sin(sine * 4), 0) * euler(1.5707963267948966, -1.7453292519943295 + 0.08726646259971647 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                

    elseif mode == "dab" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.5, 0.5, 0) * euler(-1.7453292519943295, 0.17453292519943295 - 0.04363323129985824 * sin(sine * 2), -1.4835298641951802), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.9000000953674316 - 0.1 * sin(sine * 2), 0) * euler(-1.3962634015954636, 1.3962634015954636, 1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1.0000001192092896 - 0.1 * sin(sine * 2), 0) * euler(-1.5707963267948966, -1.3962634015954636, -1.5707963267948966), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-2.0943951023931953 + 0.08726646259971647 * sin((sine - 1) * 2), -0.08726646259971647, 2.792526803190927), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 1.2000000476837158, 0) * euler(2.6179938779914944 + 0.08726646259971647 * sin((sine - 1) * 2), 0.6981317007977318, -1.3962634015954636), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.1 * sin(sine * 2), 0) * euler(-1.6580627893946132, 0.08726646259971647, 3.0543261909900767), deltaTime) 
                

    elseif mode == "blaze" then
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.75 + 0.25 * sin(sine * 2), 0) * euler(-1.5707963267948966, 0, 3.141592653589793), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1.5 - 0.1 * sin((sine + 0.2) * 2), 0) * euler(-1.5707963267948966 - 0.08726646259971647 * sin((sine + 0.4) * 2), 0, 3.141592653589793 + 0.3490658503988659 * sin(sine * 0.66)), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5 - 1 * sin((sine + 0.2) * 2.2), -0.75 - 0.25 * sin(sine * 2), 1 * sin((sine + 0.95) * 2.2)) * euler(0, -1.5707963267948966, 0), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(0.5 + 1 * sin((sine + 0.2) * 2.2), -0.75 - 0.25 * sin(sine * 2), -1 * sin((sine + 0.95) * 2.2)) * euler(0, 1.5707963267948966, 0), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(-0.5 - 1.85 * sin(sine * 2), 0.8 - 0.5 * sin(sine * 2), -1.85 * sin((sine + 0.75) * 2)) * euler(0, 1.5707963267948966, 0), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(0.5 + 1.85 * sin(sine * 2), 0.8 - 0.5 * sin(sine * 2), 1.85 * sin((sine + 0.75) * 2)) * euler(0, -1.5707963267948966, 0), deltaTime) 
                

    elseif mode == "T" then
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1.5, 0.5, 0) * euler(1.5707963267948966, 3.141592653589793, -1.5707963267948966), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(0, 1.5707963267948966, 0), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.5, 0.5, 0) * euler(1.5707963267948966, 3.141592653589793, 1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(0, -1.5707963267948966, 0), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                

    elseif mode == "float" then
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.5, 0) * euler(-1.7453292519943295, 1.5707963267948966 + 0.17453292519943295 * sin((sine + 1) * 2), 1.5707963267948966), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(1 * sin(sine * 2), 2 + 0.5 * sin(sine * 1), 0) * euler(-1.3962634015954636, 0.08726646259971647 * sin(sine * 2), 3.141592653589793), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.3962634015954636, -1.5707963267948966 + 0.08726646259971647 * sin((sine + 2) * 2), 1.5707963267948966), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.5, 0) * euler(1.3962634015954636, -1.5707963267948966 - 0.17453292519943295 * sin((sine + 1) * 2), 1.5707963267948966), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636, 1.5707963267948966 + 0.08726646259971647 * sin((sine + 2) * 2), -1.5707963267948966), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.0471975511965976 + 0.17453292519943295 * sin((sine + 1) * 1), -0.17453292519943295 * sin((sine + 0.5) * 2), 3.141592653589793 + 0.17453292519943295 * sin((sine + 0.2) * 2)), deltaTime) 
                

    elseif mode == "floss" then
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.04363323129985824 * sin((sine + 0.125) * 16), -0.2617993877991494 * sin((sine + 0.05) * 8), -3.141592653589793 + 0.5235987755982988 * sin(sine * 1.1)), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.9 + 0.4 * sin(sine * 8), 0.5, -0.5 * sin((sine - 0.35) * 4)) * euler(1.5707963267948966 + 0.6981317007977318 * sin(sine * 4), 1.5707963267948966 + 0.8726646259971648 * sin(sine * 8), -1.5707963267948966 + 0.17453292519943295 * sin((sine - 0.35) * 4)), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(-0.1 * sin((sine + 0.4) * 8), 0, 0) * euler(-1.5707963267948966, 0.3490658503988659 * sin(sine * 8), -3.141592653589793), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.4 * sin((sine - 0.01) * 8), 0) * euler(1.5707963267948966, -1.7453292519943295 + 0.5235987755982988 * sin(sine * 8), 1.5707963267948966), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.4 * sin((sine - 0.01) * 8), 0) * euler(1.5707963267948966, 1.7453292519943295 + 0.5235987755982988 * sin(sine * 8), -1.5707963267948966), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.9 + 0.4 * sin(sine * 8), 0.5, 0.5 * sin((sine + 0.25) * 4)) * euler(1.5707963267948966, -1.5707963267948966 + 0.8726646259971648 * sin(sine * 8), 1.5707963267948966 + 0.6981317007977318 * sin((sine + 0.25) * 4)), deltaTime) 
                

    elseif mode == "emote" then
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, -0.4363323129985824 * sin(sine * 8), -3.141592653589793), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.3 * sin(sine * 8), 0) * euler(1.5707963267948966, 1.5707963267948966 + 0.5235987755982988 * sin(sine * 8), -1.5707963267948966), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.5, 1, 0) * euler(-0.5235987755982988, -1.5707963267948966 - 0.5235987755982988 * sin(sine * 8), 3.141592653589793), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.5, 1, 0) * euler(-0.5235987755982988, 1.5707963267948966 - 0.5235987755982988 * sin(sine * 8), 3.141592653589793), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(-0.1 * sin(sine * 8), 0.2 * sin((sine + 0.1) * 16), 0) * euler(-1.5707963267948966, 0.2617993877991494 * sin(sine * 8), -3.141592653589793), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.3 * sin(sine * 8), 0) * euler(1.5707963267948966, -1.5707963267948966 + 0.5235987755982988 * sin(sine * 8), 1.5707963267948966), deltaTime) 
                

    elseif mode == "pushups" then
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1.2 - 0.3 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), 0.4 - 0.6 * sin(sine * 4)) * euler(3.0543261909900767 - 0.17453292519943295 * sin(sine * 4), 1.3962634015954636 + 0.17453292519943295 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, 0, 3.141592653589793), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966, -1.3962634015954636, 1.5707963267948966), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.5707963267948966, 1.3962634015954636, -1.5707963267948966), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.99 + 0.5 * sin(sine * 4), 0.15 * sin(sine * 4)) * euler(3.3161255787892263 + 0.17453292519943295 * sin(sine * 4), 0, 3.141592653589793), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.2 + 0.3 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), 0.4 - 0.6 * sin(sine * 4)) * euler(3.0543261909900767 - 0.17453292519943295 * sin(sine * 4), -1.3962634015954636 - 0.17453292519943295 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                

    elseif mode == "kazotsky" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.8 + 0.1 * sin(sine * 4), 0.5 - 0.15 * sin(sine * 4), -0.2) * euler(3.141592653589793 + 0.17453292519943295 * sin((sine + 0.6) * 8), -0.17453292519943295, 1.5707963267948966 - 0.08726646259971647 * sin(sine * 4)), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -0.5 + 0.3 * sin((sine + 0.25) * 8), 0) * euler(-1.3962634015954636 + 0.08726646259971647 * sin((sine + 0.5) * 8), 0.08726646259971647 * sin((sine + 0.1) * 4), 3.141592653589793), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.8 + 0.1 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), -0.2) * euler(3.141592653589793 + 0.17453292519943295 * sin((sine + 0.6) * 8), 0.17453292519943295, -1.5707963267948966 - 0.08726646259971647 * sin(sine * 4)), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.6580627893946132 - 0.08726646259971647 * sin((sine + 0.5) * 8), -0.08726646259971647 * sin((sine + 0.2) * 4), 3.141592653589793), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.5 - 0.5 * sin((sine + 0.6) * 8), -0.5) * euler(1.7453292519943295 + 1.0471975511965976 * sin(sine * 4), 1.5707963267948966 + 0.2617993877991494 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.5 - 0.5 * sin((sine + 0.6) * 8), -0.5) * euler(1.7453292519943295 - 1.0471975511965976 * sin(sine * 4), -1.5707963267948966 + 0.017453292519943295 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                

    elseif mode == "L" then
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.04363323129985824 * sin((sine + 0.1) * 1), -0.17453292519943295 * sin((sine + 0.1) * 5), -3.141592653589793), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.2 * sin(sine * 5), -0.2 + 0.2 * sin(sine * 5)) * euler(2.181661564992912 - 0.8726646259971648 * sin(sine * 5), 1.9198621771937625 - 0.3490658503988659 * sin(sine * 5), -1.5707963267948966), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.7, 0.8, 0) * euler(1.0471975511965976 + 0.03490658503988659 * sin(sine * 10), 2.0943951023931953 + 0.10471975511965978 * sin((sine + 0.1) * 5), 1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.2 * sin(sine * 5), -0.2 - 0.2 * sin(sine * 5)) * euler(2.181661564992912 + 0.8726646259971648 * sin(sine * 5), -1.9198621771937625 - 0.3490658503988659 * sin(sine * 5), 1.5707963267948966), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.15 + 0.4 * sin((sine - 0.5) * 10), 0) * euler(-1.4835298641951802, 0.17453292519943295 * sin(sine * 5), -3.141592653589793), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.7, 0.5, -0.3) * euler(1.7453292519943295, -0.8726646259971648, 1.5707963267948966), deltaTime) 
                
            elseif mode == "goofy trolus" then
                Neck.C0 = Neck.C0:Lerp(cfMul(CFrame.new(0, 1, 0), angles(-1.5707963267948966 + 0.5235987755982988 * math.sin((sine + 0.45) * 8), 0, 3.141592653589793)), deltaTime)
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(CFrame.new(1, 0.5, 0), angles(2.0943951023931953 - 1.7453292519943295 * math.sin((sine - 0.1) * 4), 1.9198621771937625, -1.5707963267948966)), deltaTime)
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(CFrame.new(0, 0.25 + 0.5 * math.sin((sine - 0.125) * 8), 0), angles(-1.5707963267948966 + 0.17453292519943295 * math.sin(sine * 8), 0, 3.141592653589793)), deltaTime)
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(CFrame.new(-1, -1 - 1 * math.sin(sine * 4), 0), angles(1.5707963267948966 - 1.2217304763960306 * math.sin((sine - 0.15) * 4), -1.5707963267948966 - 0.6108652381980153 * math.sin((sine - 0.15) * 4), 1.5707963267948966)), deltaTime)
                RightHip.C0 = RightHip.C0:Lerp(cfMul(CFrame.new(1, -1 + 1 * math.sin(sine * 4), 0), angles(1.5707963267948966 + 1.2217304763960306 * math.sin((sine - 0.15) * 4), 1.5707963267948966 + 0.6108652381980153 * math.sin((sine - 0.15) * 4), -1.5707963267948966)), deltaTime)
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(CFrame.new(-1, 0.5, 0), angles(2.0943951023931953 + 1.7453292519943295 * math.sin((sine - 0.1) * 4), -1.7453292519943295, 1.5707963267948966)), deltaTime)
            elseif mode == "fe creepy crawler" then
                Neck.C0 = Neck.C0:Lerp(cf(0, 0, 0.5) * euler(0.17453292519943295, 0.03490658503988659 * sin((sine * 20 + 2.5) * 0.2), 3.141592653589793 + -0.17453292519943295 * sin((sine * 20 + -10) * 0.2)), 0.1) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.5, 0) * euler(3.0543261909900767, 0.08726646259971647 * sin((sine * 20 + 7.5) * 0.2), -3.1590459461097367 + -0.08726646259971647 * sin(sine * 20 * 0.2)), 0.1) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 1.5 + 0.5 * sin((sine * 20 + 10) * 0.2), 0.3 + 0.2 * sin((sine * 20 + -10) * 0.2)) * euler(1.6580627893946132 + 0.17453292519943295 * sin((sine * 20 + 15) * 0.2), 0, -0.08726646259971647 * sin(sine * 20 * 0.2)), 0.1) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 1.5 + 0.5 * sin((sine * 20 + -7.5) * 0.2), 0.3 + 0.2 * sin((sine * 20 + 5) * 0.2)) * euler(1.6580627893946132 + 0.17453292519943295 * sin(sine * 20 * 0.2), 0, -0.08726646259971647 * sin(sine * 20 * 0.2)), 0.1) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1.5 + 0.5 * sin((sine * 20 + -7.5) * 0.2), 0.5 + 0.2 * sin((sine * 20 + 5) * 0.2)) * euler(1.6580627893946132 + 0.17453292519943295 * sin(sine * 20 * 0.2), 0, 0.08726646259971647 * sin(sine * 20 * 0.2)), 0.1) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1.5 + 0.5 * sin((sine * 20 + 10) * 0.2), 0.5 + 0.2 * sin((sine * 20 + -7.5) * 0.2)) * euler(1.6580627893946132 + -0.17453292519943295 * sin(sine * 20 * 0.2), 0, -0.08726646259971647 * sin(sine * 20 * 0.2)), 0.1) 
    end
        elseif vel.Y < -1 then 
            if mode == "goofy trolus" then
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), 2.792526803190927, 0.6981317007977318), deltaTime)
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), -2.792526803190927, -0.6981317007977318), deltaTime)
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.9198621771937625 - 0.10471975511965978 * sin((sine + 0.3) * 2), 0, 3.141592653589793), deltaTime)
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -2.45 - 0.05 * sin(sine * 2), 0) * euler(0.03490658503988659 * sin(sine * 2), 0, 3.141592653589793), deltaTime)
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), 1.3089969389957472, -0.9599310885968813), deltaTime)
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966 - 0.03490658503988659 * sin(sine * 2), -1.3089969389957472, 1.5707963267948966), deltaTime)
    elseif mode == "laying" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), -2.792526803190927, -0.6981317007977318), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), 2.792526803190927, 0.6981317007977318), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.9198621771937625 - 0.10471975511965978 * sin((sine + 0.3) * 2), 0, 3.141592653589793), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -2.45 - 0.05 * sin(sine * 2), 0) * euler(0.03490658503988659 * sin(sine * 2), 0, 3.141592653589793), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), 1.3089969389957472, -0.9599310885968813), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966 - 0.03490658503988659 * sin(sine * 2), -1.3089969389957472, 1.5707963267948966), deltaTime) 
                
    elseif mode == "sit" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.9, 0.4 + 0.1 * sin(sine * 2), 0.3 - 0.15 * sin(sine * 2)) * euler(-1.0471975511965976 - 0.12217304763960307 * sin(sine * 2), -1.3962634015954636, -0.6981317007977318), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.85 - 0.1 * sin((sine + 0.2) * 2), 0) * euler(-1.3962634015954636 + 0.03490658503988659 * sin(sine * 2), -0.08726646259971647, 3.141592653589793), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.4 + 0.1 * sin(sine * 2), 0.2 - 0.15 * sin(sine * 2)) * euler(0.6108652381980153 - 0.12217304763960307 * sin(sine * 2), 1.2217304763960306, -0.7853981633974483), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.6580627893946132 - 0.03490658503988659 * sin((sine + 0.6) * 2), 0.10471975511965978 + 0.06981317007977318 * sin(sine * 0.66), 3.141592653589793 + 0.3490658503988659 * sin(sine * 0.66)), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, 0.2 + 0.15 * sin((sine + 0.2) * 2), -0.7 + 0.1 * sin(sine * 2)) * euler(1.4835298641951802 + 0.03490658503988659 * sin(sine * 2), 1.4835298641951802, -1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.75 + 0.1 * sin((sine + 0.2) * 2), -0.5) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), -1.6580627893946132, 0), deltaTime) 
                
    elseif mode == "Back Handstand" then 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,-0.6981317007977318,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.65+0.03*sin(sine*3),0),angles(-0.22689280275926285+0.017453292519943295*sin(sine*3),-15.707963267948966,3.141592653589793)),deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,1.0471975511965976,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,1.2217304763960306,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,-1.2217304763960306,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-0.5235987755982988,0.17453292519943295*sin(sine*1),3.141592653589793+0.5235987755982988*sin(sine*1))),deltaTime) 
    
    elseif mode == "rickroll" then
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.9 - 0.2 * sin(sine * 2), 0) * euler(1.5707963267948966, 1.6580627893946132 - 0.17453292519943295 * sin(sine + 0.8), -1.5707963267948966), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0.3 * sin(sine + 0.8), -0.1 + 0.2 * sin(sine * 2), 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.08726646259971647 * sin((sine - 0.5) * 2), 0.08726646259971647 * sin(sine - 1), -3.141592653589793 + 0.2617993877991494 * sin(sine * 5)), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1 + 0.1 * sin(sine * 7), 0.2 - 0.1 * sin(sine + 0.8), -0.25) * euler(1.5707963267948966 + 0.5235987755982988 * sin(sine * 7), -0.6981317007977318, 0.3490658503988659 * sin(sine * 7)), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.9 - 0.2 * sin(sine * 2), 0) * euler(1.5707963267948966, -1.6580627893946132 - 0.17453292519943295 * sin(sine + 0.8), 1.5707963267948966), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1 + 0.1 * sin(sine * 7), 0.2 + 0.1 * sin(sine + 0.8), -0.25) * euler(1.5707963267948966 - 0.5235987755982988 * sin(sine * 7), 0.6981317007977318, 0.3490658503988659 * sin(sine * 7)), deltaTime) 
                

    elseif mode == "wave" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.5, 0) * euler(1.5707963267948966, -1.6580627893946132 + 0.08726646259971647 * sin((sine - 0.3) * 4), 1.5707963267948966), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1 + 0.15 * sin((sine - 0.4) * 4), 1.42, 0) * euler(1.5707963267948966, 1.4835298641951802 - 0.3490658503988659 * sin((sine - 0.4) * 4), 1.5707963267948966), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.4835298641951802, 0.04363323129985824 - 0.08726646259971647 * sin((sine + 0.1) * 4), -3.141592653589793 + 0.04363323129985824 * sin(sine * 4)), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0.1 * sin(sine * 4), 0, 0) * euler(-1.5707963267948966, -0.08726646259971647 + 0.08726646259971647 * sin(sine * 4), -3.141592653589793), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1.1 + 0.1 * sin(sine * 4), 0) * euler(1.5707963267948966, 1.5707963267948966 + 0.08726646259971647 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1 - 0.02 * sin(sine * 4), -0.925 - 0.07 * sin(sine * 4), 0) * euler(1.5707963267948966, -1.7453292519943295 + 0.08726646259971647 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                

    elseif mode == "dab" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.5, 0.5, 0) * euler(-1.7453292519943295, 0.17453292519943295 - 0.04363323129985824 * sin(sine * 2), -1.4835298641951802), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.9000000953674316 - 0.1 * sin(sine * 2), 0) * euler(-1.3962634015954636, 1.3962634015954636, 1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1.0000001192092896 - 0.1 * sin(sine * 2), 0) * euler(-1.5707963267948966, -1.3962634015954636, -1.5707963267948966), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-2.0943951023931953 + 0.08726646259971647 * sin((sine - 1) * 2), -0.08726646259971647, 2.792526803190927), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 1.2000000476837158, 0) * euler(2.6179938779914944 + 0.08726646259971647 * sin((sine - 1) * 2), 0.6981317007977318, -1.3962634015954636), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.1 * sin(sine * 2), 0) * euler(-1.6580627893946132, 0.08726646259971647, 3.0543261909900767), deltaTime) 
                

    elseif mode == "blaze" then
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.75 + 0.25 * sin(sine * 2), 0) * euler(-1.5707963267948966, 0, 3.141592653589793), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1.5 - 0.1 * sin((sine + 0.2) * 2), 0) * euler(-1.5707963267948966 - 0.08726646259971647 * sin((sine + 0.4) * 2), 0, 3.141592653589793 + 0.3490658503988659 * sin(sine * 0.66)), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5 - 1 * sin((sine + 0.2) * 2.2), -0.75 - 0.25 * sin(sine * 2), 1 * sin((sine + 0.95) * 2.2)) * euler(0, -1.5707963267948966, 0), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(0.5 + 1 * sin((sine + 0.2) * 2.2), -0.75 - 0.25 * sin(sine * 2), -1 * sin((sine + 0.95) * 2.2)) * euler(0, 1.5707963267948966, 0), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(-0.5 - 1.85 * sin(sine * 2), 0.8 - 0.5 * sin(sine * 2), -1.85 * sin((sine + 0.75) * 2)) * euler(0, 1.5707963267948966, 0), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(0.5 + 1.85 * sin(sine * 2), 0.8 - 0.5 * sin(sine * 2), 1.85 * sin((sine + 0.75) * 2)) * euler(0, -1.5707963267948966, 0), deltaTime) 
                

    elseif mode == "T" then
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1.5, 0.5, 0) * euler(1.5707963267948966, 3.141592653589793, -1.5707963267948966), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(0, 1.5707963267948966, 0), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.5, 0.5, 0) * euler(1.5707963267948966, 3.141592653589793, 1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(0, -1.5707963267948966, 0), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                

    elseif mode == "float" then
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.5, 0) * euler(-1.7453292519943295, 1.5707963267948966 + 0.17453292519943295 * sin((sine + 1) * 2), 1.5707963267948966), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(1 * sin(sine * 2), 2 + 0.5 * sin(sine * 1), 0) * euler(-1.3962634015954636, 0.08726646259971647 * sin(sine * 2), 3.141592653589793), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.3962634015954636, -1.5707963267948966 + 0.08726646259971647 * sin((sine + 2) * 2), 1.5707963267948966), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.5, 0) * euler(1.3962634015954636, -1.5707963267948966 - 0.17453292519943295 * sin((sine + 1) * 2), 1.5707963267948966), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636, 1.5707963267948966 + 0.08726646259971647 * sin((sine + 2) * 2), -1.5707963267948966), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.0471975511965976 + 0.17453292519943295 * sin((sine + 1) * 1), -0.17453292519943295 * sin((sine + 0.5) * 2), 3.141592653589793 + 0.17453292519943295 * sin((sine + 0.2) * 2)), deltaTime) 
                

    elseif mode == "floss" then
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.04363323129985824 * sin((sine + 0.125) * 16), -0.2617993877991494 * sin((sine + 0.05) * 8), -3.141592653589793 + 0.5235987755982988 * sin(sine * 1.1)), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.9 + 0.4 * sin(sine * 8), 0.5, -0.5 * sin((sine - 0.35) * 4)) * euler(1.5707963267948966 + 0.6981317007977318 * sin(sine * 4), 1.5707963267948966 + 0.8726646259971648 * sin(sine * 8), -1.5707963267948966 + 0.17453292519943295 * sin((sine - 0.35) * 4)), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(-0.1 * sin((sine + 0.4) * 8), 0, 0) * euler(-1.5707963267948966, 0.3490658503988659 * sin(sine * 8), -3.141592653589793), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.4 * sin((sine - 0.01) * 8), 0) * euler(1.5707963267948966, -1.7453292519943295 + 0.5235987755982988 * sin(sine * 8), 1.5707963267948966), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.4 * sin((sine - 0.01) * 8), 0) * euler(1.5707963267948966, 1.7453292519943295 + 0.5235987755982988 * sin(sine * 8), -1.5707963267948966), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.9 + 0.4 * sin(sine * 8), 0.5, 0.5 * sin((sine + 0.25) * 4)) * euler(1.5707963267948966, -1.5707963267948966 + 0.8726646259971648 * sin(sine * 8), 1.5707963267948966 + 0.6981317007977318 * sin((sine + 0.25) * 4)), deltaTime) 
                

    elseif mode == "emote" then
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, -0.4363323129985824 * sin(sine * 8), -3.141592653589793), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.3 * sin(sine * 8), 0) * euler(1.5707963267948966, 1.5707963267948966 + 0.5235987755982988 * sin(sine * 8), -1.5707963267948966), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.5, 1, 0) * euler(-0.5235987755982988, -1.5707963267948966 - 0.5235987755982988 * sin(sine * 8), 3.141592653589793), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.5, 1, 0) * euler(-0.5235987755982988, 1.5707963267948966 - 0.5235987755982988 * sin(sine * 8), 3.141592653589793), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(-0.1 * sin(sine * 8), 0.2 * sin((sine + 0.1) * 16), 0) * euler(-1.5707963267948966, 0.2617993877991494 * sin(sine * 8), -3.141592653589793), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.3 * sin(sine * 8), 0) * euler(1.5707963267948966, -1.5707963267948966 + 0.5235987755982988 * sin(sine * 8), 1.5707963267948966), deltaTime) 
                

    elseif mode == "pushups" then
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1.2 - 0.3 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), 0.4 - 0.6 * sin(sine * 4)) * euler(3.0543261909900767 - 0.17453292519943295 * sin(sine * 4), 1.3962634015954636 + 0.17453292519943295 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, 0, 3.141592653589793), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966, -1.3962634015954636, 1.5707963267948966), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.5707963267948966, 1.3962634015954636, -1.5707963267948966), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.99 + 0.5 * sin(sine * 4), 0.15 * sin(sine * 4)) * euler(3.3161255787892263 + 0.17453292519943295 * sin(sine * 4), 0, 3.141592653589793), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.2 + 0.3 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), 0.4 - 0.6 * sin(sine * 4)) * euler(3.0543261909900767 - 0.17453292519943295 * sin(sine * 4), -1.3962634015954636 - 0.17453292519943295 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                

    elseif mode == "kazotsky" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.8 + 0.1 * sin(sine * 4), 0.5 - 0.15 * sin(sine * 4), -0.2) * euler(3.141592653589793 + 0.17453292519943295 * sin((sine + 0.6) * 8), -0.17453292519943295, 1.5707963267948966 - 0.08726646259971647 * sin(sine * 4)), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -0.5 + 0.3 * sin((sine + 0.25) * 8), 0) * euler(-1.3962634015954636 + 0.08726646259971647 * sin((sine + 0.5) * 8), 0.08726646259971647 * sin((sine + 0.1) * 4), 3.141592653589793), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.8 + 0.1 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), -0.2) * euler(3.141592653589793 + 0.17453292519943295 * sin((sine + 0.6) * 8), 0.17453292519943295, -1.5707963267948966 - 0.08726646259971647 * sin(sine * 4)), deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.6580627893946132 - 0.08726646259971647 * sin((sine + 0.5) * 8), -0.08726646259971647 * sin((sine + 0.2) * 4), 3.141592653589793), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.5 - 0.5 * sin((sine + 0.6) * 8), -0.5) * euler(1.7453292519943295 + 1.0471975511965976 * sin(sine * 4), 1.5707963267948966 + 0.2617993877991494 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.5 - 0.5 * sin((sine + 0.6) * 8), -0.5) * euler(1.7453292519943295 - 1.0471975511965976 * sin(sine * 4), -1.5707963267948966 + 0.017453292519943295 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                

    elseif mode == "L" then
                Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.04363323129985824 * sin((sine + 0.1) * 1), -0.17453292519943295 * sin((sine + 0.1) * 5), -3.141592653589793), deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.2 * sin(sine * 5), -0.2 + 0.2 * sin(sine * 5)) * euler(2.181661564992912 - 0.8726646259971648 * sin(sine * 5), 1.9198621771937625 - 0.3490658503988659 * sin(sine * 5), -1.5707963267948966), deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.7, 0.8, 0) * euler(1.0471975511965976 + 0.03490658503988659 * sin(sine * 10), 2.0943951023931953 + 0.10471975511965978 * sin((sine + 0.1) * 5), 1.5707963267948966), deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.2 * sin(sine * 5), -0.2 - 0.2 * sin(sine * 5)) * euler(2.181661564992912 + 0.8726646259971648 * sin(sine * 5), -1.9198621771937625 - 0.3490658503988659 * sin(sine * 5), 1.5707963267948966), deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.15 + 0.4 * sin((sine - 0.5) * 10), 0) * euler(-1.4835298641951802, 0.17453292519943295 * sin(sine * 5), -3.141592653589793), deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.7, 0.5, -0.3) * euler(1.7453292519943295, -0.8726646259971648, 1.5707963267948966), deltaTime) 
                
            elseif mode == "goofy trolus" then
                Neck.C0 = Neck.C0:Lerp(cfMul(CFrame.new(0, 1, 0), angles(-1.5707963267948966 + 0.5235987755982988 * math.sin((sine + 0.45) * 8), 0, 3.141592653589793)), deltaTime)
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(CFrame.new(1, 0.5, 0), angles(2.0943951023931953 - 1.7453292519943295 * math.sin((sine - 0.1) * 4), 1.9198621771937625, -1.5707963267948966)), deltaTime)
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(CFrame.new(0, 0.25 + 0.5 * math.sin((sine - 0.125) * 8), 0), angles(-1.5707963267948966 + 0.17453292519943295 * math.sin(sine * 8), 0, 3.141592653589793)), deltaTime)
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(CFrame.new(-1, -1 - 1 * math.sin(sine * 4), 0), angles(1.5707963267948966 - 1.2217304763960306 * math.sin((sine - 0.15) * 4), -1.5707963267948966 - 0.6108652381980153 * math.sin((sine - 0.15) * 4), 1.5707963267948966)), deltaTime)
                RightHip.C0 = RightHip.C0:Lerp(cfMul(CFrame.new(1, -1 + 1 * math.sin(sine * 4), 0), angles(1.5707963267948966 + 1.2217304763960306 * math.sin((sine - 0.15) * 4), 1.5707963267948966 + 0.6108652381980153 * math.sin((sine - 0.15) * 4), -1.5707963267948966)), deltaTime)
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(CFrame.new(-1, 0.5, 0), angles(2.0943951023931953 + 1.7453292519943295 * math.sin((sine - 0.1) * 4), -1.7453292519943295, 1.5707963267948966)), deltaTime)
        
            elseif mode == "fe creepy crawler" then
                Neck.C0 = Neck.C0:Lerp(cf(0, 0, 0.5) * euler(0, 0, 3.141592653589793), 0.2) 
                RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.4, 0) * euler(3.141592653589793, 0, -3.141592653589793), 0.2) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 1.5, 0.3) * euler(1.7453292519943295, 0, -0.17453292519943295), 0.2) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 1.5, 0.3) * euler(1.7453292519943295, 0, 0.17453292519943295), 0.2) 
                LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1.5, 0.8) * euler(1.3962634015954636, 0, -0.17453292519943295), 0.2) 
                RightHip.C0 = RightHip.C0:Lerp(cf(1, -1.5, 0.8) * euler(1.3962634015954636, 0, 0.17453292519943295), 0.2) 
                
            end
            else  
                if mode == "goofy trolus" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), 2.792526803190927, 0.6981317007977318), deltaTime)
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), -2.792526803190927, -0.6981317007977318), deltaTime)
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.9198621771937625 - 0.10471975511965978 * sin((sine + 0.3) * 2), 0, 3.141592653589793), deltaTime)
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -2.45 - 0.05 * sin(sine * 2), 0) * euler(0.03490658503988659 * sin(sine * 2), 0, 3.141592653589793), deltaTime)
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), 1.3089969389957472, -0.9599310885968813), deltaTime)
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966 - 0.03490658503988659 * sin(sine * 2), -1.3089969389957472, 1.5707963267948966), deltaTime)
        elseif mode == "laying" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), -2.792526803190927, -0.6981317007977318), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.75, -0.2) * euler(2.705260340591211 - 0.08726646259971647 * sin((sine + 0.1) * 2), 2.792526803190927, 0.6981317007977318), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.9198621771937625 - 0.10471975511965978 * sin((sine + 0.3) * 2), 0, 3.141592653589793), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -2.45 - 0.05 * sin(sine * 2), 0) * euler(0.03490658503988659 * sin(sine * 2), 0, 3.141592653589793), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), 1.3089969389957472, -0.9599310885968813), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966 - 0.03490658503988659 * sin(sine * 2), -1.3089969389957472, 1.5707963267948966), deltaTime) 
                    
        elseif mode == "sit" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.9, 0.4 + 0.1 * sin(sine * 2), 0.3 - 0.15 * sin(sine * 2)) * euler(-1.0471975511965976 - 0.12217304763960307 * sin(sine * 2), -1.3962634015954636, -0.6981317007977318), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.85 - 0.1 * sin((sine + 0.2) * 2), 0) * euler(-1.3962634015954636 + 0.03490658503988659 * sin(sine * 2), -0.08726646259971647, 3.141592653589793), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.4 + 0.1 * sin(sine * 2), 0.2 - 0.15 * sin(sine * 2)) * euler(0.6108652381980153 - 0.12217304763960307 * sin(sine * 2), 1.2217304763960306, -0.7853981633974483), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.6580627893946132 - 0.03490658503988659 * sin((sine + 0.6) * 2), 0.10471975511965978 + 0.06981317007977318 * sin(sine * 0.66), 3.141592653589793 + 0.3490658503988659 * sin(sine * 0.66)), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, 0.2 + 0.15 * sin((sine + 0.2) * 2), -0.7 + 0.1 * sin(sine * 2)) * euler(1.4835298641951802 + 0.03490658503988659 * sin(sine * 2), 1.4835298641951802, -1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.75 + 0.1 * sin((sine + 0.2) * 2), -0.5) * euler(1.3962634015954636 - 0.03490658503988659 * sin(sine * 2), -1.6580627893946132, 0), deltaTime) 
                    
        elseif mode == "Back Handstand" then 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,-0.6981317007977318,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.65+0.03*sin(sine*3),0),angles(-0.22689280275926285+0.017453292519943295*sin(sine*3),-15.707963267948966,3.141592653589793)),deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(0.7,1.2,0.9+0.04*sin(sine*3)),angles(-2.0943951023931953,1.0471975511965976,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,1.2217304763960306,-0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-1.3,-1.2,0.6+0.04*sin(sine*3)),angles(-1.5707963267948966,-1.2217304763960306,0.05235987755982989*sin(sine*0.4))),deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-0.5235987755982988,0.17453292519943295*sin(sine*1),3.141592653589793+0.5235987755982988*sin(sine*1))),deltaTime) 
        
        elseif mode == "rickroll" then
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.9 - 0.2 * sin(sine * 2), 0) * euler(1.5707963267948966, 1.6580627893946132 - 0.17453292519943295 * sin(sine + 0.8), -1.5707963267948966), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0.3 * sin(sine + 0.8), -0.1 + 0.2 * sin(sine * 2), 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.08726646259971647 * sin((sine - 0.5) * 2), 0.08726646259971647 * sin(sine - 1), -3.141592653589793 + 0.2617993877991494 * sin(sine * 5)), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1 + 0.1 * sin(sine * 7), 0.2 - 0.1 * sin(sine + 0.8), -0.25) * euler(1.5707963267948966 + 0.5235987755982988 * sin(sine * 7), -0.6981317007977318, 0.3490658503988659 * sin(sine * 7)), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.9 - 0.2 * sin(sine * 2), 0) * euler(1.5707963267948966, -1.6580627893946132 - 0.17453292519943295 * sin(sine + 0.8), 1.5707963267948966), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1 + 0.1 * sin(sine * 7), 0.2 + 0.1 * sin(sine + 0.8), -0.25) * euler(1.5707963267948966 - 0.5235987755982988 * sin(sine * 7), 0.6981317007977318, 0.3490658503988659 * sin(sine * 7)), deltaTime) 
                    
    
        elseif mode == "wave" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.5, 0) * euler(1.5707963267948966, -1.6580627893946132 + 0.08726646259971647 * sin((sine - 0.3) * 4), 1.5707963267948966), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1 + 0.15 * sin((sine - 0.4) * 4), 1.42, 0) * euler(1.5707963267948966, 1.4835298641951802 - 0.3490658503988659 * sin((sine - 0.4) * 4), 1.5707963267948966), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.4835298641951802, 0.04363323129985824 - 0.08726646259971647 * sin((sine + 0.1) * 4), -3.141592653589793 + 0.04363323129985824 * sin(sine * 4)), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0.1 * sin(sine * 4), 0, 0) * euler(-1.5707963267948966, -0.08726646259971647 + 0.08726646259971647 * sin(sine * 4), -3.141592653589793), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1.1 + 0.1 * sin(sine * 4), 0) * euler(1.5707963267948966, 1.5707963267948966 + 0.08726646259971647 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1 - 0.02 * sin(sine * 4), -0.925 - 0.07 * sin(sine * 4), 0) * euler(1.5707963267948966, -1.7453292519943295 + 0.08726646259971647 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                    
    
        elseif mode == "dab" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.5, 0.5, 0) * euler(-1.7453292519943295, 0.17453292519943295 - 0.04363323129985824 * sin(sine * 2), -1.4835298641951802), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.9000000953674316 - 0.1 * sin(sine * 2), 0) * euler(-1.3962634015954636, 1.3962634015954636, 1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1.0000001192092896 - 0.1 * sin(sine * 2), 0) * euler(-1.5707963267948966, -1.3962634015954636, -1.5707963267948966), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-2.0943951023931953 + 0.08726646259971647 * sin((sine - 1) * 2), -0.08726646259971647, 2.792526803190927), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 1.2000000476837158, 0) * euler(2.6179938779914944 + 0.08726646259971647 * sin((sine - 1) * 2), 0.6981317007977318, -1.3962634015954636), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.1 * sin(sine * 2), 0) * euler(-1.6580627893946132, 0.08726646259971647, 3.0543261909900767), deltaTime) 
                    
    
        elseif mode == "blaze" then
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.75 + 0.25 * sin(sine * 2), 0) * euler(-1.5707963267948966, 0, 3.141592653589793), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1.5 - 0.1 * sin((sine + 0.2) * 2), 0) * euler(-1.5707963267948966 - 0.08726646259971647 * sin((sine + 0.4) * 2), 0, 3.141592653589793 + 0.3490658503988659 * sin(sine * 0.66)), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-0.5 - 1 * sin((sine + 0.2) * 2.2), -0.75 - 0.25 * sin(sine * 2), 1 * sin((sine + 0.95) * 2.2)) * euler(0, -1.5707963267948966, 0), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(0.5 + 1 * sin((sine + 0.2) * 2.2), -0.75 - 0.25 * sin(sine * 2), -1 * sin((sine + 0.95) * 2.2)) * euler(0, 1.5707963267948966, 0), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(-0.5 - 1.85 * sin(sine * 2), 0.8 - 0.5 * sin(sine * 2), -1.85 * sin((sine + 0.75) * 2)) * euler(0, 1.5707963267948966, 0), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(0.5 + 1.85 * sin(sine * 2), 0.8 - 0.5 * sin(sine * 2), 1.85 * sin((sine + 0.75) * 2)) * euler(0, -1.5707963267948966, 0), deltaTime) 
                    
    
        elseif mode == "T" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1.5, 0.5, 0) * euler(1.5707963267948966, 3.141592653589793, -1.5707963267948966), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(0, 1.5707963267948966, 0), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.5, 0.5, 0) * euler(1.5707963267948966, 3.141592653589793, 1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(0, -1.5707963267948966, 0), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), deltaTime) 
                    
    
        elseif mode == "float" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 0.5, 0) * euler(-1.7453292519943295, 1.5707963267948966 + 0.17453292519943295 * sin((sine + 1) * 2), 1.5707963267948966), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(1 * sin(sine * 2), 2 + 0.5 * sin(sine * 1), 0) * euler(-1.3962634015954636, 0.08726646259971647 * sin(sine * 2), 3.141592653589793), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.3962634015954636, -1.5707963267948966 + 0.08726646259971647 * sin((sine + 2) * 2), 1.5707963267948966), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 0.5, 0) * euler(1.3962634015954636, -1.5707963267948966 - 0.17453292519943295 * sin((sine + 1) * 2), 1.5707963267948966), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.3962634015954636, 1.5707963267948966 + 0.08726646259971647 * sin((sine + 2) * 2), -1.5707963267948966), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.0471975511965976 + 0.17453292519943295 * sin((sine + 1) * 1), -0.17453292519943295 * sin((sine + 0.5) * 2), 3.141592653589793 + 0.17453292519943295 * sin((sine + 0.2) * 2)), deltaTime) 
                    
    
        elseif mode == "floss" then
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.04363323129985824 * sin((sine + 0.125) * 16), -0.2617993877991494 * sin((sine + 0.05) * 8), -3.141592653589793 + 0.5235987755982988 * sin(sine * 1.1)), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.9 + 0.4 * sin(sine * 8), 0.5, -0.5 * sin((sine - 0.35) * 4)) * euler(1.5707963267948966 + 0.6981317007977318 * sin(sine * 4), 1.5707963267948966 + 0.8726646259971648 * sin(sine * 8), -1.5707963267948966 + 0.17453292519943295 * sin((sine - 0.35) * 4)), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(-0.1 * sin((sine + 0.4) * 8), 0, 0) * euler(-1.5707963267948966, 0.3490658503988659 * sin(sine * 8), -3.141592653589793), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.4 * sin((sine - 0.01) * 8), 0) * euler(1.5707963267948966, -1.7453292519943295 + 0.5235987755982988 * sin(sine * 8), 1.5707963267948966), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.4 * sin((sine - 0.01) * 8), 0) * euler(1.5707963267948966, 1.7453292519943295 + 0.5235987755982988 * sin(sine * 8), -1.5707963267948966), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.9 + 0.4 * sin(sine * 8), 0.5, 0.5 * sin((sine + 0.25) * 4)) * euler(1.5707963267948966, -1.5707963267948966 + 0.8726646259971648 * sin(sine * 8), 1.5707963267948966 + 0.6981317007977318 * sin((sine + 0.25) * 4)), deltaTime) 
                    
    
        elseif mode == "emote" then
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, -0.4363323129985824 * sin(sine * 8), -3.141592653589793), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.3 * sin(sine * 8), 0) * euler(1.5707963267948966, 1.5707963267948966 + 0.5235987755982988 * sin(sine * 8), -1.5707963267948966), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.5, 1, 0) * euler(-0.5235987755982988, -1.5707963267948966 - 0.5235987755982988 * sin(sine * 8), 3.141592653589793), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.5, 1, 0) * euler(-0.5235987755982988, 1.5707963267948966 - 0.5235987755982988 * sin(sine * 8), 3.141592653589793), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(-0.1 * sin(sine * 8), 0.2 * sin((sine + 0.1) * 16), 0) * euler(-1.5707963267948966, 0.2617993877991494 * sin(sine * 8), -3.141592653589793), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.3 * sin(sine * 8), 0) * euler(1.5707963267948966, -1.5707963267948966 + 0.5235987755982988 * sin(sine * 8), 1.5707963267948966), deltaTime) 
                    
    
        elseif mode == "pushups" then
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1.2 - 0.3 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), 0.4 - 0.6 * sin(sine * 4)) * euler(3.0543261909900767 - 0.17453292519943295 * sin(sine * 4), 1.3962634015954636 + 0.17453292519943295 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966, 0, 3.141592653589793), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1, 0) * euler(1.5707963267948966, -1.3962634015954636, 1.5707963267948966), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1, 0) * euler(1.5707963267948966, 1.3962634015954636, -1.5707963267948966), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.99 + 0.5 * sin(sine * 4), 0.15 * sin(sine * 4)) * euler(3.3161255787892263 + 0.17453292519943295 * sin(sine * 4), 0, 3.141592653589793), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1.2 + 0.3 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), 0.4 - 0.6 * sin(sine * 4)) * euler(3.0543261909900767 - 0.17453292519943295 * sin(sine * 4), -1.3962634015954636 - 0.17453292519943295 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                    
    
        elseif mode == "kazotsky" then
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.8 + 0.1 * sin(sine * 4), 0.5 - 0.15 * sin(sine * 4), -0.2) * euler(3.141592653589793 + 0.17453292519943295 * sin((sine + 0.6) * 8), -0.17453292519943295, 1.5707963267948966 - 0.08726646259971647 * sin(sine * 4)), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -0.5 + 0.3 * sin((sine + 0.25) * 8), 0) * euler(-1.3962634015954636 + 0.08726646259971647 * sin((sine + 0.5) * 8), 0.08726646259971647 * sin((sine + 0.1) * 4), 3.141592653589793), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.8 + 0.1 * sin(sine * 4), 0.5 + 0.15 * sin(sine * 4), -0.2) * euler(3.141592653589793 + 0.17453292519943295 * sin((sine + 0.6) * 8), 0.17453292519943295, -1.5707963267948966 - 0.08726646259971647 * sin(sine * 4)), deltaTime) 
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.6580627893946132 - 0.08726646259971647 * sin((sine + 0.5) * 8), -0.08726646259971647 * sin((sine + 0.2) * 4), 3.141592653589793), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -0.5 - 0.5 * sin((sine + 0.6) * 8), -0.5) * euler(1.7453292519943295 + 1.0471975511965976 * sin(sine * 4), 1.5707963267948966 + 0.2617993877991494 * sin(sine * 4), -1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -0.5 - 0.5 * sin((sine + 0.6) * 8), -0.5) * euler(1.7453292519943295 - 1.0471975511965976 * sin(sine * 4), -1.5707963267948966 + 0.017453292519943295 * sin(sine * 4), 1.5707963267948966), deltaTime) 
                    
    
        elseif mode == "L" then
                    Neck.C0 = Neck.C0:Lerp(cf(0, 1, 0) * euler(-1.5707963267948966 + 0.04363323129985824 * sin((sine + 0.1) * 1), -0.17453292519943295 * sin((sine + 0.1) * 5), -3.141592653589793), deltaTime) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1 + 0.2 * sin(sine * 5), -0.2 + 0.2 * sin(sine * 5)) * euler(2.181661564992912 - 0.8726646259971648 * sin(sine * 5), 1.9198621771937625 - 0.3490658503988659 * sin(sine * 5), -1.5707963267948966), deltaTime) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(0.7, 0.8, 0) * euler(1.0471975511965976 + 0.03490658503988659 * sin(sine * 10), 2.0943951023931953 + 0.10471975511965978 * sin((sine + 0.1) * 5), 1.5707963267948966), deltaTime) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1 - 0.2 * sin(sine * 5), -0.2 - 0.2 * sin(sine * 5)) * euler(2.181661564992912 + 0.8726646259971648 * sin(sine * 5), -1.9198621771937625 - 0.3490658503988659 * sin(sine * 5), 1.5707963267948966), deltaTime) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, 0.15 + 0.4 * sin((sine - 0.5) * 10), 0) * euler(-1.4835298641951802, 0.17453292519943295 * sin(sine * 5), -3.141592653589793), deltaTime) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-0.7, 0.5, -0.3) * euler(1.7453292519943295, -0.8726646259971648, 1.5707963267948966), deltaTime) 
                    
                elseif mode == "goofy trolus" then
                    Neck.C0 = Neck.C0:Lerp(cfMul(CFrame.new(0, 1, 0), angles(-1.5707963267948966 + 0.5235987755982988 * math.sin((sine + 0.45) * 8), 0, 3.141592653589793)), deltaTime)
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(CFrame.new(1, 0.5, 0), angles(2.0943951023931953 - 1.7453292519943295 * math.sin((sine - 0.1) * 4), 1.9198621771937625, -1.5707963267948966)), deltaTime)
                    RootJoint.C0 = RootJoint.C0:Lerp(cfMul(CFrame.new(0, 0.25 + 0.5 * math.sin((sine - 0.125) * 8), 0), angles(-1.5707963267948966 + 0.17453292519943295 * math.sin(sine * 8), 0, 3.141592653589793)), deltaTime)
                    LeftHip.C0 = LeftHip.C0:Lerp(cfMul(CFrame.new(-1, -1 - 1 * math.sin(sine * 4), 0), angles(1.5707963267948966 - 1.2217304763960306 * math.sin((sine - 0.15) * 4), -1.5707963267948966 - 0.6108652381980153 * math.sin((sine - 0.15) * 4), 1.5707963267948966)), deltaTime)
                    RightHip.C0 = RightHip.C0:Lerp(cfMul(CFrame.new(1, -1 + 1 * math.sin(sine * 4), 0), angles(1.5707963267948966 + 1.2217304763960306 * math.sin((sine - 0.15) * 4), 1.5707963267948966 + 0.6108652381980153 * math.sin((sine - 0.15) * 4), -1.5707963267948966)), deltaTime)
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(CFrame.new(-1, 0.5, 0), angles(2.0943951023931953 + 1.7453292519943295 * math.sin((sine - 0.1) * 4), -1.7453292519943295, 1.5707963267948966)), deltaTime)
                elseif mode == "fe creepy crawler" then
                    Neck.C0 = Neck.C0:Lerp(cf(0, 0, 0.5) * euler(0.17453292519943295, 0.03490658503988659 * sin((sine * 20 + 2.5) * 0.2), 3.141592653589793 + -0.17453292519943295 * sin((sine * 20 + -10) * 0.2)), 0.1) 
                    RootJoint.C0 = RootJoint.C0:Lerp(cf(0, -1.5, 0) * euler(3.0543261909900767, 0.08726646259971647 * sin((sine * 20 + 7.5) * 0.2), -3.1590459461097367 + -0.08726646259971647 * sin(sine * 20 * 0.2)), 0.1) 
                    LeftShoulder.C0 = LeftShoulder.C0:Lerp(cf(-1, 1.5 + 0.5 * sin((sine * 20 + 10) * 0.2), 0.3 + 0.2 * sin((sine * 20 + -10) * 0.2)) * euler(1.6580627893946132 + 0.17453292519943295 * sin((sine * 20 + 15) * 0.2), 0, -0.08726646259971647 * sin(sine * 20 * 0.2)), 0.1) 
                    RightShoulder.C0 = RightShoulder.C0:Lerp(cf(1, 1.5 + 0.5 * sin((sine * 20 + -7.5) * 0.2), 0.3 + 0.2 * sin((sine * 20 + 5) * 0.2)) * euler(1.6580627893946132 + 0.17453292519943295 * sin(sine * 20 * 0.2), 0, -0.08726646259971647 * sin(sine * 20 * 0.2)), 0.1) 
                    LeftHip.C0 = LeftHip.C0:Lerp(cf(-1, -1.5 + 0.5 * sin((sine * 20 + -7.5) * 0.2), 0.5 + 0.2 * sin((sine * 20 + 5) * 0.2)) * euler(1.6580627893946132 + 0.17453292519943295 * sin(sine * 20 * 0.2), 0, 0.08726646259971647 * sin(sine * 20 * 0.2)), 0.1) 
                    RightHip.C0 = RightHip.C0:Lerp(cf(1, -1.5 + 0.5 * sin((sine * 20 + 10) * 0.2), 0.5 + 0.2 * sin((sine * 20 + -7.5) * 0.2)) * euler(1.6580627893946132 + -0.17453292519943295 * sin(sine * 20 * 0.2), 0, -0.08726646259971647 * sin(sine * 20 * 0.2)), 0.1) 
            end
            end
        end)
    end)
           

    Animations:CreateToggle("Get Ingame Emotes GUI", function(IngameEmotes)
            if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
              
    return end
        getgenv().IngameEmotess = IngameEmotes
        while true do wait(0)
        if not getgenv().IngameEmotess then
            return end
            local LocalPlayer = Players.LocalPlayer
            local PlayerGui = LocalPlayer.PlayerGui
            
            if PlayerGui:FindFirstChild("Animations") == nil then
                
                local loganWS = game:FindFirstChild("LoganWS")
                if loganWS then
                    loganWS:Destroy() 
                end
    
            local animations = {
        ["Vip01"] = 124072584017964,
        ["Vip02"] = 121659384964277,
        ["Vip03"] = 137445502103066,
        ["VipA"] = 79206964158638,
        ["VipD"] = 117490893874984,
        ["VipH"] = 11137175775,
        ["VipM"] = 11137338685,
        ["VipN"] = 11136806744,
        ["VipT"] = 11136713233,
        ["VipU"] = 14852252548
                  } 
                  function sortAnimations(animTable)
                      local sortedAnimations = {}
    
                      for name, id in pairs(animTable) do
                          table.insert(sortedAnimations, {name, id})
                      end
    
                      table.sort(sortedAnimations, function(a, b)
                          return a[1] < b[1]
                      end)
    
                      
                      local newSortedTable = {}
                      for _, v in ipairs(sortedAnimations) do
                          newSortedTable[v[1]] = v[2]
                      end
    
                      return newSortedTable
                  end
    
                  
                  animations = sortAnimations(animations)
    
                  
                  local LoganWS = Instance.new('Folder', game.CoreGui)
                  LoganWS.Name = 'LoganWS'
    
                  local buttonHolder = Instance.new('Folder', LoganWS)
                  buttonHolder.Name = "Buttons"
    
                  local Animations = Instance.new("ScreenGui")
                  local MainFrame = Instance.new("Frame")
                  local UIGradient = Instance.new("UIGradient")
                  local Title = Instance.new("TextLabel")
                  local SearchBox = Instance.new("TextBox")
                  local Container = Instance.new("ScrollingFrame")
                  local Button = Instance.new("TextButton")
                  local UIListLayout = Instance.new("UIListLayout")
                  local UIListLayout2 = Instance.new("UIListLayout")
                  local UIListLayout3 = Instance.new("UIListLayout")
                  local StopAnim = Instance.new("TextButton")
                  local PauseAnim = Instance.new("TextButton")
                  local ReplayAnim = Instance.new("TextButton")
                  local ReverseAnim = Instance.new("TextButton")
                  local Exit = Instance.new("TextButton")
                  local Mini = Instance.new("TextButton")
                  local titleFrame = Instance.new("Frame")
                  local slideFrame = Instance.new("Frame")
                  local SlideBar = Instance.new("Frame")
                  local SlideButton = Instance.new("TextButton")
                  local creds = Instance.new("TextLabel")
                  wait(0.3)
                  Animations.Name = "Animations"
                  Animations.Parent = plr:WaitForChild("PlayerGui")
    
                  MainFrame.Name = "MainFrame"
                  MainFrame.Parent = Animations
                  MainFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                  MainFrame.BorderColor3 = Color3.fromRGB(27, 42, 53)
                  MainFrame.BorderSizePixel = 0
                  MainFrame.Position = UDim2.new(0.4, 584, 0.2, -74)
                  MainFrame.Size = UDim2.new(0.135, 0, 0.6, 0)
    
                  titleFrame.Name = "TitleFrame"
                  titleFrame.Parent = MainFrame
                  titleFrame.BorderSizePixel = 0
                  titleFrame.LayoutOrder = 0
                  titleFrame.BackgroundTransparency = 1
                  titleFrame.Size = UDim2.new(1, 0, 0.05, 0)
    
                  slideFrame.Name = "SlideFrame"
                  slideFrame.Parent = MainFrame
                  slideFrame.BorderSizePixel = 0
                  slideFrame.LayoutOrder = 3
                  slideFrame.BackgroundTransparency = 1
                  slideFrame.Size = UDim2.new(1, 0, 0.05, 0)
    
                  UIListLayout3.Parent = titleFrame
                  UIListLayout3.FillDirection = Enum.FillDirection.Horizontal
                  UIListLayout3.SortOrder = Enum.SortOrder.LayoutOrder
    
                  UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(102, 45, 113)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(102, 34, 103))}
                  UIGradient.Parent = MainFrame
    
                  Title.Name = "Title"
                  Title.Parent = titleFrame
                  Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                  Title.BackgroundTransparency = 1.000
                  Title.Size = UDim2.new(0.8, 0, 1, 0)
                  Title.Font = Enum.Font.GothamSemibold
                  Title.Text = "Emotes"
                  Title.TextColor3 = Color3.fromRGB(255, 255, 255)
                  Title.TextScaled = true
                  Title.TextSize = 14.000
                  Title.TextWrapped = true
                  Title.LayoutOrder = 0
    
                  creds.Name = "Creds"
                  creds.Parent = MainFrame
                  creds.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                  creds.BackgroundTransparency = 1.000
                  creds.Size = UDim2.new(1, 0, 0.05, 0)
                  creds.Font = Enum.Font.GothamSemibold
                  creds.Text = "By HaxterFelix"
                  creds.TextColor3 = Color3.fromRGB(255, 255, 255)
                  creds.TextScaled = true
                  creds.TextSize = 14.000
                  creds.TextWrapped = true
                  creds.LayoutOrder = 8
    
                  SearchBox.Name = "SearchBox"
                  SearchBox.Parent = MainFrame
                  SearchBox.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                  SearchBox.BackgroundTransparency = 0.750
                  SearchBox.BorderSizePixel = 0
                  SearchBox.Size = UDim2.new(1, 0, 0.045, 0)
                  SearchBox.Font = Enum.Font.GothamSemibold
                  SearchBox.PlaceholderColor3 = Color3.fromRGB(255, 255, 255)
                  SearchBox.PlaceholderText = "Search bar..."
                  SearchBox.Text = ""
                  SearchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
                  SearchBox.TextScaled = true
                  SearchBox.TextSize = 14.000
                  SearchBox.TextWrapped = true
                  SearchBox.LayoutOrder = 1
    
                  Container.Name = "Container"
                  Container.Parent = MainFrame
                  Container.Active = true
                  Container.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                  Container.BackgroundTransparency = 0.750
                  Container.BorderSizePixel = 0
                  Container.Size = UDim2.new(1, 0, 0.5, 0)
                  Container.ScrollBarThickness = 5
                  Container.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Left
                  Container.LayoutOrder = 2
    
                  Button.Name = "Button"
                  Button.Parent = LoganWS
                  Button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                  Button.BackgroundTransparency = 0.850
                  Button.BorderSizePixel = 0
                  Button.Size = UDim2.new(1, 0, 0, 38)
                  Button.Font = Enum.Font.GothamSemibold
                  Button.Text = "Test"
                  Button.TextColor3 = Color3.fromRGB(255, 255, 255)
                  Button.TextScaled = true
                  Button.TextSize = 14.000
                  Button.TextWrapped = true
    
                  UIListLayout.Parent = Container
                  UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
                  UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
                  UIListLayout.Padding = UDim.new(0, 5)
    
                  UIListLayout2.Parent = MainFrame
                  UIListLayout2.HorizontalAlignment = Enum.HorizontalAlignment.Center
                  UIListLayout2.SortOrder = Enum.SortOrder.LayoutOrder
                  UIListLayout2.Padding = UDim.new(0, 5)
    
                  ReverseAnim.Name = "ReverseAnim"
                  ReverseAnim.Parent = MainFrame
                  ReverseAnim.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                  ReverseAnim.BackgroundTransparency = 0.750
                  ReverseAnim.BorderColor3 = Color3.fromRGB(27, 42, 53)
                  ReverseAnim.BorderSizePixel = 0
                  ReverseAnim.LayoutOrder = 4
                  ReverseAnim.Size = UDim2.new(0.85, 0, 0.06, 0)
                  ReverseAnim.Font = Enum.Font.GothamSemibold
                  ReverseAnim.Text = "Reverse animation"
                  ReverseAnim.TextColor3 = Color3.fromRGB(255, 255, 255)
                  ReverseAnim.TextScaled = true
                  ReverseAnim.TextSize = 14.000
                  ReverseAnim.TextWrapped = true
    
                  StopAnim.Name = "StopAnim"
                  StopAnim.Parent = MainFrame
                  StopAnim.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                  StopAnim.BackgroundTransparency = 0.750
                  StopAnim.BorderColor3 = Color3.fromRGB(27, 42, 53)
                  StopAnim.BorderSizePixel = 0
                  StopAnim.LayoutOrder = 5
                  StopAnim.Size = UDim2.new(0.85, 0, 0.06, 0)
                  StopAnim.Font = Enum.Font.GothamSemibold
                  StopAnim.Text = "Stop animation"
                  StopAnim.TextColor3 = Color3.fromRGB(255, 255, 255)
                  StopAnim.TextScaled = true
                  StopAnim.TextSize = 14.000
                  StopAnim.TextWrapped = true
    
                  PauseAnim.Name = "PauseAnim"
                  PauseAnim.Parent = MainFrame
                  PauseAnim.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                  PauseAnim.BackgroundTransparency = 0.750
                  PauseAnim.BorderColor3 = Color3.fromRGB(27, 42, 53)
                  PauseAnim.BorderSizePixel = 0
                  PauseAnim.Size = UDim2.new(0, 219, 0, 28)
                  PauseAnim.Font = Enum.Font.GothamSemibold
                  PauseAnim.Text = "Pause Game Animations"
                  PauseAnim.TextColor3 = Color3.fromRGB(255, 255, 255)
                  PauseAnim.TextScaled = true
                  PauseAnim.TextSize = 14.000
                  PauseAnim.TextWrapped = true
                  PauseAnim.LayoutOrder = 6
    
                  ReplayAnim.Name = "ReplayAnim"
                  ReplayAnim.Parent = MainFrame
                  ReplayAnim.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                  ReplayAnim.BackgroundTransparency = 0.750
                  ReplayAnim.BorderColor3 = Color3.fromRGB(27, 42, 53)
                  ReplayAnim.BorderSizePixel = 0
                  ReplayAnim.Size = UDim2.new(0, 219, 0, 28)
                  ReplayAnim.Font = Enum.Font.GothamSemibold
                  ReplayAnim.Text = "Replay Game Animations"
                  ReplayAnim.TextColor3 = Color3.fromRGB(255, 255, 255)
                  ReplayAnim.TextScaled = true
                  ReplayAnim.TextSize = 14.000
                  ReplayAnim.TextWrapped = true
                  ReplayAnim.LayoutOrder = 7
    
                  Exit.Name = "Exit"
                  Exit.Parent = titleFrame
                  Exit.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                  Exit.BackgroundTransparency = 1.000
                  Exit.Size = UDim2.new(0.1, 0, 0.7, 0)
                  Exit.Font = Enum.Font.GothamSemibold
                  Exit.Text = "X"
                  Exit.TextColor3 = Color3.fromRGB(255, 255, 255)
                  Exit.TextScaled = true
                  Exit.TextSize = 14.000
                  Exit.TextWrapped = true
                  Exit.LayoutOrder = 2
    
                  Mini.Name = "Mini"
                  Mini.Parent = titleFrame
                  Mini.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                  Mini.BackgroundTransparency = 1.000
                  Mini.Size = UDim2.new(0.1, 0, 0.7, 0)
                  Mini.Font = Enum.Font.GothamSemibold
                  Mini.Text = "-"
                  Mini.TextColor3 = Color3.fromRGB(255, 255, 255)
                  Mini.TextScaled = true
                  Mini.TextSize = 14.000
                  Mini.TextWrapped = true
                  Mini.LayoutOrder = 1
    
                  SlideBar.Name = "SlideBar"
                  SlideBar.Parent = slideFrame
                  SlideBar.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                  SlideBar.BackgroundTransparency = 0.750
                  SlideBar.BorderSizePixel = 0
                  SlideBar.Size = UDim2.new(1, 0, 0.3, 0)
                  SlideBar.AnchorPoint = Vector2.new(0.5,0.5)
                  SlideBar.Position = UDim2.new(0.5,0,0.5,0)
    
    
                  SlideButton.Name = "SlideButton"
                  SlideButton.Parent = SlideBar
                  SlideButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                  SlideButton.BorderSizePixel = 0
                  SlideButton.Position = UDim2.new(0.5, 0, -1.5, 0)
                  SlideButton.Size = UDim2.new(0, 10, 0, 26)
                  SlideButton.Font = Enum.Font.SourceSans
                  SlideButton.TextColor3 = Color3.fromRGB(0, 0, 0)
                  SlideButton.TextSize = 14.000
                  SlideButton.TextTransparency = 1.000
    
                  MainFrame.Active = true
                  MainFrame.Draggable = true
    
                  local LayOut = 0
                  local CurrentAni = nil
                  local neg = false
    
    
                  function StopAnims()
                  for _,v in pairs(animations) do
                    v:Stop()
                  end
                  end
                  wait(0.4)
                  function LoadAnims()
                  for i,v in pairs(animations) do
                    local Anim = Instance.new("Animation", LoganWS)
                    Anim.AnimationId = "rbxassetid://"..v
                    animations[i] = plr.Character.Humanoid:LoadAnimation(Anim)
                    CreateButton(i)
                  end
                  end
    
                  function Snap(number, factor)
                  if factor == 0 then
                    return number
                  else
                    return math.floor(number/factor+0.5)*factor
                  end
                  end
    
                  function AutoScale()
                  local number = (#Container:GetChildren()-1)*38
                  number = number + (#Container:GetChildren()-1)*5
                  Container.CanvasSize = UDim2.new(0,0,0,number)
                  end
    
    
    
                  function CreateButton(AnimationName)
                  local ButtonClone = Button:Clone()
                  ButtonClone.LayoutOrder = LayOut
                  LayOut = LayOut + 1
                  ButtonClone.Parent = buttonHolder
                  ButtonClone.Name = AnimationName
                  ButtonClone.Text = AnimationName
                  ButtonClone.MouseButton1Click:Connect(function()
                    StopAnims()
                    CurrentAni = animations[ButtonClone.Name]
                    CurrentAni:Play()
                  end)
                  end
    
                  function FindAnim() 
                  local text = string.lower(SearchBox.Text)
                  if SearchBox.Text == "" or SearchBox.Text == nil then
                    for _,v in pairs(buttonHolder:GetChildren()) do
                      v.Parent = Container
                    end
                  else
                    for i,v in pairs(buttonHolder:GetChildren()) do
                      if string.find(string.lower(v.Name), text) then
                        v.Parent = Container
                      end
                    end
                    for i,v in pairs(Container:GetChildren()) do
                      if not string.find(string.lower(v.Name), text) and v.Name ~= "UIListLayout" then
                        v.Parent = buttonHolder
                      end
                    end
                  end
                  end
    
                  ReverseAnim.MouseButton1Click:Connect(function()
                  neg = not neg
                  end)
                  StopAnim.MouseButton1Click:Connect(StopAnims)
                  PauseAnim.MouseButton1Click:Connect(function()
                  plr.Character.Animate.Disabled = true
                  end)
                  ReplayAnim.MouseButton1Click:Connect(function()
                  plr.Character.Animate.Disabled = false
                  end)
    
                  local TS = game:GetService("TweenService")
                  local tweenclose = TS:Create(MainFrame, TweenInfo.new(1), {Size = UDim2.new(0.135, 0, 0.03, 0)})
                  local tweenclose2 = TS:Create(titleFrame, TweenInfo.new(1), {Size = UDim2.new(1, 0, 1, 0)})
                  local tweenopen = TS:Create(MainFrame, TweenInfo.new(1), {Size = UDim2.new(0.135, 0, 0.6, 0)})
                  local tweenopen2 = TS:Create(titleFrame, TweenInfo.new(1), {Size = UDim2.new(1, 0, 0.05, 0)})
                  local open = true
                  Mini.MouseButton1Click:Connect(function()
                  if open then
                    Mini.Text = "o"
                    for _,v in pairs(MainFrame:GetChildren()) do
                      if v.Name ~= titleFrame.Name and not string.find(v.Name, "UI") then
                        v.Visible = false
                      end
                    end
                    tweenclose:Play()
                    tweenclose2:Play()
                  else
                    Mini.Text = "-"
                    for _,v in pairs(MainFrame:GetChildren()) do
                      if not string.find(v.Name, "UI") then
                        v.Visible = true
                      end
                    end
                    tweenopen:Play()
                    tweenopen2:Play()
                  end
                  open = not open
                  end)
    
                  LoadAnims()
    
                  local held = false
                  SlideButtonPos = SlideButton.Position
                  local UIS = game:GetService("UserInputService")
                  local RuS = game:GetService("RunService")
                  local step = 0.01
                  local percentage = 0
    
                  UIS.InputEnded:connect(function(input, processed)
                  if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    held = false
                  end
                  end)
    
                  SlideButton.MouseButton1Down:Connect(function()
                  held = true
                  end)
    
                  local con = RuS.RenderStepped:connect(function()
                  if held then
                    local MousePos = UIS:GetMouseLocation().X
                    local BtnPos = SlideButton.Position
                    local SliderSize = SlideBar.AbsoluteSize.X
                    local SliderPos = SlideBar.AbsolutePosition.X
                    local pos = Snap((MousePos-SliderPos)/SliderSize,step)
                    percentage = math.clamp(pos,0,0.96)
                    SlideButton.Position = UDim2.new(percentage,0,BtnPos.Y.Scale, BtnPos.Y.Offset)
                  end
                  local axis = SlideButton.Position.X.Scale*2
                  if neg then
                    axis = -axis
                  end
                  if CurrentAni ~= nil then
                    CurrentAni:AdjustSpeed(axis)
                  end
                  FindAnim()
                  AutoScale()
                  end)
    
                  Exit.MouseButton1Click:Connect(function()
                  StopAnims()
                  plr.Character.Animate.Disabled = false
                  Animations:Destroy()
                  LoganWS:Destroy()
                  con:Disconnect()
                  end)
                  end
                  end
    end)

    Credits:CreateButton("Credits To Shavine/da_goofy_groover. Animations.", function()
        setclipboard("da_goofy_groover")
    end)

    Server:CreateBox("Job ID", "string", function(JobID)
        JobIDs = JobID
    end)
    Server:CreateButton("Join Job ID", function(OPENS) 
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId , tostring(JobIDs) )
    end)
    Server:CreateButton("Copy Job ID", function(OPENS) 
    local placeId = game.JobId
    setclipboard(tostring(placeId)) 
    end)
    Server:CreateButton("Copy Game ID", function(OPENS) 
        local gameID = game.GameId
        setclipboard(tostring(gameID)) 
        end)
    Server:CreateButton("Server Hop", function(OPENS) 
    local PlaceID = game.PlaceId
    local AllIDs = {}
    local foundAnything = ""
    local actualHour = os.date("!*t").hour
    local Deleted = false

    function TPReturner()
        local Site;
        if foundAnything == "" then
            Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
        else
            Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
        end
        local ID = ""
        if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
            foundAnything = Site.nextPageCursor
        end
        local num = 50;
        for i,v in pairs(Site.data) do
            local Possible = true
            ID = tostring(v.id)
            if tonumber(v.maxPlayers) > tonumber(v.playing) then
                for _,Existing in pairs(AllIDs) do
                    if num ~= 0 then
                        if ID == tostring(Existing) then
                            Possible = false
                        end
                    else
                        if tonumber(actualHour) ~= tonumber(Existing) then
                            local delFile = pcall(function()

                                AllIDs = {}
                                table.insert(AllIDs, actualHour)
                            end)
                        end
                    end
                    num = num + 1
                end
                if Possible == true then
                    table.insert(AllIDs, ID)
                    wait()
                    pcall(function()

                        wait()
                        game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, game.Players.LocalPlayer)
                    end)
                    wait(4)
                end
            end
        end
    end

    function Teleport()
        while wait() do
            pcall(function()
                TPReturner()
                if foundAnything ~= "" then
                    TPReturner()
                end
            end)
        end
    end

    Teleport()
        end)


        local ServerList = {}


        function getCurrentTime()
            return os.date("%Y-%m-%d %H:%M:%S")  
        end


        function saveServerInfo(gameName, jobID, gameID)
            local currentTime = getCurrentTime()
        

            if #gameName > 7 then
                gameName = gameName:sub(1, 7) .. "..."
            end
        

            local serverInfoToStore = string.format("%s : %s : %s : %s", currentTime, gameName, jobID, gameID)
        

            local serverInfoForDropdown = string.format("%s : %s", currentTime, gameName)
        

            local existingServers = {}
            local success, err = pcall(function()
                if isfile("saved_servers.txt") then  
                    local data = readfile("saved_servers.txt")
                    for line in data:gmatch("[^\r\n]+") do
                        table.insert(existingServers, line)
                    end
                else

                    writefile("saved_seasdrvers.txt", "")

                end
            end)
        
            if not success then

                return false
            end
        

            for _, info in ipairs(existingServers) do
                if info:find(jobID, 1, true) then  
                    return false  
                end
            end
        

            table.insert(ServerList, serverInfoForDropdown)  
            table.insert(existingServers, serverInfoToStore)  
        
            local successWrite, errWrite = pcall(function()
                writefile("saved_servers.txt", table.concat(existingServers, "\n"))
            end)
        
            if not successWrite then

                return false
            else

                return true
            end
        end


        function getCurrentGameInfo()
            local gameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
            local jobID = game.JobId
            local gameID = game.PlaceId

            return gameName, jobID, gameID
        end


        function removeDuplicates()
            local uniqueServers = {}
            local seen = {}
        
            for _, info in ipairs(ServerList) do
                if not seen[info] then
                    seen[info] = true
                    table.insert(uniqueServers, info)
                end
            end
        
            ServerList = uniqueServers
        end


        function getJobIDAndGameIDByTimestamp(timestamp)
            local existingServers = {}
        
            local success, err = pcall(function()
                if isfile("saved_servers.txt") then  
                    local data = readfile("saved_servers.txt")
                    for line in data:gmatch("[^\r\n]+") do
                        table.insert(existingServers, line)
                    end
                end
            end)
        
            if not success then

                return nil, nil
            end
        
            for _, info in ipairs(existingServers) do

                local storedTimestamp, storedJobID, storedGameID = info:match("^(%d%d%d%d%-%d%d%-%d%d %d%d:%d%d:%d%d) : [^:]+ : ([^:]+) : (%d+)$")




                if storedTimestamp == timestamp then
                    return storedJobID, storedGameID
                end
            end
        
            return nil, nil  
        end

        local dropdown = Server:CreateDropdown2("Saved Servers", ServerList, function(CurrentServerListOption)
            local selectedTimestamp = CurrentServerListOption:match("^(%d%d%d%d%-%d%d%-%d%d %d%d:%d%d:%d%d)")

            if selectedTimestamp then
                local jobID, gameID = getJobIDAndGameIDByTimestamp(selectedTimestamp)
            
                if jobID and gameID then
                    local success, err = pcall(function()
                        game:GetService("TeleportService"):TeleportToPlaceInstance(tonumber(gameID), jobID)
                    end)
                    if not success then

                    end
                end
            end
        end)


        function refreshDropdown()
            dropdown:Refresh(ServerList)
        end


        function loadSavedServers()
            local success, err = pcall(function()
                if isfile("saved_servers.txt") then  
                    local data = readfile("saved_servers.txt")
                    for line in data:gmatch("[^\r\n]+") do

                        local timestamp, gameName = line:match("^(%S+ %S+) : ([^:]+)")
                        if timestamp and gameName then
                            table.insert(ServerList, 1, string.format("%s : %s", timestamp, gameName))
                        end
                    end
                else

                    writefile("saved_servers.txt", "")

                end
            end)
        
            if not success then

            else

                removeDuplicates()  
            end
        
            refreshDropdown()
        end


        function saveCurrentGameInfo()
            local gameName, jobID, gameID = getCurrentGameInfo()
            saveServerInfo(gameName, jobID, gameID)
        end

        loadSavedServers()
        removeDuplicates() 
        saveCurrentGameInfo() 
        spawn(function()
            while true do
                refreshDropdown()
                wait(1)
            end
        end)
    local IdleAnimations = {
            {Name = "Wicked Popular Idle", ID1 = "http://www.roblox.com/asset/?id=118832222982049", ID2 = "http://www.roblox.com/asset/?id=76049494037641"},
            {Name = "Berry Avenue Idle", ID1 = "http://www.roblox.com/asset/?id=4211217646", ID2 = "http://www.roblox.com/asset/?id=4211218409"},
            {Name = "Catwalk Glam Idle", ID1 = "http://www.roblox.com/asset/?id=133806214992291", ID2 = "http://www.roblox.com/asset/?id=94970088341563"},
            {Name = "NFL Animation Idle", ID1 = "http://www.roblox.com/asset/?id=92080889861410", ID2 = "http://www.roblox.com/asset/?id=74451233229259"},
            {Name = "Bold Animation Idle", ID1 = "http://www.roblox.com/asset/?id=16738333868", ID2 = "http://www.roblox.com/asset/?id=16738334710"},
            {Name = "Adidas Sports Idle", ID1 = "http://www.roblox.com/asset/?id=18537376492", ID2 = "http://www.roblox.com/asset/?id=18537371272"},
            {Name = "No Boundaries Idle", ID1 = "http://www.roblox.com/asset/?id=18747067405", ID2 = "http://www.roblox.com/asset/?id=18747063918"},
            {Name = "Vampire Idle", ID1 = "http://www.roblox.com/asset/?id=1083445855", ID2 = "http://www.roblox.com/asset/?id=1083450166"},
            {Name = "Hero Idle", ID1 = "http://www.roblox.com/asset/?id=616111295", ID2 = "http://www.roblox.com/asset/?id=616113536"},
            {Name = "Zombie Idle", ID1 = "http://www.roblox.com/asset/?id=616158929", ID2 = "http://www.roblox.com/asset/?id=616160636"},
            {Name = "Mage Idle", ID1 = "http://www.roblox.com/asset/?id=707742142", ID2 = "http://www.roblox.com/asset/?id=707855907"},
            {Name = "Levitation Idle", ID1 = "http://www.roblox.com/asset/?id=616006778", ID2 = "http://www.roblox.com/asset/?id=616008087"},
            {Name = "Elder Idle", ID1 = "http://www.roblox.com/asset/?id=845397899", ID2 = "http://www.roblox.com/asset/?id=845400520"},
            {Name = "Astronaut Idle", ID1 = "http://www.roblox.com/asset/?id=891621366", ID2 = "http://www.roblox.com/asset/?id=891633237"},
            {Name = "Ninja Idle", ID1 = "http://www.roblox.com/asset/?id=656117400", ID2 = "http://www.roblox.com/asset/?id=656118341"},
            {Name = "Werewolf Idle", ID1 = "http://www.roblox.com/asset/?id=1083195517", ID2 = "http://www.roblox.com/asset/?id=1083214717"},
            {Name = "Cartoon Idle", ID1 = "http://www.roblox.com/asset/?id=742637544", ID2 = "http://www.roblox.com/asset/?id=742638445"},
            {Name = "Pirate Idle", ID1 = "http://www.roblox.com/asset/?id=750781874", ID2 = "http://www.roblox.com/asset/?id=750782770"},
            {Name = "Sneaky Idle", ID1 = "http://www.roblox.com/asset/?id=1132473842", ID2 = "http://www.roblox.com/asset/?id=1132477671"},
            {Name = "Toy Idle", ID1 = "http://www.roblox.com/asset/?id=782841498", ID2 = "http://www.roblox.com/asset/?id=782845736"},
            {Name = "Knight Idle", ID1 = "http://www.roblox.com/asset/?id=657595757", ID2 = "http://www.roblox.com/asset/?id=657568135"},
            {Name = "Confident Idle", ID1 = "http://www.roblox.com/asset/?id=1069977950", ID2 = "http://www.roblox.com/asset/?id=1069987858"},
            {Name = "PopStar Idle", ID1 = "http://www.roblox.com/asset/?id=1212900985", ID2 = "http://www.roblox.com/asset/?id=1212900985"},
            {Name = "Princess Idle", ID1 = "http://www.roblox.com/asset/?id=941003647", ID2 = "http://www.roblox.com/asset/?id=941013098"},
            {Name = "Cowboy Idle", ID1 = "http://www.roblox.com/asset/?id=1014390418", ID2 = "http://www.roblox.com/asset/?id=1014398616"},
            {Name = "Patrol Idle", ID1 = "http://www.roblox.com/asset/?id=1149612882", ID2 = "http://www.roblox.com/asset/?id=1150842221"},
            {Name = "Edited Zombie Idle", ID1 = "http://www.roblox.com/asset/?id=3489171152", ID2 = "http://www.roblox.com/asset/?id=3489171152"},
        }

        local IdleList = {}


        for _, anim in ipairs(IdleAnimations) do
            table.insert(IdleList, anim.Name)
        end

        local selectedAnimID1, selectedAnimID2

        local dropdown = Animations:CreateDropdown("Animations", IdleList, function(CurrentIdleOption)
            function StopAnim()
                plr.Character.Animate.Disabled = false
                local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
                for _, track in pairs(animtrack) do
                    track:Stop()
                end
            end
        
        if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                    Message("Error!", "You're in R6", 5)
        return end
            StopAnim()
            plr.Character.Animate.Disabled = true
        
        
            for _, anim in ipairs(IdleAnimations) do
                if anim.Name == CurrentIdleOption then
                    selectedAnimID1 = anim.ID1
                    selectedAnimID2 = anim.ID2
                    break
                end
            end
        
        
            plr.Character.Animate.idle.Animation1.AnimationId = selectedAnimID1
            plr.Character.Animate.idle.Animation2.AnimationId = selectedAnimID2
            plr.Character.Animate.Disabled = false
            plr.Character.Humanoid:ChangeState(3)
        
        
        end)

        Animations:CreateToggle("Auto Idle", function(AutoIdle)
                if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
        return end
            getgenv().AutoIdles = AutoIdle
                
                
            function onCharacterAdded(character)
                if selectedAnimID1 and selectedAnimID2 then
                    if R6reanimated then return end
                    local character = plr.Character
                    if character then
                    local animate = character:FindFirstChild("Animate")
                    if not animate then return end
                    if R6reanimated then return end

                        character.Animate.idle.Animation1.AnimationId = selectedAnimID1
                        character.Animate.idle.Animation2.AnimationId = selectedAnimID2
                        character.Animate.Disabled = false
                    end
                end
            end
        
        
            plr.CharacterAdded:Connect(onCharacterAdded)
        
        
            if plr.Character then
                onCharacterAdded(plr.Character)
            end
        
            while true do
                wait(0)
                if not getgenv().AutoIdles then
                    _G.AutoIdlesss = false
                    return
                end
            
                _G.AutoIdlesss = true
                local AutoIdlessss = nil
            
                AutoIdlessss = RunService.Stepped:Connect(function()
                    task.spawn(function()
                        if selectedAnimID1 and selectedAnimID2 then
                            if plr.Character then
                                if R6reanimated then return end
                                    local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                                    if not (plr.Character.Animate.idle.Animation1.AnimationId == selectedAnimID1 or 
                                        plr.Character.Animate.idle.Animation2.AnimationId == selectedAnimID2) then
                                        plr.Character.Animate.idle.Animation1.AnimationId = selectedAnimID1
                                        plr.Character.Animate.idle.Animation2.AnimationId = selectedAnimID2
                                        plr.Character.Animate.Disabled = false
                                        plr.Character.Humanoid:ChangeState(3)
                                    end
                                end
                            end
                        end
                    end)
                end)
            
                repeat task.wait() until _G.AutoIdlesss == false
                AutoIdlessss:Disconnect()
            end
        end)





        local WalkAnimations = {
            {Name = "Wicked Walk", ID = "http://www.roblox.com/asset/?id=92072849924640"},
            {Name = "Berry Avenue Walk", ID = "http://www.roblox.com/asset/?id=4211223236"},
            {Name = "Catwalk Glam Walk", ID = "http://www.roblox.com/asset/?id=109168724482748"},
            {Name = "NFL Walk", ID = "http://www.roblox.com/asset/?id=110358958299415"},
            {Name = "Bold Walk", ID = "http://www.roblox.com/asset/?id=16738340646"},
            {Name = "Adidas Sports Walk", ID = "http://www.roblox.com/asset/?id=18537392113"},
            {Name = "No Boundaries Walk", ID = "http://www.roblox.com/asset/?id=18747074203"},
            {Name = "Vampire Walk", ID = "http://www.roblox.com/asset/?id=1083473930"},
            {Name = "Hero Walk", ID = "http://www.roblox.com/asset/?id=616122287"},
            {Name = "Zombie Walk", ID = "http://www.roblox.com/asset/?id=616168032"},
            {Name = "Mage Walk", ID = "http://www.roblox.com/asset/?id=707897309"},
            {Name = "Levitation Walk", ID = "http://www.roblox.com/asset/?id=616010382"}, 
            {Name = "Elder Walk", ID = "http://www.roblox.com/asset/?id=845403856"}, 
            {Name = "Astronaut Walk", ID = "http://www.roblox.com/asset/?id=891667138"},
            {Name = "Ninja Walk", ID = "http://www.roblox.com/asset/?id=656121766"},
            {Name = "Werewolf Walk", ID = "http://www.roblox.com/asset/?id=1083178339"},
            {Name = "Cartoon Walk", ID = "http://www.roblox.com/asset/?id=742640026"},
            {Name = "Pirate Walk", ID = "http://www.roblox.com/asset/?id=750785693"},
            {Name = "Sneaky Walk", ID = "http://www.roblox.com/asset/?id=1132510133"},
            {Name = "Toy Walk", ID = "http://www.roblox.com/asset/?id=782843345"},
            {Name = "Knight Walk", ID = "http://www.roblox.com/asset/?id=657552124"},
            {Name = "Confident Walk", ID = "http://www.roblox.com/asset/?id=1070017263"},
            {Name = "PopStar Walk", ID = "http://www.roblox.com/asset/?id=1212980338"},
            {Name = "Princess Walk", ID = "http://www.roblox.com/asset/?id=941028902"},
            {Name = "Cowboy Walk", ID = "http://www.roblox.com/asset/?id=1014421541"},
            {Name = "Patrol Walk", ID = "http://www.roblox.com/asset/?id=1151231493"},
            {Name = "Edited Zombie Walk", ID = "http://www.roblox.com/asset/?id=3489174223"},
        }


        local WalkList = {}


        for _, anim in ipairs(WalkAnimations) do
            table.insert(WalkList, anim.Name)
        end

        local selectedAnimID

        local dropdown = Animations:CreateDropdown("Walk Animations", WalkList, function(CurrentWalkOption)
            function StopAnim()
                plr.Character.Animate.Disabled = false
                local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
                for _, track in pairs(animtrack) do
                    track:Stop()
                end
            end
        
        if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                    Message("Error!", "You're in R6", 5)
        return end
            StopAnim()
            plr.Character.Animate.Disabled = true
        
        
            for _, anim in ipairs(WalkAnimations) do
                if anim.Name == CurrentWalkOption then
                    selectedAnimID = anim.ID
                    break
                end
            end
        
        
            plr.Character.Animate.walk:FindFirstChildOfClass("Animation").AnimationId = selectedAnimID
            plr.Character.Animate.run:FindFirstChildOfClass("Animation").AnimationId = selectedAnimID 
            plr.Character.Animate.Disabled = false
        end)

        Animations:CreateToggle("Auto Walk", function(AutoWalk)
                if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                
        return end
            getgenv().AutoWalks = AutoWalk
                
                
            function onCharacterAdded(character)
                local humanoid = character:WaitForChild("Humanoid")
            
            
                if humanoid then
                if R6reanimated then return end
                                    local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                    if character.Animate.idle.Animation1.AnimationId ~= selectedAnimID then
                        character.Animate.walk.WalkAnim.AnimationId = selectedAnimID
                    end
                    end
                end
            end
        
        
            plr.CharacterAdded:Connect(onCharacterAdded)
        
        
            if plr.Character then
                onCharacterAdded(plr.Character)
            end
        
            while true do
                wait(0)
                if not getgenv().AutoWalks then
                    _G.AutoWalks = false
                    return
                end

                _G.AutoWalks = true
                local AutoWalkConnection = nil
            
                AutoWalkConnection = RunService.Stepped:Connect(function()
                    task.spawn(function()
                        if plr.Character then
                            if selectedAnimID then
                if R6reanimated then return end
                                                local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                                if not (plr.Character.Animate.idle.Animation1.AnimationId == selectedAnimID) then
                                    plr.Character.Animate.walk:FindFirstChildOfClass("Animation").AnimationId = selectedAnimID
                                end
                                end
                            end
                        end
                    end)
                end)
            
                repeat task.wait() until _G.AutoWalks == false
                AutoWalkConnection:Disconnect()
            end
        end)
        local RunAnimations = {
            {Name = "Wicked Run", ID = "http://www.roblox.com/asset/?id=72301599441680"},
            {Name = "Berry Avenue Run", ID = "http://www.roblox.com/asset/?id=4211220381"},
            {Name = "Catwalk Glam Run", ID = "http://www.roblox.com/asset/?id=117333533048078"},
            {Name = "NFL Run", ID = "http://www.roblox.com/asset/?id=117333533048078"},
            {Name = "Bold Run", ID = "http://www.roblox.com/asset/?id=16738337225"},
            {Name = "Adidas Sports Run", ID = "http://www.roblox.com/asset/?id=18537384940"},
            {Name = "No Boundaries Run", ID = "http://www.roblox.com/asset/?id=18747070484"},
            {Name = "Vampire Run", ID = "http://www.roblox.com/asset/?id=1083462077"},
            {Name = "Hero Run", ID = "http://www.roblox.com/asset/?id=616117076"},
            {Name = "Zombie Run", ID = "http://www.roblox.com/asset/?id=616163682"},
            {Name = "Mage Run", ID = "http://www.roblox.com/asset/?id=707861613"},
            {Name = "Levitation Run", ID = "http://www.roblox.com/asset/?id=616013216"}, 
            {Name = "Elder Run", ID = "http://www.roblox.com/asset/?id=845386501"}, 
            {Name = "Astronaut Run", ID = "http://www.roblox.com/asset/?id=891636393"},
            {Name = "Ninja Run", ID = "http://www.roblox.com/asset/?id=656118852"},
            {Name = "Werewolf Run", ID = "http://www.roblox.com/asset/?id=1083216690"},
            {Name = "Cartoon Run", ID = "http://www.roblox.com/asset/?id=742638842"},
            {Name = "Pirate Run", ID = "http://www.roblox.com/asset/?id=750783738"},
            {Name = "Sneaky Run", ID = "http://www.roblox.com/asset/?id=1132494274"},
            {Name = "Toy Run", ID = "http://www.roblox.com/asset/?id=782842708"},
            {Name = "Knight Run", ID = "http://www.roblox.com/asset/?id=657564596"},
            {Name = "Confident Run", ID = "http://www.roblox.com/asset/?id=1070001516"},
            {Name = "PopStar Run", ID = "http://www.roblox.com/asset/?id=1212980348"},
            {Name = "Princess Run", ID = "http://www.roblox.com/asset/?id=941015281"},
            {Name = "Cowboy Run", ID = "http://www.roblox.com/asset/?id=1014401683"},
            {Name = "Patrol Run", ID = "http://www.roblox.com/asset/?id=1150967949"},
            {Name = "Edited Zombie Run", ID = "http://www.roblox.com/asset/?id=3489173414"},
        }

        local RunList = {}


        for _, anim in ipairs(RunAnimations) do
            table.insert(RunList, anim.Name)
        end

        local selectedRunAnimID

        local dropdown = Animations:CreateDropdown("Run Animations", RunList, function(CurrentRunOption)
            function StopAnim()
                plr.Character.Animate.Disabled = false
                local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
                for _, track in pairs(animtrack) do
                    track:Stop()
                end
            end
        
        if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                    Message("Error!", "You're in R6", 5)
        return end
            StopAnim()
            plr.Character.Animate.Disabled = true
        
        
            for _, anim in ipairs(RunAnimations) do
                if anim.Name == CurrentRunOption then
                    selectedRunAnimID = anim.ID
                    break
                end
            end
        
        
            plr.Character.Animate.run:FindFirstChildOfClass("Animation").AnimationId = selectedRunAnimID
            plr.Character.Animate.Disabled = false
        
        end)

        Animations:CreateToggle("Auto Run", function(AutoRun)
                if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                
        return end
            getgenv().AutoRuns = AutoRun
                
                
            function onCharacterAdded(character)
                local humanoid = character:WaitForChild("Humanoid")
            
            
                if humanoid then
                if R6reanimated then return end
                                    local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                    if character.Animate.idle.Animation1.AnimationId ~= selectedRunAnimID then
                        character.Animate.run.RunAnim.AnimationId = selectedRunAnimID
                    end
                    end
                end
            end
        
        
            plr.CharacterAdded:Connect(onCharacterAdded)
        
        
            if plr.Character then
                onCharacterAdded(plr.Character)
            end
        
            while true do
                wait(0)
                if not getgenv().AutoRuns then
                    _G.AutoRuns = false
                    return
                end
            
                _G.AutoRuns = true
                local AutoRunConnection = nil
                AutoRunConnection = RunService.Stepped:Connect(function()
                    task.spawn(function()
                        if plr.Character then
                            if selectedRunAnimID then
                if R6reanimated then return end
                                                local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                                if not (plr.Character.Animate.idle.Animation1.AnimationId == selectedRunAnimID) then
                                    plr.Character.Animate.run:FindFirstChildOfClass("Animation").AnimationId = selectedRunAnimID
                                end
                                end
                            end
                        end
                    end)
                end)
            
                repeat task.wait() until _G.AutoRuns == false
                AutoRunConnection:Disconnect()
            end
        end)

        local JumpAnimations = {
            {Name = "Wicked Jump", ID = "http://www.roblox.com/asset/?id=104325245285198"},
            {Name = "Berry Avenue Jump", ID = "http://www.roblox.com/asset/?id=4211219390"},
            {Name = "Catwalk Glam Jump", ID = "http://www.roblox.com/asset/?id=116936326516985"},
            {Name = "NFL Jump", ID = "http://www.roblox.com/asset/?id=119846112151352"},
            {Name = "Bold Jump", ID = "http://www.roblox.com/asset/?id=16738336650"},
            {Name = "Adidas Sports Jump", ID = "http://www.roblox.com/asset/?id=18537380791"},
            {Name = "No Boundaries Jump", ID = "http://www.roblox.com/asset/?id=18747069148"},
            {Name = "Vampire Jump", ID = "http://www.roblox.com/asset/?id=1083455352"},
            {Name = "Hero Jump", ID = "http://www.roblox.com/asset/?id=616115533"},
            {Name = "Zombie Jump", ID = "http://www.roblox.com/asset/?id=616161997"},
            {Name = "Mage Jump", ID = "http://www.roblox.com/asset/?id=707853694"},
            {Name = "Levitation Jump", ID = "http://www.roblox.com/asset/?id=616008936"}, 
            {Name = "Elder Jump", ID = "http://www.roblox.com/asset/?id=845398858"}, 
            {Name = "Astronaut Jump", ID = "http://www.roblox.com/asset/?id=891627522"},
            {Name = "Ninja Jump", ID = "http://www.roblox.com/asset/?id=656117878"},
            {Name = "Werewolf Jump", ID = "http://www.roblox.com/asset/?id=1083218792"},
            {Name = "Cartoon Jump", ID = "http://www.roblox.com/asset/?id=742638842"},
            {Name = "Pirate Jump", ID = "http://www.roblox.com/asset/?id=750782230"},
            {Name = "Sneaky Jump", ID = "http://www.roblox.com/asset/?id=1132489853"},
            {Name = "Toy Jump", ID = "http://www.roblox.com/asset/?id=782847020"},
            {Name = "Knight Jump", ID = "http://www.roblox.com/asset/?id=658409194"},
            {Name = "Confident Jump", ID = "http://www.roblox.com/asset/?id=1069984524"},
            {Name = "PopStar Jump", ID = "http://www.roblox.com/asset/?id=1212954642"},
            {Name = "Princess Jump", ID = "http://www.roblox.com/asset/?id=941008832"},
            {Name = "Cowboy Jump", ID = "http://www.roblox.com/asset/?id=1014394726"},
            {Name = "Patrol Jump", ID = "http://www.roblox.com/asset/?id=1150944216"},
            {Name = "Edited Zombie Jump", ID = "http://www.roblox.com/asset/?id=616161997"},
        }

        local JumpList = {}


        for _, anim in ipairs(JumpAnimations) do
            table.insert(JumpList, anim.Name)
        end

        local selectedJumpAnimID

        local dropdown = Animations:CreateDropdown("Jump Animations", JumpList, function(CurrentJumpOption)
            function StopAnim()
                plr.Character.Animate.Disabled = false
                local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
                for _, track in pairs(animtrack) do
                    track:Stop()
                end
            end
        
        if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                    Message("Error!", "You're in R6", 5)
        return end
            StopAnim()
            plr.Character.Animate.Disabled = true
        
        
            for _, anim in ipairs(JumpAnimations) do
                if anim.Name == CurrentJumpOption then
                    selectedJumpAnimID = anim.ID
                    break
                end
            end
        
        
            plr.Character.Animate.jump:FindFirstChildOfClass("Animation").AnimationId = selectedJumpAnimID
            plr.Character.Animate.Disabled = false
        
        end)

        Animations:CreateToggle("Auto Jump", function(AutoJump)
                if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                
        return end
            getgenv().AutoJumps = AutoJump
                
                
            function onCharacterAdded(character)
                local humanoid = character:WaitForChild("Humanoid")
            
            
                if humanoid then
                if R6reanimated then return end
                                    local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                    if character.Animate.idle.Animation1.AnimationId ~= selectedJumpAnimID then
                        character.Animate.jump:FindFirstChildOfClass("Animation").AnimationId = selectedJumpAnimID
                    end
                    end
                end
            end
        
        
            plr.CharacterAdded:Connect(onCharacterAdded)
        
        
            if plr.Character then
                onCharacterAdded(plr.Character)
            end
        
            while true do
                wait(0)
                if not getgenv().AutoJumps then
                    _G.AutoJumps = false
                    return
                end
            
                _G.AutoJumps = true
                local AutoJumpConnection = nil
            
                AutoJumpConnection = RunService.Stepped:Connect(function()
                    task.spawn(function()
                        if plr.Character then
                            if selectedJumpAnimID then
                                if R6reanimated then return end
                                                                local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                                if not (plr.Character.Animate.idle.Animation1.AnimationId == selectedJumpAnimID) then
                                    plr.Character.Animate.jump:FindFirstChildOfClass("Animation").AnimationId = selectedJumpAnimID
                                end
                            end
                            end
                        end
                    end)
                end)
            
                repeat task.wait() until _G.AutoJumps == false
                AutoJumpConnection:Disconnect()
            end
        end)

        local ClimbAnimations = {
            {Name = "Wicked Climb", ID = "http://www.roblox.com/asset/?id=131326830509784"},
            {Name = "Berry Avenue Climb", ID = "http://www.roblox.com/asset/?id=4211214992"},
            {Name = "Catwalk Glam Climb", ID = "http://www.roblox.com/asset/?id=119377220967554"},
            {Name = "NFL Climb", ID = "http://www.roblox.com/asset/?id=134630013742019"},
            {Name = "Bold Climb", ID = "http://www.roblox.com/asset/?id=16738332169"},
            {Name = "Adidas Sports Climb", ID = "http://www.roblox.com/asset/?id=18537363391"},
            {Name = "No Boundaries Climb", ID = "http://www.roblox.com/asset/?id=18747060903"},
            {Name = "Vampire Climb", ID = "http://www.roblox.com/asset/?id=1083439238"},
            {Name = "Hero Climb", ID = "http://www.roblox.com/asset/?id=616104706"},
            {Name = "Zombie Climb", ID = "http://www.roblox.com/asset/?id=616156119"},
            {Name = "Mage Climb", ID = "http://www.roblox.com/asset/?id=707826056"},
            {Name = "Levitation Climb", ID = "http://www.roblox.com/asset/?id=616003713"}, 
            {Name = "Elder Climb", ID = "http://www.roblox.com/asset/?id=845392038"}, 
            {Name = "Astronaut Climb", ID = "http://www.roblox.com/asset/?id=891609353"},
            {Name = "Ninja Climb", ID = "http://www.roblox.com/asset/?id=656114359"},
            {Name = "Werewolf Climb", ID = "http://www.roblox.com/asset/?id=1083182000"},
            {Name = "Cartoon Climb", ID = "http://www.roblox.com/asset/?id=742636889"},
            {Name = "Pirate Climb", ID = "http://www.roblox.com/asset/?id=750779899"},
            {Name = "Sneaky Climb", ID = "http://www.roblox.com/asset/?id=1132461372"},
            {Name = "Toy Climb", ID = "http://www.roblox.com/asset/?id=782843869"},
            {Name = "Knight Climb", ID = "http://www.roblox.com/asset/?id=658360781"},
            {Name = "Confident Climb", ID = "http://www.roblox.com/asset/?id=1069946257"},
            {Name = "PopStar Climb", ID = "http://www.roblox.com/asset/?id=1213044953"},
            {Name = "Princess Climb", ID = "http://www.roblox.com/asset/?id=940996062"},
            {Name = "Cowboy Climb", ID = "http://www.roblox.com/asset/?id=1014380606"},
            {Name = "Patrol Climb", ID = "http://www.roblox.com/asset/?id=1148811837"},
            {Name = "Edited Zombie Climb", ID = "http://www.roblox.com/asset/?id=616156119"},
        }

        local ClimbList = {}


        for _, anim in ipairs(ClimbAnimations) do
            table.insert(ClimbList, anim.Name)
        end

        local selectedClimbAnimID

        local dropdown = Animations:CreateDropdown("Climb Animations", ClimbList, function(CurrentClimbOption)
            function StopAnim()
                plr.Character.Animate.Disabled = false
                local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
                for _, track in pairs(animtrack) do
                    track:Stop()
                end
            end
        
        if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                    Message("Error!", "You're in R6", 5)
        return end
            StopAnim()
            plr.Character.Animate.Disabled = true
        
        
            for _, anim in ipairs(ClimbAnimations) do
                if anim.Name == CurrentClimbOption then
                    selectedClimbAnimID = anim.ID
                    break
                end
            end
        
        
            plr.Character.Animate.climb.ClimbAnim.AnimationId = selectedClimbAnimID
            plr.Character.Animate.Disabled = false
        
        end)

        Animations:CreateToggle("Auto Climb", function(AutoClimb)
                if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                
        return end
            getgenv().AutoClimbs = AutoClimb
                
                
            function onCharacterAdded(character)
                local humanoid = character:WaitForChild("Humanoid")
            
            
                if humanoid then
                if R6reanimated then return end
                                    local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                        if character.Animate.idle.Animation1.AnimationId ~= selectedClimbAnimID then
                            character.Animate.climb.ClimbAnim.AnimationId = selectedClimbAnimID
                        end
                        end
                    end
                end
            
            
            plr.CharacterAdded:Connect(onCharacterAdded)
            
            
            if plr.Character then
                onCharacterAdded(plr.Character)
            end
        
            if not getgenv().AutoClimbs then
                _G.AutoClimbs = false
                return
            end
        
            _G.AutoClimbs = true
        
            local AutoClimbConnection = nil
        
            AutoClimbConnection = RunService.Stepped:Connect(function()
                task.spawn(function()
                    if plr.Character then
                        if selectedClimbAnimID then
                            if R6reanimated then return end
                                                            local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                            if not (plr.Character.Animate.idle.Animation1.AnimationId == selectedClimbAnimID) then
                                plr.Character.Animate.climb.ClimbAnim.AnimationId = selectedClimbAnimID
                            end
                            end
                        end
                    end
                end)
            end)
        
            repeat task.wait() until _G.AutoClimbs == false
            AutoClimbConnection:Disconnect()
        end)


        local FallAnimations = {
            {Name = "Wicked Fall", ID = "http://www.roblox.com/asset/?id=121152442762481"},
            {Name = "Berry Avenue Fall", ID = "http://www.roblox.com/asset/?id=4211216152"},
            {Name = "Catwalk Glam Fall", ID = "http://www.roblox.com/asset/?id=92294537340807"},
            {Name = "NFL Fall", ID = "http://www.roblox.com/asset/?id=129773241321032"},
            {Name = "Bold Fall", ID = "http://www.roblox.com/asset/?id=16738333171"},
            {Name = "Adidas Sports Fall", ID = "http://www.roblox.com/asset/?id=18537367238"},
            {Name = "No Boundaries Fall", ID = "http://www.roblox.com/asset/?id=18747062535"},
            {Name = "Vampire Fall", ID = "http://www.roblox.com/asset/?id=1083443587"},
            {Name = "Hero Fall", ID = "http://www.roblox.com/asset/?id=616108001"},
            {Name = "Zombie Fall", ID = "http://www.roblox.com/asset/?id=616157476"},
            {Name = "Mage Fall", ID = "http://www.roblox.com/asset/?id=707829716"},
            {Name = "Levitation Fall", ID = "http://www.roblox.com/asset/?id=616005863"},
            {Name = "Elder Fall", ID = "http://www.roblox.com/asset/?id=845396048"},
            {Name = "Astronaut Fall", ID = "http://www.roblox.com/asset/?id=891617961"},
            {Name = "Ninja Fall", ID = "http://www.roblox.com/asset/?id=656115606"},
            {Name = "Werewolf Fall", ID = "http://www.roblox.com/asset/?id=1083189019"},
            {Name = "Cartoon Fall", ID = "http://www.roblox.com/asset/?id=742637151"},
            {Name = "Pirate Fall", ID = "http://www.roblox.com/asset/?id=750780242"},
            {Name = "Sneaky Fall", ID = "http://www.roblox.com/asset/?id=1132469004"},
            {Name = "Toy Fall", ID = "http://www.roblox.com/asset/?id=782846423"},
            {Name = "Knight Fall", ID = "http://www.roblox.com/asset/?id=657600338"},
            {Name = "Confident Fall", ID = "http://www.roblox.com/asset/?id=1069973677"},
            {Name = "PopStar Fall", ID = "http://www.roblox.com/asset/?id=1212900995"},
            {Name = "Princess Fall", ID = "http://www.roblox.com/asset/?id=941000007"},
            {Name = "Cowboy Fall", ID = "http://www.roblox.com/asset/?id=1014384571"},
            {Name = "Patrol Fall", ID = "http://www.roblox.com/asset/?id=1148863382"},
            {Name = "Edited Zombie Fall", ID = "http://www.roblox.com/asset/?id=616157476"},
    }
    local FallList = {}


    for _, anim in ipairs(FallAnimations) do
        table.insert(FallList, anim.Name)
    end

    local selectedFallAnimID

    local dropdown = Animations:CreateDropdown("Fall Animations", FallList, function(CurrentFallOption)
        function StopAnim()
            plr.Character.Animate.Disabled = false
            local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
            for _, track in pairs(animtrack) do
                track:Stop()
            end
        end

    if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                Message("Error!", "You're in R6", 5)
    return end
        StopAnim()
        plr.Character.Animate.Disabled = true


        for _, anim in ipairs(FallAnimations) do
            if anim.Name == CurrentFallOption then
                selectedFallAnimID = anim.ID
                break
            end
        end


        plr.Character.Animate.fall:FindFirstChildOfClass("Animation").AnimationId = selectedFallAnimID
        plr.Character.Animate.Disabled = false

    end)

    Animations:CreateToggle("Auto Fall", function(AutoFall)
            if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
            
    return end
        getgenv().AutoFalls = AutoFall


        function onCharacterAdded(character)
            local humanoid = character:WaitForChild("Humanoid")


            if humanoid then 
                if R6reanimated then return end
                                                local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                if character.Animate.idle.Animation1.AnimationId ~= selectedFallAnimID then
                    character.Animate.fall:FindFirstChildOfClass("Animation").AnimationId = selectedFallAnimID
                end
                end
            end
        end


        plr.CharacterAdded:Connect(onCharacterAdded)


        if plr.Character then
            onCharacterAdded(plr.Character)
        end

        while true do
            wait(0)
            if not getgenv().AutoFalls then
                _G.AutoFalls = false
                return
            end

            _G.AutoFalls = true
            local AutoFallConnection = nil

            AutoFallConnection = RunService.Stepped:Connect(function()
                task.spawn(function()
                    if plr.Character then
                        if selectedFallAnimID then
                if R6reanimated then return end
                                    local character = plr.Character
                                if character then
                                    local animate = character:FindFirstChild("Animate")
                                if not animate then return end
                                if R6reanimated then return end
                            if not (plr.Character.Animate.idle.Animation1.AnimationId == selectedFallAnimID) then
                                plr.Character.Animate.fall:FindFirstChildOfClass("Animation").AnimationId = selectedFallAnimID
                            end
                            end
                        end
                    end
                end)
            end)

            repeat task.wait() until _G.AutoFalls == false
            AutoFallConnection:Disconnect()
        end
    end)
    local letters = {
    	["A"] = "", ["a"] = "",
    	["B"] = "", ["b"] = "",
    	["C"] = "", ["c"] = "",
    	["D"] = "", ["d"] = "",
    	["E"] = "", ["e"] = "",
    	["F"] = "", ["f"] = "",
    	["G"] = "", ["g"] = "",
    	["H"] = "", ["h"] = "",
    	["I"] = "", ["i"] = "",
    	["J"] = "", ["j"] = "",
    	["K"] = "", ["k"] = "",
    	["L"] = "", ["l"] = "",
    	["M"] = "", ["m"] = "",
    	["N"] = "", ["n"] = "",
    	["O"] = "", ["o"] = "",
    	["P"] = "", ["p"] = "",
    	["Q"] = "", ["q"] = "",
    	["R"] = "", ["r"] = "",
    	["S"] = "", ["s"] = "",
    	["T"] = "", ["t"] = "",
    	["U"] = "", ["u"] = "",
    	["V"] = "", ["v"] = "",
    	["W"] = "", ["w"] = "",
    	["X"] = "", ["x"] = "",
    	["Y"] = "", ["y"] = "",
    	["Z"] = "", ["z"] = ""
    }

    local prefixCharacter = " "
    local suffixCharacter = " "

    local tcs = game:GetService("TextChatService")
    local chats = game:GetService("Chat")
    local chat = tcs.ChatInputBarConfiguration.TargetTextChannel
    local ReplicatedStorage = game:GetService("ReplicatedStorage")


    local CurseLetters = {
    	["A"] = "", ["a"] = "", ["B"] = "", ["b"] = "",
    	["C"] = "", ["c"] = "", ["D"] = "", ["d"] = "",
    	["E"] = "", ["e"] = "", ["F"] = "", ["f"] = "",
    	["G"] = "", ["g"] = "", ["H"] = "", ["h"] = "",
    	["I"] = "", ["i"] = "", ["J"] = "", ["j"] = "",
    	["K"] = "", ["k"] = "", ["L"] = "", ["l"] = "",
    	["M"] = "", ["m"] = "", ["N"] = "", ["n"] = "",
    	["O"] = "", ["o"] = "", ["P"] = "", ["p"] = "",
    	["Q"] = "", ["q"] = "", ["R"] = "", ["r"] = "",
    	["S"] = "", ["s"] = "", ["T"] = "", ["t"] = "",
    	["U"] = "", ["u"] = "", ["V"] = "", ["v"] = "",
    	["W"] = "", ["w"] = "", ["X"] = "", ["x"] = "",
    	["Y"] = "", ["y"] = "", ["Z"] = "", ["z"] = ""
    }


    local NormalStyledLetters = {
    	["A"] = "", ["a"] = "", ["B"] = "", ["b"] = "",
    	["C"] = "", ["c"] = "", ["D"] = "", ["d"] = "",
    	["E"] = "", ["e"] = "", ["F"] = "", ["f"] = "",
    	["G"] = "", ["g"] = "", ["H"] = "", ["h"] = "",
    	["I"] = "", ["i"] = "", ["J"] = "", ["j"] = "",
    	["K"] = "", ["k"] = "", ["L"] = "", ["l"] = "",
    	["M"] = "", ["m"] = "", ["N"] = "", ["n"] = "",
    	["O"] = "", ["o"] = "", ["P"] = "", ["p"] = "",
    	["Q"] = "", ["q"] = "", ["R"] = "", ["r"] = "",
    	["S"] = "", ["s"] = "", ["T"] = "", ["t"] = "",
    	["U"] = "", ["u"] = "", ["V"] = "", ["v"] = "",
    	["W"] = "", ["w"] = "", ["X"] = "", ["x"] = "",
    	["Y"] = "", ["y"] = "", ["Z"] = "", ["z"] = "",
    	[" "] = " "
    }

    local CurseWords = {
    "2g1c",
    "2 girls 1 cup",
    "acrotomophilia",
    "alabama hot pocket",
    "alaskan pipeline",
    "anal",
    "anilingus",
    "anus",
    "apeshit",
    "arsehole",
    "ass",
    "asshole",
    "assmunch",
    "auto erotic",
    "autoerotic",
    "babeland",
    "baby batter",
    "baby juice",
    "ball gag",
    "ball gravy",
    "ball kicking",
    "ball licking",
    "ball sack",
    "ball sucking",
    "bangbros",
    "bangbus",
    "bareback",
    "barely legal",
    "barenaked",
    "bastard",
    "bastardo",
    "bastinado",
    "bbw",
    "bdsm",
    "beaner",
    "beaners",
    "beaver cleaver",
    "beaver lips",
    "beastiality",
    "bestiality",
    "big black",
    "big breasts",
    "big knockers",
    "big tits",
    "bimbos",
    "birdlock",
    "bitch",
    "bitches",
    "black cock",
    "blonde action",
    "blonde on blonde action",
    "blowjob",
    "blow job",
    "blow your load",
    "blue waffle",
    "blumpkin",
    "bollocks",
    "bondage",
    "boner",
    "boob",
    "boobs",
    "booty",
    "brown showers",
    "brunette action",
    "bukkake",
    "bulldyke",
    "bullet vibe",
    "bullshit",
    "bung hole",
    "bunghole",
    "busty",
    "butt",
    "buttcheeks",
    "butthole",
    "camel toe",
    "camgirl",
    "camslut",
    "camwhore",
    "carpet muncher",
    "carpetmuncher",
    "chocolate rosebuds",
    "cialis",
    "circlejerk",
    "cleveland steamer",
    "clit",
    "clitoris",
    "clover clamps",
    "clusterfuck",
    "cock",
    "cocks",
    "coprolagnia",
    "coprophilia",
    "cornhole",
    "coon",
    "coons",
    "creampie",
    "cum",
    "cumming",
    "cumshot",
    "cumshots",
    "cunnilingus",
    "cunt",
    "darkie",
    "date rape",
    "daterape",
    "deep throat",
    "deepthroat",
    "dendrophilia",
    "dick",
    "dildo",
    "dingleberry",
    "dingleberries",
    "dirty pillows",
    "dirty sanchez",
    "doggie style",
    "doggiestyle",
    "doggy style",
    "doggystyle",
    "dog style",
    "dolcett",
    "domination",
    "dominatrix",
    "dommes",
    "donkey punch",
    "double dong",
    "double penetration",
    "dp action",
    "condo",
    "dry hump",
    "dvda",
    "eat my ass",
    "ecchi",
    "ejaculation",
    "erotic",
    "erotism",
    "escort",
    "eunuch",
    "fag",
    "faggot",
    "fecal",
    "felch",
    "fellatio",
    "feltch",
    "female squirting",
    "femdom",
    "figging",
    "fingerbang",
    "fingering",
    "fisting",
    "foot fetish",
    "footjob",
    "frotting",
    "fuck",
    "fuck buttons",
    "fuckin",
    "fucking",
    "fucktards",
    "fudge packer",
    "fudgepacker",
    "futanari",
    "gangbang",
    "gang bang",
    "gay sex",
    "genitals",
    "giant cock",
    "girl on",
    "girl on top",
    "girls gone wild",
    "goatcx",
    "goatse",
    "god damn",
    "gokkun",
    "golden shower",
    "goodpoop",
    "goo girl",
    "goregasm",
    "grope",
    "group sex",
    "g-spot",
    "guro",
    "hand job",
    "handjob",
    "hard core",
    "hardcore",
    "hentai",
    "homoerotic",
    "honkey",
    "hooker",
    "horny",
    "hot carl",
    "hot chick",
    "how to kill",
    "how to murder",
    "huge fat",
    "humping",
    "incest",
    "intercourse",
    "jack off",
    "jail bait",
    "jailbait",
    "jelly donut",
    "jerk off",
    "jigaboo",
    "jiggaboo",
    "jiggerboo",
    "jizz",
    "juggs",
    "kike",
    "kinbaku",
    "kinkster",
    "kinky",
    "knobbing",
    "bbc",
    "leather restraint",
    "leather straight jacket",
    "lemon party",
    "livesex",
    "lolita",
    "lovemaking",
    "make me come",
    "male squirting",
    "masturbate",
    "masturbating",
    "masturbation",
    "menage a trois",
    "milf",
    "missionary position",
    "mong",
    "motherfucker",
    "mound of venus",
    "mr hands",
    "muff diver",
    "muffdiving",
    "nambla",
    "nawashi",
    "negro",
    "neonazi",
    "nigga",
    "nigger",
    "nig nog",
    "nimphomania",
    "nipple",
    "nipples",
    "nsfw",
    "nsfw images",
    "nude",
    "nudity",
    "nutten",
    "nympho",
    "nymphomania",
    "octopussy",
    "omorashi",
    "one cup two girls",
    "one guy one jar",
    "orgasm",
    "orgy",
    "paedophile",
    "paki",
    "panties",
    "panty",
    "pedobear",
    "pedophile",
    "pegging",
    "penis",
    "phone sex",
    "piece of shit",
    "skype",
    "messanger",
    "discord",
    "pikey",
    "pissing",
    "piss pig",
    "pisspig",
    "playboy",
    "pleasure chest",
    "pole smoker",
    "ponyplay",
    "poof",
    "poon",
    "poontang",
    "punany",
    "diddy",
    "poop chute",
    "poopchute",
    "porn",
    "porno",
    "pornography",
    "prince albert piercing",
    "pthc",
    "pubes",
    "pussy",
    "queaf",
    "queef",
    "quim",
    "raghead",
    "raging boner",
    "rape",
    "raping",
    "rapist",
    "rectum",
    "reverse cowgirl",
    "rimjob",
    "rimming",
    "rosy palm",
    "rosy palm and her 5 sisters",
    "rusty trombone",
    "sadism",
    "santorum",
    "scat",
    "schlong",
    "scissoring",
    "semen",
    "sex",
    "sexcam",
    "sexo",
    "sexy",
    "sexual",
    "sexually",
    "sexuality",
    "shaved beaver",
    "shaved pussy",
    "shemale",
    "shibari",
    "shit",
    "shitblimp",
    "shitty",
    "shota",
    "shrimping",
    "skeet",
    "slanteye",
    "slut",
    "s&m",
    "smut",
    "snatch",
    "snowballing",
    "sodomize",
    "sodomy",
    "spastic",
    "spic",
    "splooge",
    "splooge moose",
    "spooge",
    "spread legs",
    "spunk",
    "strap on",
    "strapon",
    "strappado",
    "strip club",
    "style doggy",
    "suck",
    "sucks",
    "suicide girls",
    "sultry women",
    "swastika",
    "swinger",
    "tainted love",
    "taste my",
    "tea bagging",
    "threesome",
    "throating",
    "thumbzilla",
    "tied up",
    "tight white",
    "tit",
    "tits",
    "titties",
    "titty",
    "tongue in a",
    "topless",
    "tosser",
    "towelhead",
    "tranny",
    "tribadism",
    "tub girl",
    "tubgirl",
    "tushy",
    "twat",
    "twink",
    "twinkie",
    "two girls one cup",
    "undressing",
    "upskirt",
    "urethra play",
    "urophilia",
    "vagina",
    "venus mound",
    "viagra",
    "vibrator",
    "violet wand",
    "vorarephilia",
    "voyeur",
    "voyeurweb",
    "voyuer",
    "vulva",
    "wank",
    "wetback",
    "finger",
    "wet dream",
    "white power",
    "whore",
    "worldsex",
    "wrapping men",
    "wrinkled starfish",
    "xx",
    "xxx",
    "yaoi",
    "yellow showers",
    "yiffy",
    "zoophilia",
    }


    local NormalizedCurseWords = {}
    for _, word in ipairs(CurseWords) do
    	NormalizedCurseWords[word:lower()] = true
    end


    function stylizeWord(word, isCurse)
    	local map = isCurse and CurseLetters or NormalStyledLetters
    	local output = {}
    	for i = 1, #word do
    		local c = word:sub(i, i)
    		table.insert(output, map[c] or map[c:lower()] or c)
    	end
    	return table.concat(output)
    end

    function containsCurseWord(word)
    	word = word:lower()
    	for curse in pairs(NormalizedCurseWords) do
    		if word:find(curse, 1, true) then
    			return true
    		end
    	end
    	return false
    end

    function filterMessage(message)
    	local result = {}
    	for word, space in message:gmatch("(%S+)(%s*)") do
    		local base = word:match("^%W*(%w+)%W*$") 
    		local isCurse = base and containsCurseWord(base)
    		local prefix = word:match("^(%W*)") or ""
    		local suffix = word:match("(%W*)$") or ""
    		local cleanWord = base or word
    		table.insert(result, prefix .. stylizeWord(cleanWord, isCurse) .. suffix .. space)
    	end
    	return table.concat(result)
    end

    function filter(message, _, prefix, suffix)
    	return prefix .. filterMessage(message) .. suffix
    end

    function sendChat(msg)
    	local converted = filter(msg, nil, prefixCharacter, suffixCharacter)
    	local filteredMessage = chats:FilterStringForBroadcast(converted, game.Players.LocalPlayer)
    	if filteredMessage ~= converted then
        
    	end

    	if tcs.ChatVersion == Enum.ChatVersion.LegacyChatService then
    		ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents").SayMessageRequest:FireServer(converted, "All")
    	else
    		chat:SendAsync(converted)
    	end
    end

    getgenv().ChatBypasserEnabled = false

    Universal:CreateToggle("Enable Chat Bypasser", function(state)
    	getgenv().ChatBypasserEnabled = state
    end)

    task.spawn(function()
    	local CoreGui = game:GetService("CoreGui")
    	local TextBox = CoreGui:WaitForChild("ExperienceChat")
    		:WaitForChild("appLayout")
    		:WaitForChild("chatInputBar")
    		:WaitForChild("Background")
    		:WaitForChild("Container")
    		:WaitForChild("TextContainer")
    		:WaitForChild("TextBoxContainer")
    		:WaitForChild("TextBox")

    	TextBox.FocusLost:Connect(function(enterPressed)
    		if enterPressed and getgenv().ChatBypasserEnabled then
    			local original = TextBox.Text
    			local converted = filterMessage(original)
    			TextBox.Text = converted
    		end
    	end)
    end)


    main:CreateBox("School Text Bypasser", "string", function(message)
        local conversionTable = letters
        converted = filter(message, conversionTable, prefixCharacter, suffixCharacter)
        local args = {
        	converted
        }
        game:GetService("ReplicatedStorage"):WaitForChild("EventTextSchool"):FireServer(unpack(args))
    end)

        Universal:CreateBox("Swastika in chat", "string", function(boxs)

        end)

        Universal:CreateButton("Clear Chat", function(OPENS) 
            sendChat("\u{001E}" .. string.rep("\u{000D}", 100) .. ".")
        end)

    local VoiceChatService = game:GetService("VoiceChatService")
    local VoiceChatInternal = cloneref(game:GetService("VoiceChatInternal"))

    local autoJoinEnabled = true
    local onVoiceModerated 


    local function setupAutoJoin()
        if autoJoinEnabled and (not onVoiceModerated or not onVoiceModerated.Connected) then
            onVoiceModerated = VoiceChatInternal.LocalPlayerModerated:Connect(function()
                task.wait(1)
                VoiceChatService:JoinVoice()
            end)
        end
    end


    local function stopAutoJoin()
        if onVoiceModerated and onVoiceModerated.Connected then
            onVoiceModerated:Disconnect()
        end
    end


    setupAutoJoin()


    Universal:CreateToggle("Disable Auto Join Voice Chat", function(state)
        autoJoinEnabled = not state 

        if autoJoinEnabled then
            setupAutoJoin()
        else
            stopAutoJoin()
        end
    end)


        Universal:CreateButton("Join Voice Chat", function()
            game:GetService("VoiceChatService"):joinVoice()
        end)
        Universal:CreateButton("Leave Voice Chat", function()
            local VoiceChat_Internal = cloneref and cloneref(game:GetService("VoiceChatInternal")) or game:GetService("VoiceChatInternal")
            VoiceChat_Internal:Leave()
        end)
        Universal:CreateButton("Chat bypasser (set ur language to   )", function()
        end)
        local AnimationLogger
        local loggedAnimations = {}
        local excludedAnimations = {
            "WalkAnim",
            "RunAnim",
            "Animation1",
            "JumpAnim",
            "FallAnim",
            "Animation2"
        }

        local allowDefaultAnims = false


        function getExcludedAnimationIds()
            local excludedIds = {}
            local animate = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Animate")
            if not animate then return excludedIds end
        
            local states = {"idle", "walk", "run", "jump", "fall", "climb", "swim", "sit"}
            for _, state in ipairs(states) do
                local stateFolder = animate:FindFirstChild(state)
                if stateFolder then
                    for _, anim in ipairs(stateFolder:GetChildren()) do
                        if anim:IsA("Animation") and anim.AnimationId then
                            local cleanId = anim.AnimationId:gsub("https?://www%.roblox%.com/asset/%?id=", "")
                            excludedIds[cleanId] = true
                        end
                    end
                end
            end
            return excludedIds
        end

        local excludedAnimationIds = getExcludedAnimationIds()


        function getLoggedAnimationList()
            local list = {}
            for _, animationName in pairs(loggedAnimations) do
                table.insert(list, animationName)
            end
            return list
        end


        function logAnimation(animationName, animationId)
            local cleanAnimationId = animationId:gsub("https?://www%.roblox%.com/asset/%?id=", "")


            if not allowDefaultAnims and excludedAnimationIds[cleanAnimationId] then
                return
            end
        
            if not loggedAnimations[animationId] then
                loggedAnimations[animationId] = animationName


                if AnimationLogger then
                    AnimationLogger:Refresh(getLoggedAnimationList())
                end
            end
        end

        local MarketplaceService = game:GetService("MarketplaceService")


        function onAnimationPlayed(animationTrack)
            local animation = animationTrack.Animation
            if animation then
                local animationId = animation.AnimationId
                local assetId = tonumber(string.match(animationId, "%d+"))
                if assetId then
                    local success, productInfo = pcall(function()
                        return MarketplaceService:GetProductInfo(assetId)
                    end)
                    if success and productInfo then
                        local animationName = productInfo.Name or "Unknown Animation"
                        logAnimation(animationName, animationId)
                    end
                end
            end
        end


        function trackPlayerAnimations()
            local player = game.Players.LocalPlayer
            function setup(character)
                local humanoid = character:WaitForChild("Humanoid")
                humanoid.AnimationPlayed:Connect(onAnimationPlayed)
            end
        
            if player.Character then
                setup(player.Character)
            end
            player.CharacterAdded:Connect(setup)
        end

        trackPlayerAnimations()



        Universal:CreateToggle("Allow Default Animations", function(state)
            allowDefaultAnims = state
        end)

        Universal:CreateButton("Clear All Logged Animations", function()
            loggedAnimations = {}
            if AnimationLogger then
                AnimationLogger:Refresh({})
            end
        end)

        Universal:CreateButton("Copy All Logged Animations", function()
            local allEntries = {}
            for animationId, animationName in pairs(loggedAnimations) do

                local cleanAnimationId = animationId
                    :gsub("https?://www%.roblox%.com/asset/%?id=", "")
                    :gsub("rbxassetid://", "") 
                table.insert(allEntries, string.format('["%s"] = %s,', animationName, cleanAnimationId))
            end
            setclipboard(table.concat(allEntries, "\n"))
        end)

        AnimationLogger = Universal:CreateDropdown2("Animation Logger", getLoggedAnimationList(), function(selectedAnimation)

            for animationId, animationName in pairs(loggedAnimations) do
                if animationName == selectedAnimation then
                    local cleanAnimationId = animationId
                        :gsub("https?://www%.roblox%.com/asset/%?id=", "")
                        :gsub("rbxassetid://", "") 
                    setclipboard(cleanAnimationId)
                    break
                end
            end
        end)



        if AnimationLogger then
            AnimationLogger:Refresh(getLoggedAnimationList())
        end

    local Players = game:GetService("Players")
    local HttpService = game:GetService("HttpService")

    local MessageLogger
    local loggedMessages = {}
    local folderPath = "HaxterFelix"
    local ChatLogsPath = "Chat Logs"

    local messageCounts = {}
    local debounceDelay = 0.5 
    local lastRefresh = 0
    local needsRefresh = false

    local loggingEnabled = false 


    function getLocalTime()
        local success, result = pcall(function()
            local date = os.date("*t")
            local hour = (date.hour % 12 == 0) and 12 or (date.hour % 12)
            local ampm = (date.hour < 12) and "AM" or "PM"
            return string.format("%d:%02d:%02d %s", hour, date.min, date.sec, ampm)
        end)
        return success and result or "Unknown"
    end


    function getLoggedMessageList()
        return loggedMessages
    end


    function logMessage(message)
        if not loggingEnabled then return end
        table.insert(loggedMessages, 1, message)
        needsRefresh = true
    end


    function saveMessageLogs()
        local logDir = folderPath .. "/" .. ChatLogsPath
        if not isfolder(folderPath) then
            makefolder(folderPath)
        end
        if not isfolder(logDir) then
            makefolder(logDir)
        end

        local fileName = logDir .. "/" .. os.time() .. "_ChatLog.txt"
        writefile(fileName, table.concat(loggedMessages, "\n"))
    end


    function setupChatListener(player)
        player.Chatted:Connect(function(msg)
            local currentTime = getLocalTime()
            local key = player.Name .. ": " .. msg

            messageCounts[key] = (messageCounts[key] or 0) + 1

            local outputMessage = currentTime .. " " .. player.Name .. ": " .. msg
            if messageCounts[key] > 1 then
                outputMessage = outputMessage .. " x" .. messageCounts[key]
            end

            logMessage(outputMessage)
        end)
    end


    Players.PlayerAdded:Connect(setupChatListener)
    for _, player in pairs(Players:GetPlayers()) do
        setupChatListener(player)
    end


    Universal:CreateButton("Clear All Logged Messages", function()
        loggedMessages = {}
        messageCounts = {}

        if MessageLogger and MessageLogger.Refresh then
            pcall(function()
                MessageLogger:Refresh({})
            end)
        end
    end)

    Universal:CreateButton("Copy All Logged Messages", function()
        setclipboard(table.concat(loggedMessages, "\n"))
    end)

    Universal:CreateButton("Save Message Logs", function()
        saveMessageLogs()
    end)


    Universal:CreateToggle("Message Logging", function(state)
        loggingEnabled = state
        local status = loggingEnabled and "enabled" or "disabled"
    end, true) 


    MessageLogger = Universal:CreateDropdown2("Message Logger", getLoggedMessageList(), function(selectedMessage)
        setclipboard(selectedMessage)
    end)


    if MessageLogger and MessageLogger.Refresh then
        pcall(function()
            MessageLogger:Refresh(getLoggedMessageList())
        end)
    end


    task.spawn(function()
        while true do
            task.wait(debounceDelay)
            if needsRefresh and MessageLogger and MessageLogger.Refresh then
                needsRefresh = false
                pcall(function()
                    MessageLogger:Refresh(getLoggedMessageList())
                end)
            end
        end
    end)

        local SkidFling = function(TargetPlayer)
        local Character = plr.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Humanoid and Humanoid.RootPart

        local TCharacter = TargetPlayer.Character
        local THumanoid = TCharacter and TCharacter:FindFirstChildOfClass("Humanoid")
        local TRootPart = THumanoid and THumanoid.RootPart
        local THead = TCharacter:FindFirstChild("Head")

        if Character and Humanoid and RootPart then

            OriginalCFrame = RootPart.CFrame
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0
            local humanoid = plr.Character:FindFirstChildWhichIsA("Humanoid")
            local originalHipHeight = humanoid.HipHeight

            if RootPart.Velocity.Magnitude < 50 then
                getgenv().OldPos = RootPart.CFrame
            end
            if THumanoid and THumanoid.Sit and not AllBool then
                return Message("Error Occurred", "Targeting is sitting", 5)
            end
            if THead then
                workspace.CurrentCamera.CameraSubject = THead
            elseif THumanoid and TRootPart then
                workspace.CurrentCamera.CameraSubject = THumanoid
            end

            local FPos = function(BasePart, Pos, Ang)
                RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
                Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
                RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
                RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
            end

            local SFBasePart = function(BasePart)


                wait(0.3)
                repeat
                    if RootPart and THumanoid then
                        if BasePart.Velocity.Magnitude < 50 then
                            Angle = -90
                            FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                        else
                            FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(-90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(-90, 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(-90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(-90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(-90, 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(-90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(-90, 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                            task.wait()

                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        end
                    else
                        break
                    end
                until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
            end

            workspace.FallenPartsDestroyHeight = 0/0

            local BV = Instance.new("BodyVelocity")
            BV.Name = "EpixVel"
            BV.Parent = RootPart
            BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
            BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)

            if TRootPart and THead then
                if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                    SFBasePart(THead)
                else
                    SFBasePart(TRootPart)
                end
            elseif TRootPart and not THead then
                SFBasePart(TRootPart)
            elseif not TRootPart and THead then
                SFBasePart(THead)
            elseif not TRootPart and not THead and Accessory and Handle then
                SFBasePart(Handle)
            else
                return Message("Error Occurred", "Target is missing everything", 5)
            end


            repeat
                task.wait()
                RootPart.Velocity = Vector3.new(0, 0, 0)
                RootPart.RotVelocity = Vector3.new(0, 0, 0)
                wait(0)
            until RootPart.Velocity.Magnitude < 0.1

            StopAllAnims()
            RootPart.Velocity = Vector3.new(0, 0, 0)
            RootPart.RotVelocity = Vector3.new(0, 0, 0)
            BV:Destroy()
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
            workspace.CurrentCamera.CameraSubject = Humanoid


            Character:SetPrimaryPartCFrame(OriginalCFrame)
            RootPart.Velocity = Vector3.new(0, 0, 0)
            RootPart.RotVelocity = Vector3.new(0, 0, 0)
            Character:SetPrimaryPartCFrame(OriginalCFrame)
            RootPart.Velocity = Vector3.new(0, 0, 0)
            RootPart.RotVelocity = Vector3.new(0, 0, 0)
            Character:SetPrimaryPartCFrame(OriginalCFrame)
            RootPart.Velocity = Vector3.new(0, 0, 0)
            RootPart.RotVelocity = Vector3.new(0, 0, 0)
            Character:SetPrimaryPartCFrame(OriginalCFrame)
            RootPart.Velocity = Vector3.new(0, 0, 0)
            RootPart.RotVelocity = Vector3.new(0, 0, 0)
            wait(0.1)
            if TRootPart.Velocity.Magnitude > 50 then
                Message("Player Was Flung", TargetPlayer, 5)
                    end
        else
            return Message("Error Occurred", "Random error", 5)
        end
    end



    local SkidFlingKill = function(TargetPlayer)
        local Character = plr.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Humanoid and Humanoid.RootPart

        local TCharacter = TargetPlayer.Character
        local THumanoid = TCharacter and TCharacter:FindFirstChildOfClass("Humanoid")
        local TRootPart = THumanoid and THumanoid.RootPart
        local THead = TCharacter:FindFirstChild("Head")

        if Character and Humanoid and RootPart then

            OriginalCFrame = RootPart.CFrame
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0
            local humanoid = plr.Character:FindFirstChildWhichIsA("Humanoid")
            local originalHipHeight = humanoid.HipHeight

            if RootPart.Velocity.Magnitude < 50 then
                getgenv().OldPos = RootPart.CFrame
            end
            if THumanoid and THumanoid.Sit and not AllBool then
                return Message("Error Occurred", "Targeting is sitting", 5)
            end
            if THead then
                workspace.CurrentCamera.CameraSubject = THead
            elseif THumanoid and TRootPart then
                workspace.CurrentCamera.CameraSubject = THumanoid
            end

            local FPos = function(BasePart, Pos, Ang)

                local AboveHeadPosition = BasePart.Position + Vector3.new(0, 2.5, 0) 
                RootPart.CFrame = CFrame.new(AboveHeadPosition) * Pos * Ang
            

                local currentVelocity = RootPart.Velocity
                local downwardForce = Vector3.new(0, -9e7, 0) 
            

                if currentVelocity.Y > 0 then
                    downwardForce = downwardForce + Vector3.new(0, -currentVelocity.Y * 10, 0) 
                end
            
                RootPart.Velocity = downwardForce
                RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
            end

            local SFBasePart = function(BasePart)
                plr.Character.Humanoid:ChangeState(3)
            
                wait(0.3)
                repeat
                    if RootPart and THumanoid then
                        if BasePart.Velocity.Magnitude < 50 then
                            Angle = -90


                            FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(2.25, -1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                        else
                            FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        
                            FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(-90, 0, 0))
                            task.wait()
                        end
                    else
                        break
                    end
                until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
            end

                       workspace.FallenPartsDestroyHeight = 0/0

            local BV = Instance.new("BodyVelocity")
            BV.Name = "EpixVel"
            BV.Parent = RootPart
            BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
            BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)

            if TRootPart and THead then
                 if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                              SFBasePart(THead)
                              else
                              SFBasePart(TRootPart)
                          end
                      elseif TRootPart and not THead then
                          SFBasePart(TRootPart)
                      elseif not TRootPart and THead then
                          SFBasePart(THead)
                      elseif not TRootPart and not THead and Accessory and Handle then
                          SFBasePart(Handle)
                      else
                          return Message("Error Occurred", "Target is missing everything", 5)
            end

            repeat
                task.wait()
                RootPart.Velocity = Vector3.new(0, 0, 0)
                RootPart.RotVelocity = Vector3.new(0, 0, 0)
                wait(0)
            until RootPart.Velocity.Magnitude < 0.1
            plr.Character.Humanoid:ChangeState(3)
            StopAllAnims()
            RootPart.Velocity = Vector3.new(0, 0, 0)
            RootPart.RotVelocity = Vector3.new(0, 0, 0)
            BV:Destroy()
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
            workspace.CurrentCamera.CameraSubject = Humanoid
    wait(0.3)

            Character:SetPrimaryPartCFrame(OriginalCFrame)
            RootPart.Velocity = Vector3.new(0, 0, 0)
            RootPart.RotVelocity = Vector3.new(0, 0, 0)
            Character:SetPrimaryPartCFrame(OriginalCFrame)
            RootPart.Velocity = Vector3.new(0, 0, 0)
            RootPart.RotVelocity = Vector3.new(0, 0, 0)
            Character:SetPrimaryPartCFrame(OriginalCFrame)
            RootPart.Velocity = Vector3.new(0, 0, 0)
            RootPart.RotVelocity = Vector3.new(0, 0, 0)
            Character:SetPrimaryPartCFrame(OriginalCFrame)
            RootPart.Velocity = Vector3.new(0, 0, 0)
            RootPart.RotVelocity = Vector3.new(0, 0, 0)
        else
            return Message("Error Occurred", "Random error", 5)
        end
    end

        Target:CreateBox("Target Name", "string", function(Targetnm)
            Targetnms = Targetnm
            local TargetPlayer = GetPlayer(Targetnms)
            if TargetPlayer then
            Message("Target", Targetnms, 5)
            else
            Message("Error!", "Target not found", 5)
            end
        end)
    local arrowGui = nil
    local target = nil
    local hoveredModel = nil
    local mouse = game.Players.LocalPlayer:GetMouse()


    function createArrowFor(model)
    	local head = model:FindFirstChild("Head")
    	if not head then return end

    	arrowGui = Instance.new("BillboardGui")
    	arrowGui.Name = "TargetArrow"
    	arrowGui.Adornee = head
    	arrowGui.Size = UDim2.new(0, 40, 0, 40)
    	arrowGui.StudsOffset = Vector3.new(0, 2.5, 0)
    	arrowGui.AlwaysOnTop = true

    	local imageLabel = Instance.new("ImageLabel")
    	imageLabel.Size = UDim2.new(1, 0, 1, 0)
    	imageLabel.BackgroundTransparency = 1
    	imageLabel.Image = "rbxassetid://6031090990" 
    	imageLabel.ImageColor3 = Color3.fromRGB(170, 0, 255)
    	imageLabel.Rotation = 0
    	imageLabel.Parent = arrowGui

    	arrowGui.Parent = game.CoreGui
    end


    function cleanup()
    	if arrowGui then
    		arrowGui:Destroy()
    		arrowGui = nil
    	end
    	hoveredModel = nil
    end


    function activateTargetSelection()
    	game:GetService("RunService").RenderStepped:Connect(function()
    		if not getgenv().ClickTargetToggles then
    			cleanup()
    			return
    		end

    		local current = mouse.Target and mouse.Target:FindFirstAncestorOfClass("Model")
    		if current and current:FindFirstChild("Humanoid") then
    			if current ~= hoveredModel then
    				cleanup()
    				hoveredModel = current
    				createArrowFor(hoveredModel)
    			end
    		else
    			cleanup()
    		end
    	end)

    	mouse.Button1Up:Connect(function()
    		if getgenv().ClickTargetToggles and hoveredModel then
    			target = hoveredModel
    			Targetnms = target.Name
    			Message("Target", Targetnms, 2.3)
    		end
    	end)
    end


    Target:CreateToggle("Select Target", function(ClickTargetToggle)
    	getgenv().ClickTargetToggles = ClickTargetToggle
    	if ClickTargetToggle then
    		activateTargetSelection()
    		Message("Click", "Hover a player", 3)
    	else
    		cleanup()
    	end
    end)

    Target:CreateButton("Go To Target", function()
        local TargetPlayer = GetPlayer(Targetnms)
        if TargetPlayer then
            plr.Character.HumanoidRootPart.CFrame = TargetPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0,0,5)
        else
            Message("Error Occurred", "Username Invalid", 5)
        end
    end)


    local isSpectating = false
    local targetPlayer = nil

    Target:CreateToggle("Spectate Target", function(SpecateTarget)
        getgenv().SpecateTargets = SpecateTarget


        while true do
            wait(0)  

            if not getgenv().SpecateTargets then

                isSpectating = false
                targetPlayer = nil

                local Character = plr.Character
                local HumanoidRP = Character and Character:FindFirstChild("HumanoidRootPart")


                if Character then
                    if reanimated then
                        workspace.CurrentCamera.CameraSubject = plr.Character.Model.Humanoid
                    else
                        workspace.CurrentCamera.CameraSubject = plr.Character.Humanoid
                    end
                end
                return
            end

            local TargetPlayer = GetPlayer(Targetnms)

            if TargetPlayer then
                isSpectating = true
                targetPlayer = TargetPlayer


                while isSpectating do

                    if not IsPlayerInGame(targetPlayer) then
                        Message("Player Left", "The player you were spectating has left the game.", 5)
                        workspace.CurrentCamera.CameraSubject = plr.Character.Humanoid
                        break
                    end


                    if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local THead = targetPlayer.Character:FindFirstChild("Head")
                        local THumanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")

                        if THead then
                            workspace.CurrentCamera.CameraSubject = THumanoid
                        elseif THumanoid then
                            workspace.CurrentCamera.CameraSubject = THead
                        end
                    end

                    wait(0) 
                end
            end
        end
    end)

    local orbitEnabled = false
    local radius = 10
    local heightOffset = 5
    local rotationSpeed = math.rad(45)
    local TiltAngleZ = 0
    local verticalWave = false
    local _wave = 1
    local smoothedWave = _wave
    local smoothedTiltZ = TiltAngleZ

    local CharacterOrder = {
    	"Head", "UpperTorso", "LowerTorso",
    	"LeftUpperArm", "LeftLowerArm", "LeftHand",
    	"RightUpperArm", "RightLowerArm", "RightHand",
    	"LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    	"RightUpperLeg", "RightLowerLeg", "RightFoot"
    }

    local orbitParts = {}
    local angleOffset = 0
    local waveTime = 0
    local TargetPlayer = nil
    local lockConnection, orbitConnection, diedConnection
    local originalCFrame = nil
    local Character, HumanoidRootPart

    local function GetPlayer(name)
    	for _, plr in ipairs(game:GetService("Players"):GetPlayers()) do
    		if plr.Name:lower():match(name:lower()) then
    			return plr
    		end
    	end
    end

    local function setupRealOrbitParts()
    	orbitParts = {}
    	for _, name in ipairs(CharacterOrder) do
    		local part = Character:FindFirstChild(name)
    		if part and part:IsA("MeshPart") then
    			part.Parent.HumanoidRootPart.Anchored = true
    			part.Anchored = true
    			table.insert(orbitParts, part)
    		end
    	end
    end

    Target:CreateToggle("Enable Orbit", function(state)
    	orbitEnabled = state

    	if not R15reanimated then
    		Message("Error!", "Enable Reanimation", 5)
    		return
    	end

    	if state then
    		Character = plr.Character or plr.CharacterAdded:Wait()
    		HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

    		local humanoid = Character:FindFirstChildOfClass("Humanoid")
    		if humanoid then
    			if diedConnection then diedConnection:Disconnect() end
    			diedConnection = humanoid.Died:Connect(function()
    				orbitEnabled = false
    				workspace.CurrentCamera.CameraSubject = humanoid
    				if lockConnection then lockConnection:Disconnect() end
    				if orbitConnection then orbitConnection:Disconnect() end
    				for _, part in ipairs(orbitParts) do
    					if part:IsA("BasePart") then
    						part.Anchored = false
    						if part.Parent and part.Parent:FindFirstChild("HumanoidRootPart") then
    							part.Parent.HumanoidRootPart.Anchored = false
    						end
    					end
    				end
    				orbitParts = {}
    				originalCFrame = nil
    			end)
    		end

    		local candidate = GetPlayer(Targetnms)
    		if candidate and candidate.Character and candidate.Character:FindFirstChild("HumanoidRootPart") then
    			TargetPlayer = candidate
    			originalCFrame = HumanoidRootPart.CFrame

    			local camTarget = TargetPlayer.Character:FindFirstChildOfClass("Humanoid") or TargetPlayer.Character:FindFirstChild("Head")
    			if camTarget then
    				workspace.CurrentCamera.CameraSubject = camTarget
    			end

    			setupRealOrbitParts()

    			if lockConnection then lockConnection:Disconnect() end
    			lockConnection = game:GetService("RunService").Heartbeat:Connect(function()
    				local found = GetPlayer(Targetnms)
    				if found and found ~= TargetPlayer then TargetPlayer = found end
    				local targetHRP = TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
    				local camTarget = TargetPlayer.Character:FindFirstChildOfClass("Humanoid") or TargetPlayer.Character:FindFirstChild("Head")
    				if targetHRP and HumanoidRootPart then
    					HumanoidRootPart.CFrame = targetHRP.CFrame * CFrame.new(0, 0.5, 0)
    					workspace.CurrentCamera.CameraSubject = camTarget
    				end
    			end)

    			if orbitConnection then orbitConnection:Disconnect() end
    			orbitConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
    				if not orbitEnabled or not HumanoidRootPart then return end

    				smoothedWave = smoothedWave + (_wave - smoothedWave) * dt * 10
    				smoothedTiltZ = smoothedTiltZ + (TiltAngleZ - smoothedTiltZ) * dt * 10

    				local targetHRP = TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
    				local centerCFrame = targetHRP and targetHRP.CFrame or HumanoidRootPart.CFrame
    				local centerPos = centerCFrame.Position + Vector3.new(0, heightOffset, 0)
    				angleOffset += rotationSpeed * dt
    				local tiltCFrame = CFrame.Angles(0, 0, math.rad(smoothedTiltZ))

    				for i, part in ipairs(orbitParts) do
    					local t = i / #orbitParts
    					local angle = angleOffset + t * math.pi * 2
    					local offset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
    					local finalOffset = tiltCFrame:VectorToWorldSpace(offset)
    					local finalPos = centerPos + finalOffset

    					if verticalWave then
                            waveTime += dt * smoothedWave * 0.7
                            finalPos += Vector3.new(0, math.sin(waveTime + i) * smoothedWave, 0)
    					end

    					if part ~= HumanoidRootPart then
    						part.CFrame = CFrame.new(finalPos, centerPos)
    					end
    				end
    			end)
    		else
    			Message("Error Occurred", "Username Invalid", 5)
    		end
    	else
    		orbitEnabled = false
    		local humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    		if humanoid then
    			workspace.CurrentCamera.CameraSubject = humanoid
    			humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    		end
    		if originalCFrame and Character and Character:FindFirstChild("HumanoidRootPart") then
    			Character.HumanoidRootPart.CFrame = originalCFrame
    		end
    		for _, part in ipairs(orbitParts) do
    			if part:IsA("BasePart") then
    				part.Anchored = false
    				if part.Parent and part.Parent:FindFirstChild("HumanoidRootPart") then
    					part.Parent.HumanoidRootPart.Anchored = false
    				end
    			end
    		end
    		orbitParts = {}
    		if lockConnection then lockConnection:Disconnect(); lockConnection = nil end
    		if orbitConnection then orbitConnection:Disconnect(); orbitConnection = nil end
    		if diedConnection then diedConnection:Disconnect(); diedConnection = nil end
    	end
    end)

    Target:CreateSlider("Orbit Speed", 1, 1000, 10, function(val)
    	rotationSpeed = math.rad(val)
    end)

    Target:CreateSlider("Orbit Radius", 1, 50, radius, function(val)
    	radius = val
    end)

    Target:CreateSlider("Orbit Height", -50, 50, 0, function(val)
    	heightOffset = val
    end)

    Target:CreateSlider("Tilt Left/Right", -90, 90, 0, function(val)
    	TiltAngleZ = val
    end)

    Target:CreateToggle("Vertical Wave", function(val)
    	verticalWave = val
    end)

    Target:CreateSlider("Wave Strength", 0, 10, _wave, function(val)
    	_wave = val
    end)

    local OrbitModes = Target:CreateDropdown("Kill Player Animations", VoidPlayerOptions, function(VoidPlayer)

    end)

    function IsPlayerInGame(player)

                return true 
            end


            function IsPlayerInGame(player)

                return true 
            end


            function IsPlayerInGame(player)

                return true 
            end

            function GetMyCharacter()

                return plr.Character 
            end


            function IsPlayerInGame(player)

                return true 
    end

    local Prefix = ":"
    local Admins = {} 
    local adminFilePath = "admins.txt" 


    function loadAdmins()
        if not isfile(adminFilePath) then
            print("Admin file not found. Creating a new one.")

            writefile(adminFilePath, "")
            print("Admin file created successfully.")
        end

        local fileContent = readfile(adminFilePath)

        if fileContent then
            for line in fileContent:gmatch("[^\r\n]+") do
                Admins[line:lower()] = true 
            end
        else
            print("Could not read admin file.")
        end
    end



    function isAdmin(playerName)
        return Admins[playerName:lower()] == true
    end


    function resetCharacter(player)
        if player.Character then
            player.Character:BreakJoints()
        end
    end


    function handleCommand(player, cmd, targetName)
        if cmd == "reset" then
            resetCharacter(player)  
        elseif cmd == "fling" then
            local targetPlayer = nil


            for _, p in pairs(game.Players:GetPlayers()) do
                if string.sub(p.Name:lower(), 1, #targetName) == targetName:lower() or 
                   string.sub(p.DisplayName:lower(), 1, #targetName) == targetName:lower() then
                    targetPlayer = p
                    break
                end
            end

            if targetPlayer then
                SkidFlingKill(targetPlayer)  
            else
                print("Target player not found.")
            end
        elseif cmd == "cmds" then 
            print("Available commands: reset, fling, cmds")
        else
            print("Unknown command: " .. cmd)  
        end
    end


    loadAdmins()


    for _, player in pairs(game.Players:GetPlayers()) do
        player.Chatted:Connect(function(msg)
            msg = msg:lower()  
            if string.sub(msg, 1, 3) == "/e " then
                msg = string.sub(msg, 4)  
            end

            if string.sub(msg, 1, 1) == Prefix then
                local cmd
                local space = string.find(msg, " ")
                if space then
                    cmd = string.sub(msg, 2, space - 1)  
                    local targetName = string.sub(msg, space + 1)  
                else
                    cmd = string.sub(msg, 2)  
                    local targetName = ""
                end

                if isAdmin(player.Name) then
                    handleCommand(player, cmd, targetName)  
                else
                    print("You do not have permission to use this command.")
                end
            end
        end)
    end

    local VoidPlayerOption = "None" 

    Target:CreateButton("Fling The Target", function()
        local TargetPlayer = GetPlayer(Targetnms)

        if VoidPlayerOption == "None" then 
            if TargetPlayer then
                if flying then  

                    flying = false  
                    SkidFling(TargetPlayer)                

                    flying = true  
                else
                    SkidFling(TargetPlayer)                
                end
            else
                Message("Error Occurred", "Username Invalid", 5)
            end
        else

            if VoidPlayerOption == "Neighbourhood Hero uppercut" then


            elseif VoidPlayerOption == "Slam" then


            end
        end
    end)

    Target:CreateToggle("Flinger The Target", function(ToggleFlingTheTarget)
        getgenv().ToggleFlingTheTargets = ToggleFlingTheTarget
           while true do wait(0)  

            if not getgenv().ToggleFlingTheTargets then
    return end 
        local TargetPlayer = GetPlayer(Targetnms)
            
        if VoidPlayerOption == "None" then 
            if TargetPlayer then
                if flying then  

                    flying = false  
                            RVelocity = GetRoot(plr).Velocity 
                            GetRoot(plr).Velocity = Vector3.new(math.random(-150,150),-25000,math.random(-150,150))
                            GetRoot(plr).Velocity = RVelocity

                    flying = true  
                else
                    SkidFling(TargetPlayer)                
                end
            else
                Message("Error Occurred", "Username Invalid", 5)
            end
        else

            if VoidPlayerOption == "Neighbourhood Hero uppercut" then


            elseif VoidPlayerOption == "Slam" then


            end
        end
    end
    end)

    local VoidPlayerOptions = {
        option1 = "None", 
        option2 = "Neighbourhood Hero uppercut", 
        option3 = "Slam" 
    }

    local dropdown = Target:CreateDropdown("Kill Player Animations", VoidPlayerOptions, function(VoidPlayer)
        VoidPlayerOption = VoidPlayer 

    end)

    Reanimate:CreateDropdown("Animation", TargetAnimation, function(TargetAnimationssss)
        mode = TargetAnimationssss
        if not R6reanimated then 
            Message("Error:", "Please Reanimate", 5)
            return 
        end


        AnimationActive = false
        StopAnim = true

        if connection then
            connection:Disconnect()
            connection = nil
        end


        local character = plr.Character or plr.CharacterAdded:Wait()
        local humanoid = character:FindFirstChild("Humanoid")
        local animate = character:FindFirstChild("Animate")

        if humanoid then
            local animator = humanoid:FindFirstChild("Animator")
            if animator then animator:Destroy() end
            humanoid.AutomaticScalingEnabled = false
        end

        if animate then
            animate.Enabled = false
        end


        local joints = {
            ["Torso"] = character.HumanoidRootPart:FindFirstChild("RootJoint"),
            ["Right Arm"] = character.Torso:FindFirstChild("Right Shoulder"),
            ["Left Arm"] = character.Torso:FindFirstChild("Left Shoulder"),
            ["Head"] = character.Torso:FindFirstChild("Neck"),
            ["Left Leg"] = character.Torso:FindFirstChild("Left Hip"),
            ["Right Leg"] = character.Torso:FindFirstChild("Right Hip")
        }

        local cf = CFrame.new
        local originalCFrames = {
            ["Torso"] = { C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
            ["Right Arm"] = { C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0), C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0) },
            ["Left Arm"] = { C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
            ["Head"] = { C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0), C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) },
            ["Left Leg"] = { C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0), C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0) },
            ["Right Leg"] = { C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0), C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0) }
        }

        for jointName, joint in pairs(joints) do
            if joint then
                joint.C0 = originalCFrames[jointName].C0
                joint.C1 = originalCFrames[jointName].C1
                joint.Transform = CFrame.new() 
            end
        end


        local newAnimator = Instance.new("Animator")
        newAnimator.Parent = humanoid
        wait(0.05)
        StopAnim = false
        AnimationActive = true
        if animate then
            animate.Enabled = true
            local defaultAnimId = "http://www.roblox.com/asset/?id=180435571"
            animate.idle.Animation1.AnimationId = defaultAnimId
            animate.idle.Animation2.AnimationId = defaultAnimId
            animate.walk:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.run:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.jump:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
            animate.fall:FindFirstChildOfClass("Animation").AnimationId = defaultAnimId
        end
            wait(0.1)

            local character = plr.Character or plr.CharacterAdded:Wait()
            local humanoid = character:WaitForChild("Humanoid")
            local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
            local RootJoint = HumanoidRootPart["RootJoint"]
            local RightShoulder = character.Torso["Right Shoulder"]
            local LeftShoulder = character.Torso["Left Shoulder"]
            local Neck = character.Torso["Neck"]
            local LeftHip = character.Torso["Left Hip"]
            local RightHip = character.Torso["Right Hip"]

        if plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid:FindFirstChild("Animator") then
            plr.Character.Humanoid.Animator:Destroy()
        end
        if plr.Character:FindFirstChild("Animate") then
            plr.Character.Animate.Enabled = false
        end
            local animate = plr.Character:FindFirstChild("Animate")
        if animate then animate.Enabled = false end
                if connection then 
                    connection:Disconnect()  
                end
            
            
                local runService = game:GetService("RunService")
                local sine = 0
            
                connection = runService.RenderStepped:Connect(function(deltaTime)
                    sine += deltaTime * R67 / 1
                    deltaTime = clamp(deltaTime * 10, 0, 1)
                    plr.Character.Humanoid.Sit = true
                    local vel = HumanoidRootPart.Velocity
                    local onGround = humanoid:GetState() == Enum.HumanoidStateType.Freefall
            local humanoidRootPartVelocity  = character:FindFirstChild("HumanoidRootPart").Velocity 
            game.Workspace.Gravity = 0

        if vel.Magnitude < 1 then 
            if mode == "Hawk Tuah" then
                Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,-0.2+0.1*sin(sine*4)),angles(-1.4835298641951802+0.12217304763960307*sin(sine*4),0,3.141592653589793)),deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.7,-0.8,-0.2+0.2*sin(sine*4)),angles(-1.1344640137963142+0.12217304763960307*sin(sine*-4),0.17453292519943295,0)),deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.3,0),angles(-2.007128639793479+0.12217304763960307*sin(sine*4),0,3.141592653589793)),deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.1,0),angles(2.443460952792061+0.29670597283903605*sin(sine*-4),-1.5707963267948966,0)),deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.7,-0.8,-0.2+0.2*sin(sine*4)),angles(-1.1344640137963142+0.12217304763960307*sin(sine*-4),-0.17453292519943295,0)),deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.1,0),angles(2.443460952792061+0.29670597283903605*sin(sine*-4),1.5707963267948966,0)),deltaTime) 

                local TargetPlayer = GetPlayer(Targetnms)
                if TargetPlayer then
                    local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                    plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, -0.7, -1.7) * CFrame.Angles(0, math.rad(180), 0)
                    plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
                end
            elseif mode == "Thrust On Face" then
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1,-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966+0.2617993877991494*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+2)*5),0,-0.3490658503988659)),deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295-0.3490658503988659*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+2)*5),0,0.3490658503988659)),deltaTime) 

                local TargetPlayer = GetPlayer(Targetnms)
                if TargetPlayer then
                    local targetCFrame = TargetPlayer.Character.Head.CFrame
                    plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 1, -1) * CFrame.Angles(0, math.rad(180), 0)
                    plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
                end
            elseif mode == "Back Fuck" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+3)*-5),0,0.3490658503988659)),deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(2.6179938779914944+0.2617993877991494*sin((sine+1)*-5),0,-0.3490658503988659)),deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295-0.3490658503988659*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1,-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966+0.2617993877991494*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 

                local TargetPlayer = GetPlayer(Targetnms)
                if TargetPlayer then
                    local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                    plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 0, 1)
                    plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
                end
            elseif mode == "Lap Dance" then
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.2,0.5,-0.7),angles(0.6981317007977318-0.5235987755982988*sin(sine*20),0.3490658503988659,-0.5235987755982988+0.3490658503988659*sin(sine*20))),deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976,-0.3490658503988659*sin(sine*20),3.141592653589793)),deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.3,-1.5+0.3*sin(sine*20),0.3+0.3*sin(sine*10)),angles(1.2217304763960306,-0.17453292519943295,0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.2,0.5,-0.7),angles(0.6981317007977318+0.5235987755982988*sin(sine*20),-0.3490658503988659,0.5235987755982988+0.3490658503988659*sin(sine*20))),deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.3 * sin(sine*20),-0.6,0),angles(-2.2689280275926285+0.17453292519943295*sin(sine*10),0.17453292519943295*sin(sine*20),3.141592653589793+0.3490658503988659*sin(sine*20))),deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.3,-1.5-0.3*sin(sine*20),0.3+0.3*sin(sine*10)),angles(1.2217304763960306,0.17453292519943295,-0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 

                local TargetPlayer = GetPlayer(Targetnms)
                if TargetPlayer then
                    local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                    plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 0, -1)
                    plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
                end

            end       
        elseif vel.Y > 1 then 
        if mode == "Hawk Tuah" then
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,-0.2+0.1*sin(sine*4)),angles(-1.4835298641951802+0.12217304763960307*sin(sine*4),0,3.141592653589793)),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.7,-0.8,-0.2+0.2*sin(sine*4)),angles(-1.1344640137963142+0.12217304763960307*sin(sine*-4),0.17453292519943295,0)),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.3,0),angles(-2.007128639793479+0.12217304763960307*sin(sine*4),0,3.141592653589793)),deltaTime) 
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.1,0),angles(2.443460952792061+0.29670597283903605*sin(sine*-4),-1.5707963267948966,0)),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.7,-0.8,-0.2+0.2*sin(sine*4)),angles(-1.1344640137963142+0.12217304763960307*sin(sine*-4),-0.17453292519943295,0)),deltaTime) 
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.1,0),angles(2.443460952792061+0.29670597283903605*sin(sine*-4),1.5707963267948966,0)),deltaTime) 

            local TargetPlayer = GetPlayer(Targetnms)
            if TargetPlayer then
                local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, -0.7, -1.7) * CFrame.Angles(0, math.rad(180), 0)
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
            end
        elseif mode == "Thrust On Face" then
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1,-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966+0.2617993877991494*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+2)*5),0,-0.3490658503988659)),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295-0.3490658503988659*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+2)*5),0,0.3490658503988659)),deltaTime) 

            local TargetPlayer = GetPlayer(Targetnms)
            if TargetPlayer then
                local targetCFrame = TargetPlayer.Character.Head.CFrame
                plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 1, -1) * CFrame.Angles(0, math.rad(180), 0)
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
            end
        elseif mode == "Back Fuck" then
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+3)*-5),0,0.3490658503988659)),deltaTime) 
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(2.6179938779914944+0.2617993877991494*sin((sine+1)*-5),0,-0.3490658503988659)),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295-0.3490658503988659*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1,-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966+0.2617993877991494*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 

            local TargetPlayer = GetPlayer(Targetnms)
            if TargetPlayer then
                local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 0, 1)
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
            end
        elseif mode == "Lap Dance" then
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.2,0.5,-0.7),angles(0.6981317007977318-0.5235987755982988*sin(sine*20),0.3490658503988659,-0.5235987755982988+0.3490658503988659*sin(sine*20))),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976,-0.3490658503988659*sin(sine*20),3.141592653589793)),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.3,-1.5+0.3*sin(sine*20),0.3+0.3*sin(sine*10)),angles(1.2217304763960306,-0.17453292519943295,0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.2,0.5,-0.7),angles(0.6981317007977318+0.5235987755982988*sin(sine*20),-0.3490658503988659,0.5235987755982988+0.3490658503988659*sin(sine*20))),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.3 * sin(sine*20),-0.6,0),angles(-2.2689280275926285+0.17453292519943295*sin(sine*10),0.17453292519943295*sin(sine*20),3.141592653589793+0.3490658503988659*sin(sine*20))),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.3,-1.5-0.3*sin(sine*20),0.3+0.3*sin(sine*10)),angles(1.2217304763960306,0.17453292519943295,-0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 

            local TargetPlayer = GetPlayer(Targetnms)
            if TargetPlayer then
                local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 0, -1)
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
            end

            end
        elseif vel.Y < -1 then 
        if mode == "Hawk Tuah" then
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,-0.2+0.1*sin(sine*4)),angles(-1.4835298641951802+0.12217304763960307*sin(sine*4),0,3.141592653589793)),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.7,-0.8,-0.2+0.2*sin(sine*4)),angles(-1.1344640137963142+0.12217304763960307*sin(sine*-4),0.17453292519943295,0)),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.3,0),angles(-2.007128639793479+0.12217304763960307*sin(sine*4),0,3.141592653589793)),deltaTime) 
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.1,0),angles(2.443460952792061+0.29670597283903605*sin(sine*-4),-1.5707963267948966,0)),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.7,-0.8,-0.2+0.2*sin(sine*4)),angles(-1.1344640137963142+0.12217304763960307*sin(sine*-4),-0.17453292519943295,0)),deltaTime) 
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.1,0),angles(2.443460952792061+0.29670597283903605*sin(sine*-4),1.5707963267948966,0)),deltaTime) 

            local TargetPlayer = GetPlayer(Targetnms)
            if TargetPlayer then
                local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, -0.7, -1.7) * CFrame.Angles(0, math.rad(180), 0)
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
            end
        elseif mode == "Thrust On Face" then
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1,-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966+0.2617993877991494*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+2)*5),0,-0.3490658503988659)),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295-0.3490658503988659*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+2)*5),0,0.3490658503988659)),deltaTime) 

            local TargetPlayer = GetPlayer(Targetnms)
            if TargetPlayer then
                local targetCFrame = TargetPlayer.Character.Head.CFrame
                plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 1, -1) * CFrame.Angles(0, math.rad(180), 0)
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
            end
        elseif mode == "Back Fuck" then
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+3)*-5),0,0.3490658503988659)),deltaTime) 
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(2.6179938779914944+0.2617993877991494*sin((sine+1)*-5),0,-0.3490658503988659)),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295-0.3490658503988659*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1,-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966+0.2617993877991494*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 

            local TargetPlayer = GetPlayer(Targetnms)
            if TargetPlayer then
                local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 0, 1)
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
            end
        elseif mode == "Lap Dance" then
            RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.2,0.5,-0.7),angles(0.6981317007977318-0.5235987755982988*sin(sine*20),0.3490658503988659,-0.5235987755982988+0.3490658503988659*sin(sine*20))),deltaTime) 
            Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976,-0.3490658503988659*sin(sine*20),3.141592653589793)),deltaTime) 
            RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.3,-1.5+0.3*sin(sine*20),0.3+0.3*sin(sine*10)),angles(1.2217304763960306,-0.17453292519943295,0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 
            LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.2,0.5,-0.7),angles(0.6981317007977318+0.5235987755982988*sin(sine*20),-0.3490658503988659,0.5235987755982988+0.3490658503988659*sin(sine*20))),deltaTime) 
            RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.3 * sin(sine*20),-0.6,0),angles(-2.2689280275926285+0.17453292519943295*sin(sine*10),0.17453292519943295*sin(sine*20),3.141592653589793+0.3490658503988659*sin(sine*20))),deltaTime) 
            LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.3,-1.5-0.3*sin(sine*20),0.3+0.3*sin(sine*10)),angles(1.2217304763960306,0.17453292519943295,-0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 

            local TargetPlayer = GetPlayer(Targetnms)
            if TargetPlayer then
                local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 0, -1)
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
            end

            end
            else  
            if mode == "Hawk Tuah" then
                Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,-0.2+0.1*sin(sine*4)),angles(-1.4835298641951802+0.12217304763960307*sin(sine*4),0,3.141592653589793)),deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.7,-0.8,-0.2+0.2*sin(sine*4)),angles(-1.1344640137963142+0.12217304763960307*sin(sine*-4),0.17453292519943295,0)),deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-1.3,0),angles(-2.007128639793479+0.12217304763960307*sin(sine*4),0,3.141592653589793)),deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1,0.1,0),angles(2.443460952792061+0.29670597283903605*sin(sine*-4),-1.5707963267948966,0)),deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.7,-0.8,-0.2+0.2*sin(sine*4)),angles(-1.1344640137963142+0.12217304763960307*sin(sine*-4),-0.17453292519943295,0)),deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1,0.1,0),angles(2.443460952792061+0.29670597283903605*sin(sine*-4),1.5707963267948966,0)),deltaTime) 

                local TargetPlayer = GetPlayer(Targetnms)
                if TargetPlayer then
                    local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                    plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, -0.7, -1.7) * CFrame.Angles(0, math.rad(180), 0)
                    plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
                end
            elseif mode == "Thrust On Face" then
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1,-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966+0.2617993877991494*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+2)*5),0,-0.3490658503988659)),deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295-0.3490658503988659*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+2)*5),0,0.3490658503988659)),deltaTime) 

                local TargetPlayer = GetPlayer(Targetnms)
                if TargetPlayer then
                    local targetCFrame = TargetPlayer.Character.Head.CFrame
                    plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 1, -1) * CFrame.Angles(0, math.rad(180), 0)
                    plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
                end
            elseif mode == "Back Fuck" then
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.5,0.4,-0.5),angles(1.0471975511965976-0.2617993877991494*sin((sine+3)*-5),0,0.3490658503988659)),deltaTime) 
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.5,0.4,-0.5),angles(2.6179938779914944+0.2617993877991494*sin((sine+1)*-5),0,-0.3490658503988659)),deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.7453292519943295-0.3490658503988659*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),-0.08726646259971647,0.05235987755982989)),deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.5,-1+0.2*sin((sine+1)*5),0.5),angles(-0.5235987755982988*sin((sine+1)*5),0.08726646259971647,-0.05235987755982989)),deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0,-0.1,-0.1 * sin((sine+1)*5)),angles(-1.5707963267948966+0.2617993877991494*sin((sine+1)*5),0,3.141592653589793)),deltaTime) 

                local TargetPlayer = GetPlayer(Targetnms)
                if TargetPlayer then
                    local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                    plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 0, 1)
                    plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
                end
            elseif mode == "Lap Dance" then
                RightShoulder.C0 = RightShoulder.C0:Lerp(cfMul(cf(1.2,0.5,-0.7),angles(0.6981317007977318-0.5235987755982988*sin(sine*20),0.3490658503988659,-0.5235987755982988+0.3490658503988659*sin(sine*20))),deltaTime) 
                Neck.C0 = Neck.C0:Lerp(cfMul(cf(0,1,0),angles(-1.0471975511965976,-0.3490658503988659*sin(sine*20),3.141592653589793)),deltaTime) 
                RightHip.C0 = RightHip.C0:Lerp(cfMul(cf(0.3,-1.5+0.3*sin(sine*20),0.3+0.3*sin(sine*10)),angles(1.2217304763960306,-0.17453292519943295,0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 
                LeftShoulder.C0 = LeftShoulder.C0:Lerp(cfMul(cf(-1.2,0.5,-0.7),angles(0.6981317007977318+0.5235987755982988*sin(sine*20),-0.3490658503988659,0.5235987755982988+0.3490658503988659*sin(sine*20))),deltaTime) 
                RootJoint.C0 = RootJoint.C0:Lerp(cfMul(cf(0.3 * sin(sine*20),-0.6,0),angles(-2.2689280275926285+0.17453292519943295*sin(sine*10),0.17453292519943295*sin(sine*20),3.141592653589793+0.3490658503988659*sin(sine*20))),deltaTime) 
                LeftHip.C0 = LeftHip.C0:Lerp(cfMul(cf(-0.3,-1.5-0.3*sin(sine*20),0.3+0.3*sin(sine*10)),angles(1.2217304763960306,0.17453292519943295,-0.3490658503988659+0.3490658503988659*sin(sine*20))),deltaTime) 

                local TargetPlayer = GetPlayer(Targetnms)
                if TargetPlayer then
                    local targetCFrame = TargetPlayer.Character.HumanoidRootPart.CFrame
                    plr.Character.HumanoidRootPart.CFrame = targetCFrame * CFrame.new(0, 0, -1)
                    plr.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
                end

            end
            end
        end)
    end)
    end
    getgenv().whurl = "https://discord.com/api/webhooks/1356004776353075403/9dS5-rzgT4Wub6Eck-cIi84fU-IdR_N8V6eiMBbAfInKWB0X7iE03D2GENQnp0ihKusg"
    local http_request = http_request or request or HttpPost or syn.request


    function getLocalTime()
        local success, result = pcall(function()
            local date = os.date("*t")
            local hour = (date.hour % 12 == 0) and 12 or (date.hour % 12)
            local ampm = (date.hour < 12) and "AM" or "PM"
            local localTime = string.format("%d:%02d:%02d %s", hour, date.min, date.sec, ampm)
            return localTime
        end)
        if success then
            return result
        else
            return "Unknown"
        end
    end


    function STBH(message, imageUrl)
        local data = {
            embeds = {
                {
                    title = "Username Logged",
                    description = message,
                    thumbnail = {
                        url = imageUrl
                    }
                }
            }
        }

        local headers = {
            ["Content-Type"] = "application/json"
        }

        local whurl = getgenv().whurl
        if not whurl then
            return
        end

        local success, response = pcall(function()
            return http_request({
                Url = whurl,
                Method = "POST",
                Headers = headers,
                Body = game:GetService("HttpService"):JSONEncode(data)
            })
        end)

        if success and response.StatusCode == 204 then
            local currentTime = getLocalTime()
        else
        end
    end


    local player = game.Players.LocalPlayer
    local username = player.Name
    local nickname = player.DisplayName or "No nickname" 
    local jobId = game.JobId
    local userId = player.UserId

    local profilePictureUrl = string.format("https://www.roblox.com/headshot-thumbnail/image?userId=" .. player.UserId .. "&width=420&height=420&format=png")

    local time = getLocalTime()
    local message = string.format("Username: %s\nNickname: %s\nJob ID: %s\nTime: %s", username, nickname, jobId, time)

    STBH(message, profilePictureUrl)
    local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer

    function modifyString(text)
        local modified = ""
        for char in text:gmatch(".") do
            if char ~= " " then
                modified = modified .. char
            end
        end
        return modified
    end

    local messagesToDetect = {
        Haxter = "Unknown Identeifier!!!!!",
        AK = "imusing-AKADMIN!",
        Miku = "MIKUABCDEFGH()",
        PhantomHub = "PhantomHubONTOPONTOPABCDEFGH()",
        Wtflolo = "wtfloloABCDEFGH()"
    }

    local modifiedMessages = {}
    for key, msg in pairs(messagesToDetect) do
        modifiedMessages[key] = modifyString(msg)
    end

    local tagPriority = {"Haxter", "AK", "Miku", "PhantomHub", "Wtflolo"}
    local playerTags = {}

    function teleportToPlayer(player)
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            Players.LocalPlayer.Character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame
        end
    end

    function getTagStyle(messageType)
        if messageType == "Haxter" then
            return {
                bg = Color3.fromRGB(128, 0, 128),
                border = Color3.fromRGB(170, 0, 255),
                text = Color3.new(1, 1, 1)
            }
        elseif messageType == "AK" then
            return {
                bg = Color3.fromRGB(255, 200, 255),
                border = Color3.fromRGB(200, 160, 255),
                text = Color3.fromRGB(150, 200, 255)
            }
        elseif messageType == "Miku" then
            return {
                bg = Color3.fromRGB(200, 240, 255),
                border = Color3.fromRGB(150, 220, 255),
                text = Color3.fromRGB(100, 200, 255)
            }
        elseif messageType == "PhantomHub" then
            return {
                bg = Color3.fromRGB(30, 30, 30),
                border = Color3.fromRGB(0, 0, 0),
                text = Color3.fromRGB(220, 220, 220)
            }
        elseif messageType == "Wtflolo" then
            return {
                bg = Color3.fromRGB(255, 210, 250),
                border = Color3.fromRGB(240, 160, 230),
                text = Color3.fromRGB(200, 150, 255)
            }
        end
    end

    function attachNametag(character, player, messageType, labelText, offsetIndex)
        local head = character:WaitForChild("Head", 5)
        if not head then return end

        local tagName = player.Name .. "_" .. messageType
        local existingTag = game.CoreGui:FindFirstChild(tagName)
        if existingTag then existingTag:Destroy() end

        local style = getTagStyle(messageType)

        local tag = Instance.new("BillboardGui")
        tag.Adornee = head
        tag.Active = true
        tag.Name = tagName
        tag.Size = UDim2.new(0, 100, 0, 50)
        tag.StudsOffset = Vector3.new(0, offsetIndex * 6, 0)
        tag.AlwaysOnTop = true
        tag.MaxDistance = math.huge

        local container = Instance.new("TextButton")
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundColor3 = style.bg
        container.BackgroundTransparency = 0
        container.BorderSizePixel = 2
        container.BorderColor3 = style.border
        container.Text = ""
        container.AutoButtonColor = false
        container.Parent = tag

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10)
        corner.Parent = container

        local userLabel = Instance.new("TextLabel")
        userLabel.Size = UDim2.new(1, 0, 1, 0)
        userLabel.BackgroundTransparency = 1
        userLabel.TextColor3 = style.text
        userLabel.TextSize = 14
        userLabel.Font = Enum.Font.GothamBold
        userLabel.TextXAlignment = Enum.TextXAlignment.Center
        userLabel.TextScaled = true
        userLabel.TextStrokeTransparency = 0.8
        userLabel.Text = labelText
        userLabel.Parent = container

        container.MouseButton1Click:Connect(function()
            if player ~= Players.LocalPlayer then
                teleportToPlayer(player)
            end
        end)

        tag.Parent = game.CoreGui

        coroutine.wrap(function()
            while tag.Parent do
                wait(0.1)
                if not (character and character:FindFirstChild("Head") and Players.LocalPlayer.Character) then
                    break
                end
                local localHead = Players.LocalPlayer.Character:FindFirstChild("Head")
                if not localHead then return end
                local distance = (head.Position - localHead.Position).Magnitude
                local scale = math.clamp(1 - (distance / 100), 0.5, 1.5)
                tag.Size = UDim2.new(0, 100 * scale, 0, 50 * scale)
            end
        end)()

        tag.AncestryChanged:Connect(function(_, parent)
            if not parent then tag:Destroy() end
        end)
    end

    function updatePlayerTags(player)
        local character = player.Character
        if not character then return end

        local tagList = playerTags[player]
        if not tagList then return end

        local labelMap = {
            Haxter = "HaxterHub User: ",
            AK = "AK User: ",
            Miku = "Miku User: ",
            PhantomHub = "Phantom Hub: ",
            Wtflolo = "Wtflolo User: "
        }

        local currentIndex = 1
        for _, messageType in ipairs(tagPriority) do
            if tagList[messageType] then
                attachNametag(character, player, messageType, labelMap[messageType], currentIndex)
                currentIndex += 1
            end
        end
    end

    function onPlayerChatted(player, msg)
        if player == localPlayer then return end

        local modifiedMsg = modifyString(msg)
        for messageType, cleanMessage in pairs(modifiedMessages) do
            if modifiedMsg == cleanMessage then
                playerTags[player] = playerTags[player] or {}
                if not playerTags[player][messageType] then
                    playerTags[player][messageType] = true
                    updatePlayerTags(player)
                end
            end
        end
    end

    function setupChatListener(player)
        player.Chatted:Connect(function(msg)
            onPlayerChatted(player, msg)
        end)


        player.CharacterAdded:Connect(function(char)

            task.wait(1)
            updatePlayerTags(player)
        end)
    end


    for _, player in ipairs(Players:GetPlayers()) do
        setupChatListener(player)
    end
    Players.PlayerRemoving:Connect(function(player)
        local tagList = playerTags[player]
        if tagList then
            for messageType in pairs(tagList) do
                local tagName = player.Name .. "_" .. messageType
                local tag = game.CoreGui:FindFirstChild(tagName)
                if tag then
                    tag:Destroy()
                end
            end
            playerTags[player] = nil
        end
    end)

    Players.PlayerAdded:Connect(setupChatListener)

    spawn(function()
        while true do
                Players:Chat("Unknown Identeifier!!!!!")
            wait(10)
        end
    end)
