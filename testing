local player = game.Players.LocalPlayer
local emotesGui = player:WaitForChild("PlayerGui"):WaitForChild("Emotes")
local emoteContainer = emotesGui:WaitForChild("MainFrame"):WaitForChild("EmoteContainer")
local HttpService = game:GetService("HttpService")

local function serializeCFrame(cf)
	local components = {cf:GetComponents()}
	return string.format("CFrame.new(%s)", table.concat(components, ", "))
end

local function serializeTable(t, indent)
	indent = indent or ""
	local lines = {}
	table.insert(lines, "{")
	local nextIndent = indent .. "    "
	for k, v in pairs(t) do
		local keyStr
		if type(k) == "string" and k:match("^%a[%w_]*$") then
			keyStr = k .. " = "
		else
			keyStr = "[" .. (type(k) == "string" and ("%q"):format(k) or tostring(k)) .. "] = "
		end

		if type(v) == "table" then
			if v.Time and v.Data then
				local frameLines = {}
				table.insert(frameLines, "{Time = " .. string.format("%.3f", v.Time) .. ", Data = {")
				for part, cf in pairs(v.Data) do
					table.insert(frameLines, "        [" .. ("%q"):format(part) .. "] = " .. serializeCFrame(cf) .. ",")
				end
				table.insert(frameLines, "    }},")
				table.insert(lines, indent .. keyStr .. table.concat(frameLines, "\n" .. indent .. "    "))
			else
				table.insert(lines, indent .. keyStr .. serializeTable(v, nextIndent))
			end
		elseif type(v) == "string" then
			table.insert(lines, indent .. keyStr .. ("%q"):format(v) .. ",")
		else
			table.insert(lines, indent .. keyStr .. tostring(v) .. ",")
		end
	end
	table.insert(lines, indent .. "}")
	return table.concat(lines, "\n")
end

local function saveCurrentAnimation(animationId, emoteLabel)
	task.wait(0.1)

	local animAsset
	local success, result = pcall(function()
		return game:GetObjects("rbxassetid://" .. animationId)[1]
	end)
	if success then animAsset = result else return warn("‚ùå Failed to load anim:", animationId) end

	local keyframes = animAsset:GetKeyframes()
	table.sort(keyframes, function(a, b) return a.Time < b.Time end)

	local result = {}
	for _, keyframe in ipairs(keyframes) do
		local frame = { Time = keyframe.Time, Data = {} }
		for _, pose in ipairs(keyframe:GetDescendants()) do
			if pose:IsA("Pose") then
				frame.Data[pose.Name] = pose.CFrame
			end
		end
		table.insert(result, frame)
	end

	-- Load existing emotes table if exists
	local emotesTable = {}
	if isfile("EmoteToPlay.lua") then
		local func = loadstring(readfile("EmoteToPlay.lua"))
		if func then
			local ok, data = pcall(func)
			if ok and type(data) == "table" then
				emotesTable = data
			end
		end
	end

	-- Add or overwrite this emote
	emotesTable[emoteLabel] = result

	-- Save updated table to file
	local output = "return " .. serializeTable(emotesTable)
	writefile("EmoteToPlay.lua", output)

	-- ‚úÖ Logging all emotes
	print("üì¶ Emote List:")
	local count = 0
	for label, data in pairs(emotesTable) do
		local firstTrack = (type(data) == "table" and type(data[1]) == "table") and data[1] or nil
		local idText = firstTrack and ("(%.3f sec)"):format(firstTrack.Time) or "(?)"
		print("üü™", label, idText)
		count += 1
	end
	print("üî¢ Total emotes:", count)
	print("‚úÖ New emote saved:", emoteLabel, "= rbxassetid://" .. tostring(animationId))

	-- Optional: Refresh dropdown if defined
	if typeof(refreshDropdown) == "function" then
		refreshDropdown()
	end
end

local function onButtonClicked(button)
	local emoteLabelObject = button.Parent:FindFirstChild("Emote")
	if not emoteLabelObject then return end
	local emoteLabel = emoteLabelObject.Text

	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local animator = humanoid and humanoid:FindFirstChildOfClass("Animator")
	if not animator then return end

	task.wait(0.1)

	for _, track in pairs(animator:GetPlayingAnimationTracks()) do
		local animation = track.Animation
		if animation and animation.AnimationId and animation.AnimationId ~= "" then
			local id = animation.AnimationId:match("%d+")
			if id then
				saveCurrentAnimation(id, emoteLabel)
				break
			end
		end
	end
end

-- Connect all current buttons
for _, button in ipairs(emoteContainer:GetDescendants()) do
	if button:IsA("TextButton") or button:IsA("ImageButton") then
		button.MouseButton1Click:Connect(function()
			onButtonClicked(button)
		end)
	end
end

-- Watch for future buttons
emoteContainer.DescendantAdded:Connect(function(child)
	if child:IsA("TextButton") or child:IsA("ImageButton") then
		child.MouseButton1Click:Connect(function()
			onButtonClicked(child)
		end)
	end
end)
